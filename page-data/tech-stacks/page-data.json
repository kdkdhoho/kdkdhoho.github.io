{"componentChunkName":"component---src-templates-post-jsx","path":"/tech-stacks/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"459e8307-ece6-532e-bb97-8b556f52ba0b","excerpt":"Java 17 우아한테크코스에서 진행한 미션들의 Java 버전은 11이었습니다. 모든 팀원들에게 익숙한 버전은 11 버전임은 부정할 수 없는 사실이지만, 그럼에도 17 버전을 선택한 이유는 다음과 같습니다. 생산성 17 버전에 포함된 Record 타입, String 블럭 사용, Stream.toList()사용 으로 생산성 향상을 기대했기 때문입니다. 우테…","html":"<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/21ffa5090d4e6d50fc811bb5e28085dd/3c266/tech_stack_icons.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 38.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAACFklEQVR42n2RT0iTARyGP7qH0SBmsKHkISvsIIGXDuYUG5j/UhfLDg41UnFu09Smkkus1DW/hfPLmX+wNQ+Ftpw6tyWoQw+W0SHykB7y0K2gg67p0zdP1qHn/j68v/cn6HWl9Dv7aeqtxeHso9bWyEOnHXP9HXoedWJpbqGuwYzDYae9rRW72EeHuxbRZWfCO4V/dg5zSysmi4VYLIYgQ1FZIelVaorLr5FWcYWrhhLOqU9QmpeBKvUip5LPkJubzYXzZ8kv05JtU1F8U4tr/A2SZ5rE04moVGqi0SjCkCQRiUSQXBLhhTCjY2MEAwtMeCZ5Pe3D+9KLW3Lj988yMjzCQjDIgMtJKBxmZHSceTmztrrK8soKcQRBocZkNJGQpEBryCclOYnLmZks+iaZezVOm/UuTd0NGK5r0aUpuK0rpiZFQbVex8njx+iQZ4gTP/dQmK4p4NngENqqIu6J9yks1FJZYyDknyIwM4VTfMKDPhtdHbK4MovuditNeVk8tnWSk53J82H338JeYwFezwtqmit4OuDAI67jc3+ktUskp0CPNChRX2fE99bPr90Yu/JO33/85Lcs2NuLcnBwwFGES0qBRpMJZWoCulslWG8s0VMdkWXlCMoMjCYzGk0WoigeBvb39/kfwkzgHd92dlhaXGbzyybra5/YWP/Mxof3BOUHbG19JRQKsb29fRiIN/q31VHhH+e+vvn+V3k8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='프로젝트에서 선택한 기술 스택 아이콘' title='' src='/static/21ffa5090d4e6d50fc811bb5e28085dd/ca1dc/tech_stack_icons.png' srcset='/static/21ffa5090d4e6d50fc811bb5e28085dd/e7570/tech_stack_icons.png 170w,\n/static/21ffa5090d4e6d50fc811bb5e28085dd/f46e7/tech_stack_icons.png 340w,\n/static/21ffa5090d4e6d50fc811bb5e28085dd/ca1dc/tech_stack_icons.png 680w,\n/static/21ffa5090d4e6d50fc811bb5e28085dd/02d09/tech_stack_icons.png 1020w,\n/static/21ffa5090d4e6d50fc811bb5e28085dd/9d567/tech_stack_icons.png 1360w,\n/static/21ffa5090d4e6d50fc811bb5e28085dd/3c266/tech_stack_icons.png 3923w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>프로젝트에서 선택한 기술 스택 아이콘</figcaption>\n  </figure></p>\n<h2>Java 17</h2>\n<p>우아한테크코스에서 진행한 미션들의 Java 버전은 11이었습니다.</p>\n<p>모든 팀원들에게 익숙한 버전은 11 버전임은 부정할 수 없는 사실이지만, 그럼에도 17 버전을 선택한 이유는 다음과 같습니다.</p>\n<h3>생산성</h3>\n<p>17 버전에 포함된 <strong>Record 타입, String 블럭 사용, Stream.toList()</strong>사용 으로 생산성 향상을 기대했기 때문입니다.</p>\n<p>우테코에서 진행하는 프로젝트 특성상 2주 단위로 기능을 빠르게 추가해야 하는 상황이었습니다.</p>\n<p>따라서 팀에게 있어 생산성도 중요한 가치라고 판단했습니다.</p>\n<blockquote>\n<p>Record 타입은 JDK 14에 추가됐습니다. <a href=\"https://www.baeldung.com/java-record-keyword\">관련 글</a><br>\nString 블럭은 JDK 15에 추가됐습니다. <a href=\"https://www.baeldung.com/java-text-blocks\">관련 글</a>\nStreams.toList()는 JDK 17에 추가됐습니다. <a href=\"https://www.baeldung.com/java-stream-to-list-collecting\">관련 글</a></p>\n</blockquote>\n<h3>JDK 8, 11에 이은 LTS 버전</h3>\n<p>JDK 11은 26년 9월, JDK 17은 31년 9월까지 지원하는 LTS 버전입니다.</p>\n<p>셀럽잇 프로젝트를 앞으로 몇 년이고 지속할 수 있는 가능성이 존재했습니다.</p>\n<p>또한, 신규 프로젝트를 진행하는 상황에 있어 레거시를 고려할 필요는 없을 뿐더러 앞으로 있을 미래를 대비하는 것이 현명하다고 판단했습니다.</p>\n<h3>더 나은 GC 성능</h3>\n<p>이는 추가적인 이유를 찾아보다가 발견한 이유입니다.</p>\n<p>바로, JDK 11보다 더 나은 GC 성능을 가진다는 것인데요.</p>\n<p>G1 GC의 경우 JDK 11에 비해, 8.66% 더 빠르다는 벤치마킹 결과가 존재하는 것을 확인할 수 있었습니다.</p>\n<blockquote>\n<p><a href=\"https://www.optaplanner.org/blog/2021/09/15/HowMuchFasterIsJava17.html\">참고 문서</a></p>\n</blockquote>\n<p>GC 개선, JIT 컴파일러 개선, 클래스 데이터 공유로 인한 개선으로 인한 것이라고 합니다.</p>\n<h2>Spring Boot 3</h2>\n<p>Java 17은 Spring Boot 3 부터 지원을 강제하는 이유에서 선택했습니다.</p>\n<h2>Nginx</h2>\n<p>초기 개발 단계에서 React와 Spring이 한 대의 EC2 인스턴스 내에 존재했습니다.</p>\n<p>따라서 접속 URL에 따라 포트 포워딩을 할 필요가 있었습니다.</p>\n<p>추가로, Nginx와 연동 가능하며 HTTPS 적용에 필요한 SSL 인증서를 발급해주는 무료 오픈소스인 <a href=\"https://letsencrypt.org/\">Let's Encrypt</a>를 사용하여 간편하게 HTTPS 적용을 하기 위해 사용했습니다.</p>\n<blockquote>\n<p><a href=\"https://youtu.be/6FAwAXXj5N0?feature=shared\">[10분 테코톡] 🤫 피케이의 Nginx</a></p>\n</blockquote>\n<h2>JPA &#x26; Spring Data JPA</h2>\n<p>사실 처음에는, JPA를 사용해본 적이 없는 팀원이 저를 포함해 2명이 있었습니다.</p>\n<p>따라서 처음엔 발생할 수 있는 문제에 모든 팀원이 대응할 수 있기 위해 JDBC를 사용했는데요.</p>\n<p>개발을 본격적으로 시작하기까지는 조금의 시간이 있었습니다.</p>\n<p>그 시간동안 JPA를 학습할 수 있었고, JPA를 통해 개발 초기에 빠르게 개발할 수 있다는 점에서 선택을 변경했습니다.</p>\n<p>또한, JPA는 객체와 RDBMS의 패러다임 불일치를 해결해준다는 점에서 큰 메리트를 느꼈습니다.</p>\n<h2>QueryDsl</h2>\n<p>셀럽잇이 제공하는 기능 중, 음식점을 다양한 조건으로 필터링하여 조회하는 기능이 있었습니다.</p>\n<p>해당 기능을 구현하기 위해서는 동적 쿼리를 만들어야 했는데요.</p>\n<p>QueryDsl을 선택하기 전의 동적 쿼리는 유지보수가 매우 힘들었습니다.</p>\n<p>따라서 유지보수를 위해 도입했습니다.</p>\n<h2>Docker</h2>\n<p>초기 개발 단계에서 운영 단계를 준비하는 과정에서 동일한 환경을 쉽게 세팅하기 위해 사용했습니다.</p>\n<h2>nGrinder</h2>\n<p>부하 테스트 툴로써 다른 대안이었던 JMeter에 비해 더 편리한 사용성과 편리한 UI/UX, 그리고 무엇보다 한국어를 지원한다는 점에서 선택했습니다.</p>\n<h2>Grafana, Prometheus, Loki, Promtail</h2>\n<p>다른 대안이었던 AWS CloudWatch는 새로 학습해야 하는 학습 비용이 존재했습니다. 동시에 금전적인 비용이 들어갑니다.</p>\n<p>사실 <em>Grafana, Prometheus, Loki, Promtail</em>도 팀원 전체가 학습을 해야하는 건 마찬가지였지만, 인프런에 김영한 님의 관련 강의가 존재하였고 이를 통해 쉽게 기술을 익혀 사용할 수 있을 것으로 판단했습니다.</p>\n<p>동시에 모두 무료 오픈소스인 점에서 선택했습니다.</p>\n<h2>S3</h2>\n<p>음식점에 대한 정보 중, 음식점 사진이 존재했습니다.</p>\n<p>초기에는 사진을 모두 EC2 인스턴스 내에 저장하여, 정적으로 Serving 했습니다.</p>\n<p>하지만 음식점의 수가 증가함에 따라 사진 파일의 수도 증가하고, 그에 따라 서버의 용량을 걱정하지 않을 수 없었습니다.</p>\n<p>동시에, React로 개발한 결과물을 빌드한 것은 모두 정적인 자원이며, EC2 인스턴스 내에서 빌드하는 데에 많은 시간이 걸렸습니다.</p>\n<p>따라서 정적 자원들은 스토리지에서 제공하기 위해 사용했습니다.</p>\n<h2>CloudFront</h2>\n<p>S3를 그냥 사용하면 보안과 관련된 문제가 발생할 수 있습니다.</p>\n<p>또, S3에 있는 자원에 접근하려면 매우 길고 이상한 URL로 접근을 해야 했습니다.</p>\n<p>이를 해결하기 위해 CDN 역할의 AWS CloudFront를 도입했습니다.</p>\n<h2>Github Actions</h2>\n<p>CI/CD 툴로 사용했습니다.</p>\n<p>다른 대안이었던 Jenkins는 팀원 전체가 학습할 시간이 필요했습니다.</p>\n<p>따라서 바로 적용할 수 있는 CI/CD 툴을 적용했습니다.</p>\n<h2>OAuth 2.0</h2>\n<p>OAuth 2.0을 적용하면 사용자의 개인 정보를 저장하지 않아도 되는 장점이 있습니다.</p>\n<p>또한, 사용자 퍼널 개선을 위한 목적으로 선택했습니다.</p>","frontmatter":{"title":"셀럽잇의 기술 스택 및 선정 이유","date":"July 07, 2023","update":null,"tags":["celuveat"],"series":"셀럽잇 프로젝트"},"fields":{"slug":"/tech-stacks/","readingTime":{"minutes":7.75}}},"seriesList":{"edges":[{"node":{"id":"459e8307-ece6-532e-bb97-8b556f52ba0b","fields":{"slug":"/tech-stacks/"},"frontmatter":{"title":"셀럽잇의 기술 스택 및 선정 이유"}}}]},"previous":null,"next":{"fields":{"slug":"/dbcp/"},"frontmatter":{"title":"DBCP와 HikariCP 이해하기"}}},"pageContext":{"id":"459e8307-ece6-532e-bb97-8b556f52ba0b","series":"셀럽잇 프로젝트","previousPostId":null,"nextPostId":"3b94cbd6-f64a-5d82-96a2-0761602c250b"}},"staticQueryHashes":[],"slicesMap":{}}