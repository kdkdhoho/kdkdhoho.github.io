{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/05-lock-of-innodb-storage-engine/","result":{"data":{"site":{"siteMetadata":{"title":"김동호 블로그"}},"markdownRemark":{"id":"72bc6762-eb43-5244-99d8-899122b583d2","excerpt":"Lock에는 MySQL 엔진이 관리하는 Lock과 InnoDB 스토리지 엔진이 관리하는 락이 있다. 이번에는 InnoDB 스토리지 엔진이 관리하는 Lock에 대해 알아보자. 레코드 락 InnoDB 엔진이 관리하는 락 중에서 핵심이다. 다른 DBMS…","html":"<p>Lock에는 MySQL 엔진이 관리하는 Lock과 InnoDB 스토리지 엔진이 관리하는 락이 있다.</p>\n<p>이번에는 InnoDB 스토리지 엔진이 관리하는 Lock에 대해 알아보자.</p>\n<h2 id=\"레코드-락\" style=\"position:relative;\"><a href=\"#%EB%A0%88%EC%BD%94%EB%93%9C-%EB%9D%BD\" aria-label=\"레코드 락 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>레코드 락</h2>\n<p>InnoDB 엔진이 관리하는 락 중에서 핵심이다.</p>\n<p>다른 DBMS의 레코드 락과 동일하지만 한 가지 중요한 차이는 <strong>레코드 자체가 아니라 인덱스의 레코드를 잠근다는 것이다.</strong><br>\n따로 생성한 세컨더리 인덱스 뿐만 아니라 PK 인덱스도 마찬가지다.<br>\n다만, PK 인덱스는 갭 락을 걸지 않고 레코드 락만 걸지만 세컨더리 인덱스에서는 넥스트 키 락 또는 갭 락을 이용한다.</p>\n<h2 id=\"갭-락\" style=\"position:relative;\"><a href=\"#%EA%B0%AD-%EB%9D%BD\" aria-label=\"갭 락 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>갭 락</h2>\n<p>갭 락은 <strong>레코드와 해당 레코드와 바로 인접한 레코드 사이 간격을 잠그는 것을 의미</strong>한다.</p>\n<p>갭 락의 역할은 <strong>레코드와 레코드 사이에 새로운 레코드가 INSERT 되는 것을 막기 위함</strong>이다.</p>\n<p>갭 락 그 자체보다는 넥스트 키 락의 일부로 자주 사용된다.</p>\n<h2 id=\"넥스트-키-락\" style=\"position:relative;\"><a href=\"#%EB%84%A5%EC%8A%A4%ED%8A%B8-%ED%82%A4-%EB%9D%BD\" aria-label=\"넥스트 키 락 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>넥스트 키 락</h2>\n<p>레코드 락과 갭 락을 합쳐놓은 형태의 잠금이다.</p>\n<p>갭 락이나 넥스트 키 락의 주목적은, 바이너리 로그에 기록되는 쿼리가 Slave 서버에서 실행될 때 Master 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이다.</p>\n<blockquote>\n<p><a href=\"https://www.linux.co.kr/bbs/board.php?bo_table=lecture&#x26;wr_id=5775\">바이너리 로그?</a></p>\n</blockquote>\n<h2 id=\"auto-increment-락\" style=\"position:relative;\"><a href=\"#auto-increment-%EB%9D%BD\" aria-label=\"auto increment 락 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Auto Increment 락</h2>\n<p>MySQL에는 테이블에 INSERT 할 때, 자동 증가하는 숫자를 넣어주는 <code class=\"language-text\">AUTO_INCREMENT</code> 칼럼 속성이 존재한다.</p>\n<p>보통 ID 칼럼에 사용하곤 하는데, 테이블에 동시에 여러 건의 INSERT가 발생하는 경우 저장되는 각 레코드의 ID 값은 중복되지 않고 순서대로 증가하는 값이 자동으로 저장된다.</p>\n<p>InnoDB 스토리지 엔진에서는 이 작업을 위해 내부적으로 <strong>AUTO_INCREMENT 락</strong> 이라고 하는 테이블 수준의 잠금을 사용한다.</p>\n<p>어쩌면 당연하게 새로운 레코드를 저장하는 쿼리, INSERT, REPLACE 쿼리에서만 작동한다.</p>\n<p>해당 락은, <strong>트랜잭션과 상관없이 INSERT 혹은 REPLACE 쿼리에서 AUTO_INCREMENT 값을 가져올 때만 락이 걸렸다가 즉시 해제한다.</strong></p>\n<p>AUTO_INCREMENT 락은 테이블 당 하나만 존재한다.<br>\n따라서 2개 이상의 INSERT 쿼리가 동시에 실행되는 경우, 하나의 쿼리가 해당 테이블에 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 락이 해제될 때까지 기다려야 한다.</p>\n<blockquote>\n<p>참고로 AUTO_INCREMENT 칼럼에 값을 명시적으로 넣어준 쿼리가 실행되어도 AUTO_INCREMENT 락은 수행된다. 그 이유는, AUTO_INCREMENT 속성이 걸린 칼럼에 값이 명시적으로 담겨져\nINSERT 되면, AUTO_INCREMENT 값을 재설정하는 작업이 수행되기 떄문이다.</p>\n</blockquote>\n<p>AUTO_INCREMENT 락은 명시적으로 획득하고 해제하는 방법은 없다.<br>\n그리고 아주 짧은 시간동안 존재하는 락이기 때문에 대부분 문제가 잘 되지 않는다.</p>\n<p>지금까지는 MySQL 5.0 이하 버전에서 사용되던 방식이다.<br>\nMySQL 5.1 이상부터는 <code class=\"language-text\">innodb_autoinc_lock_mode</code> 시스템 변수를 이용해 작동 방식을 변경할 수 있다.</p>\n<h3 id=\"innodb_autoinc_lock_mode--0\" style=\"position:relative;\"><a href=\"#innodb_autoinc_lock_mode--0\" aria-label=\"innodb_autoinc_lock_mode  0 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>innodb_autoinc_lock_mode = 0</h3>\n<p>위에서 설명된 방식 그대로 사용한다.</p>\n<h3 id=\"innodb_autoinc_lock_mode--1\" style=\"position:relative;\"><a href=\"#innodb_autoinc_lock_mode--1\" aria-label=\"innodb_autoinc_lock_mode  1 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>innodb_autoinc_lock_mode = 1</h3>\n<p>MySQL 서버가 INSERT 되는 레코드의 수를 정확히 예측할 수 있을 때에는 AUTO_INCREMENT 락을 걸지 않고, 훨씬 빠른 래치(뮤텍스)를 이용한다.</p>\n<p>락이 존재하는 타이밍이 존재하긴 하지만 AUTO_INCREMNET 락보다는 훨씬 빠르게 테이블에 락을 걸고 해제하게 된다.</p>\n<p>다만, _INSERT 되는 레코드의 수를 정확히 예측할 수 있어야 한다_는 전제 조건이 있기 때문에 이 조건을 만족하지 못하면 AUTO_INCREMENT를 사용한다.</p>\n<p>대량의 INSERT 쿼리가 처리될 때는, InnoDB 스토리지 엔진이 AUTO_INCREMENT 값을 한 번에 여러 값을 할당받아서 사용한다.<br>\n하지만 이때 할당받은 값을 모두 사용하지 못하게 되면 폐기하게 되어, 그 다음 INSERT 쿼리에서 AUTO_INCREMENT 값은 중간 값이 누락된 값이 저장될 수 있다.</p>\n<p>위 설정에서는 하나의 INSERT 쿼리로 저장되는 레코드는 연속된 자동 증가 값을 가진다는 특징을 가진다.<br>\n따라서 이 설정 모드를 <em>연속 모드</em> 라고도 한다.</p>\n<h3 id=\"innodb_autoinc_lock_mode--2\" style=\"position:relative;\"><a href=\"#innodb_autoinc_lock_mode--2\" aria-label=\"innodb_autoinc_lock_mode  2 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>innodb_autoinc_lock_mode = 2</h3>\n<p>해당 설정은 AUTO_INCREMENT 락을 걸지 않고 가벼운 래치(뮤텍스)를 사용한다.</p>\n<p>이 설정에서는 <strong>대량 INSERT 문장이 실행되는 중에도 다른 커넥션에서 INSERT를 수행할 수 있다.</strong><br>\n결과적으로 동시 처리 성능이 높아진다.</p>\n<p>하지만 자동 증가 값이 연속되는 것은 보장할 수 없다. 단지 유니크한 값만 생성한다는 것만 보장한다.<br>\n하나의 INSERT 쿼리로 저장할 때에도 순서는 보장할 수 없다. 따라서 <em>인터리빙 모드</em> 라고도 한다.</p>\n<p>위 설정에서 <strong>STATEMENT 포맷의 바이너리 로그를 사용하는 Replication 에서는 Master와 Slave의 AUTO_INCREMENT 값이 달라질 수 있다.</strong><br>\nSTATEMENT 포맷의 바이너리 로그를 사용한다면 mode 값을 1로 설정하자.</p>\n<h2 id=\"인덱스와-innodb의-잠금\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%99%80-innodb%EC%9D%98-%EC%9E%A0%EA%B8%88\" aria-label=\"인덱스와 innodb의 잠금 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스와 InnoDB의 잠금</h2>\n<p>레코드 락에서 언급한대로 InnoDB는 <strong>레코드 자체가 아니라 인덱스의 레코드를 잠근다.</strong></p>\n<p>이 말은 즉슨, <strong>SELECT나 UPDATE, DELETE 처럼 변경해야 할 레코드를 찾기 위해 인덱스를 타고 검색하게 되는데, 이 과정에서 조건에 해당하는 레코드를 전부 잠근다.</strong></p>\n<p>MySQL의 InnoDB에서 인덱스 설계가 중요한 이유 또한 이것이다.</p>\n<h3 id=\"레코드-수준의-잠금-확인-및-해제\" style=\"position:relative;\"><a href=\"#%EB%A0%88%EC%BD%94%EB%93%9C-%EC%88%98%EC%A4%80%EC%9D%98-%EC%9E%A0%EA%B8%88-%ED%99%95%EC%9D%B8-%EB%B0%8F-%ED%95%B4%EC%A0%9C\" aria-label=\"레코드 수준의 잠금 확인 및 해제 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>레코드 수준의 잠금 확인 및 해제</h3>\n<p>MySQL 8.0부터는 performance_schema의 data_locks와 data_lock_waits 테이블을 통해 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\"># 현재 프로세스의 목록을 조회한다.</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">SHOW</span> PROCESSLIST<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\"># performance_schema의 data_locks와 data_lock_waits 테이블을 통해 잠금 대기 순서를 조회한다.</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span> \n    r<span class=\"token punctuation\">.</span>trx_id waiting_trx_id<span class=\"token punctuation\">,</span> \n    r<span class=\"token punctuation\">.</span>trx_mysql_thread_id waiting_thread<span class=\"token punctuation\">,</span> \n    r<span class=\"token punctuation\">.</span>trx_query waiting_query<span class=\"token punctuation\">,</span> \n    b<span class=\"token punctuation\">.</span>trx_id blocking_trx_id<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">.</span>trx_mysql_thread_id blocking_thread<span class=\"token punctuation\">,</span> \n    b<span class=\"token punctuation\">.</span>trx_query blocking_query \n    <span class=\"token keyword\">FROM</span> performance_schema<span class=\"token punctuation\">.</span>data_lock_watis w\n    <span class=\"token keyword\">JOIN</span> information_schema<span class=\"token punctuation\">.</span>innodb_trx b\n    <span class=\"token keyword\">ON</span> b<span class=\"token punctuation\">.</span>trx_id <span class=\"token operator\">=</span> w<span class=\"token punctuation\">.</span>blocking_engine_transaction_id\n    <span class=\"token keyword\">JOIN</span> infromation_schema<span class=\"token punctuation\">.</span>innodb_trx r\n    <span class=\"token keyword\">ON</span> r<span class=\"token punctuation\">.</span>trx_id <span class=\"token operator\">=</span> w<span class=\"token punctuation\">.</span>requesting_engine_transaction_id<span class=\"token punctuation\">;</span>\n    \n<span class=\"token comment\"># 각 스레드가 어떤 잠금을 가지는지 상세하게 조회한다.</span>\nmysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> performance_schema<span class=\"token punctuation\">.</span>data_locks\\G</code></pre></div>\n<p>문제가 되는 잠금이 있다면 <code class=\"language-text\">mysql> KILL {thread_id}</code> 를 통해 스레드를 강제 종료하자.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<blockquote>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/example-auto-increment.html\">https://dev.mysql.com/doc/refman/8.0/en/example-auto-increment.html</a></li>\n<li><a href=\"https://product.kyobobook.co.kr/detail/S000001766482\">https://product.kyobobook.co.kr/detail/S000001766482</a></li>\n</ul>\n</blockquote>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%A0%88%EC%BD%94%EB%93%9C-%EB%9D%BD\">레코드 락</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%AD-%EB%9D%BD\">갭 락</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%84%A5%EC%8A%A4%ED%8A%B8-%ED%82%A4-%EB%9D%BD\">넥스트 키 락</a></p>\n</li>\n<li>\n<p><a href=\"#auto-increment-%EB%9D%BD\">Auto Increment 락</a></p>\n<ul>\n<li><a href=\"#innodb_autoinc_lock_mode--0\">innodb_autoinc_lock_mode = 0</a></li>\n<li><a href=\"#innodb_autoinc_lock_mode--1\">innodb_autoinc_lock_mode = 1</a></li>\n<li><a href=\"#innodb_autoinc_lock_mode--2\">innodb_autoinc_lock_mode = 2</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%99%80-innodb%EC%9D%98-%EC%9E%A0%EA%B8%88\">인덱스와 InnoDB의 잠금</a></p>\n<ul>\n<li><a href=\"#%EB%A0%88%EC%BD%94%EB%93%9C-%EC%88%98%EC%A4%80%EC%9D%98-%EC%9E%A0%EA%B8%88-%ED%99%95%EC%9D%B8-%EB%B0%8F-%ED%95%B4%EC%A0%9C\">레코드 수준의 잠금 확인 및 해제</a></li>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"InnoDB 스토리지 엔진의 락","date":"2024년 1월 11일","dateISO":"2024-01-11","description":"InnoDB 스토리지 엔진 레벨의 락에 대해 이해해보자","tags":["database","MySQL"]}},"previous":{"fields":{"slug":"/posts/05-isolation-level-of-mysql/"},"frontmatter":{"title":"MySQL의 격리 수준"}},"next":{"fields":{"slug":"/posts/add-feat-and-issue-number-automatically/"},"frontmatter":{"title":"[git&github] IntelliJ에서 커밋 메시지 작성 시, 자동으로 커밋 타입과 이슈 번호 추가하기"}}},"pageContext":{"id":"72bc6762-eb43-5244-99d8-899122b583d2","previousPostId":"c451e992-096b-509c-bfd8-dc052cd4759f","nextPostId":"ef32e2f8-ab6a-56ae-ba1c-a56ce715f661"}},"staticQueryHashes":["2637872971","3361002528","3414707483"],"slicesMap":{}}