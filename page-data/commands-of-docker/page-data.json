{"componentChunkName":"component---src-templates-post-jsx","path":"/commands-of-docker/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"7b9b6854-62e7-5f25-afbf-d5459fa5d021","excerpt":"웬만하면 처럼, 를 통해 바로 파악하거나 공식 문서를 통해 자세히 이해할 수 있다. 그래도 도커를 공부하면서 유용한 명령어들을 정리할 겸 작성한다. 치트 시트 mysql 띄우기 버전 관련 : 도커의 버전을 확인한다. : 도커 버전을 간략하게 확인한다. 이미지 관련 : 도커 허브에서 이미지를 받는다. : 도커 엔진에 존재하는 이미지 목록을 출력한다. 컨테이…","html":"<p>웬만하면 <code class=\"language-text\">docker command --help</code>처럼, <code class=\"language-text\">--help</code>를 통해 바로 파악하거나 공식 문서를 통해 자세히 이해할 수 있다.</p>\n<p>그래도 도커를 공부하면서 유용한 명령어들을 정리할 겸 작성한다.</p>\n<h2>치트 시트</h2>\n<ul>\n<li>\n<p>mysql 띄우기</p>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\">docker run -d \\\n--name mysql \\\n-p 3306:3306 \\\n-e MYSQL_ROOT_PASSWORD=root \\\n-e MYSQL_USER=sa \\\n-e MYSQL_ALLOW_EMPTY_PASSWORD=yes \\\n-e MYSQL_DATABASE=listywave \\\n-v /Users/dongho/mysql_container:/var/lib/mysql \\\nmysql</code></pre></div>\n</li>\n</ul>\n<h2>버전 관련</h2>\n<ul>\n<li><code class=\"language-text\">docker version</code>: 도커의 버전을 확인한다.</li>\n<li><code class=\"language-text\">docker -v</code>: 도커 버전을 간략하게 확인한다.</li>\n</ul>\n<h2>이미지 관련</h2>\n<ul>\n<li><code class=\"language-text\">docker pull NAME[:TAG]</code>: 도커 허브에서 이미지를 받는다.</li>\n<li><code class=\"language-text\">docker images</code>: 도커 엔진에 존재하는 이미지 목록을 출력한다.</li>\n</ul>\n<h2>컨테이너 관련</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">docker run</code>: 컨테이너를 생성과 동시에 실행한다. 내부로 들어간다.</p>\n<ul>\n<li><code class=\"language-text\">-i</code>: 상호 입출력을 설정한다.</li>\n<li><code class=\"language-text\">-t</code>: tty를 활성하하여 bash shell을 사용한다.</li>\n<li><code class=\"language-text\">--name NAME</code>: 컨테이너 이름을 설정한다.</li>\n<li>\n<p><code class=\"language-text\">-p</code>: 호스트의 포트와 컨테이너의 포트를 바인딩해 연결한다.</p>\n<ul>\n<li><code class=\"language-text\">-p [호스트의 포트]:[컨테이너의 포트]</code></li>\n<li>컨테이너에 접속할 호스트의 포트를 설정하고, 해당 컨테이너의 포트에 해당하는 프로세스로 통신하는 것이다.</li>\n</ul>\n</li>\n<li>ex) <code class=\"language-text\">docker run -i -t --name myUbuntu -p 7777:80 ubuntu:14.04</code></li>\n<li><code class=\"language-text\">-d</code>: <code class=\"language-text\">-i</code>, <code class=\"language-text\">-t</code>가 접근 가능한 상태, Attach로 설정했다면, <code class=\"language-text\">-d</code>는 Detached 모드로 설정한다.</li>\n<li><code class=\"language-text\">-e</code>: 컨테이너 내부의 환경변수를 설정한다.</li>\n<li>\n<p><code class=\"language-text\">-v</code>: 컨테이너에 볼륨을 설정한다.</p>\n<ul>\n<li><code class=\"language-text\">-v HOST_DIRECTORY:CONTAINER_DIRECTORY</code>: 호스트 볼륨 공유 설정</li>\n<li><code class=\"language-text\">-v VOLUME_NAME:CONTAINER_DIRECTORY</code>: 도커 볼륨 설정</li>\n</ul>\n</li>\n<li><code class=\"language-text\">--net DRIVER_NAME</code>: 네트워크 드라이버를 설정한다.</li>\n<li><code class=\"language-text\">--net-alias HOST_NAME</code>: 컨테이너의 Domain Name을 설정한다.</li>\n<li><code class=\"language-text\">--log-opt max-size={} | max-file={}</code>: 컨테이너가 남기는 로그 파일의 최대 용량과 개수를 설정한다.</li>\n<li>\n<p><code class=\"language-text\">--restart</code>: 컨테이너의 재시작 옵션을 설정한다.</p>\n<ul>\n<li><code class=\"language-text\">no</code>: 아무런 재시작 동작을 하지 않는다. 기본값.</li>\n<li><code class=\"language-text\">on-failure</code>: 에러로 종료할 때 재시작한다.</li>\n<li><code class=\"language-text\">always</code>: 항상 재시작한다. 수동으로 종료한 경우, Docker가 재시작되면 함께 재시작된다.</li>\n<li><code class=\"language-text\">unless-stopped</code>: 컨테이너가 종료되지 않는 한, 매번 재시작된다. 직접 종료 후 재시작 전까지는, Docker가 재시작돼도 컨테이너는 재시작하지 않는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">docker update</code>: 컨테이너의 설정을 변경한다.</li>\n<li><code class=\"language-text\">docker create NAME|ID</code>: 컨테이너를 단순히 생성만 한다. 내부로 들어가진 않는다.</li>\n<li><code class=\"language-text\">docker start NAME|ID</code>: 컨테이너를 실행한다.</li>\n<li><code class=\"language-text\">docker attach NAME|ID</code>: 컨테이너 내부로 들어간다.</li>\n<li>\n<p><code class=\"language-text\">docker exec [OPTIONS] CONTAINER COMMAND</code>: 컨테이너 내부에서 명령어를 실행한다.</p>\n<ul>\n<li>ex) <code class=\"language-text\">docker exec -it mysql /bin/bash</code>: mysql 컨테이너에 bash shell을 통해 접근한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">exit</code>: 컨테이너를 정지시킴과 동시에 내부에서 빠져나온다.</li>\n<li><code class=\"language-text\">Ctrl + P + Q</code>: 컨테이너를 정지시키지 않고 내부에서 빠져나온다.</li>\n<li><code class=\"language-text\">Ctrl + D</code>: 빠져나옴과 동시에 컨테이너를 종료한다.</li>\n<li><code class=\"language-text\">docker inspect NAME|ID</code>: 도커 객체에 대해 저수준의 정보까지 출력한다.</li>\n<li>\n<p><code class=\"language-text\">docker ps</code>: 실행중인 컨테이너 정보 출력한다.</p>\n<ul>\n<li><code class=\"language-text\">-a</code>: 정지된 컨테이너도 모두 출력한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">docker rename NAME|ID NEW_NAME</code>: 컨테이너의 이름을 변경한다.</li>\n<li><code class=\"language-text\">docker stop NAME|ID</code>: 컨테이너를 중지한다.</li>\n<li>\n<p><code class=\"language-text\">docker rm NAME|ID</code>: 컨테이너를 삭제한다.</p>\n<ul>\n<li><code class=\"language-text\">-f</code>: 실행 중인 컨테이너를 강제로 삭제한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">docker container prune</code>: 모든 컨테이너를 삭제한다.</li>\n<li><code class=\"language-text\">docker volume creat NAME</code>: 도커 볼륨을 생성한다.</li>\n</ul>\n<h2>네트워크 관련</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">docker network create --driver DRIVER DRIVER_NAME</code></p>\n<ul>\n<li><code class=\"language-text\">docker run -it --net DRIVER_NAME</code>: NAME에 해당하는 네트워크 드라이버를 통해 컨테이너를 생성한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">docker network disconnect DRIVER_NAME CONTAINER_NAME</code>: 컨테이너에 네트워크를 할당 해제한다. </li>\n<li><code class=\"language-text\">docker network connect DRIVER_NAME CONTAINER_NAME</code>: 컨테이너에 네트워크를 할당한다.</li>\n</ul>\n<h2>로깅 관련</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">docker logs CONTAINER</code>: 컨테이너의 로그를 확인한다.</p>\n<ul>\n<li><code class=\"language-text\">--tail n</code>: 뒤에서부터 n줄을 출력한다.</li>\n<li><code class=\"language-text\">--since Unix_Time</code>: 특정 시간 이후의 로그를 확인한다.</li>\n<li><code class=\"language-text\">-t</code>: 타임 스탬프를 출력한다.</li>\n<li><code class=\"language-text\">-f</code>: 로그를 실시간으로 확인한다.</li>\n</ul>\n</li>\n</ul>\n<h2>이미지 관련</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code>: 컨테이너를 이미지로 만들어 도커 허브에 커밋한다.</p>\n<ul>\n<li><code class=\"language-text\">-a, --author</code>: 작성자</li>\n<li><code class=\"language-text\">-m, --message</code>: 커밋 메시지</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">docker save [OPTIONS] IMAGE</code>: 이미지를 파일로 추출한다.</p>\n<ul>\n<li><code class=\"language-text\">-o, --output NAME</code>: 추출될 파일명을 설정한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">docker load [OPTIONS]</code>: 추출된 이미지를 도커로 업로드한다.</p>\n<ul>\n<li><code class=\"language-text\">-i, --input FILE</code>: 업로드 할 파일명을 선언한다. </li>\n</ul>\n</li>\n<li><code class=\"language-text\">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code>: SOURCE<em>IMAGE의 이름에 TARGET</em>IMAGE을 추가한다.</li>\n</ul>","frontmatter":{"title":"[Docker] 도커의 기본적인 명령어들","date":"May 01, 2024","update":null,"tags":["docker"],"series":null},"fields":{"slug":"/commands-of-docker/","readingTime":{"minutes":5.965}}},"seriesList":{"edges":[{"node":{"id":"a30ff988-ea74-5562-b241-90fbff73a3da","fields":{"slug":"/kissoft-retrospection/"},"frontmatter":{"title":"키스소프트 현장실습 회고"}}},{"node":{"id":"aedd8f5b-dd45-5a14-9b57-3a48cdc0b641","fields":{"slug":"/what-is-varargs/"},"frontmatter":{"title":"[Java] Varargs는 어떻게 사용하고, 사용했을 때 장점이 무엇일까?"}}},{"node":{"id":"d41198ca-d162-523b-84f8-128b247a19b4","fields":{"slug":"/apply-https/"},"frontmatter":{"title":"[셀럽잇] HTTPS 적용기"}}},{"node":{"id":"3b94cbd6-f64a-5d82-96a2-0761602c250b","fields":{"slug":"/dbcp/"},"frontmatter":{"title":"DBCP와 HikariCP 이해하기"}}},{"node":{"id":"c418073e-50be-5fe1-807d-478c9c47f640","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"무중단 배포 이해하기"}}},{"node":{"id":"c5760ea9-e137-5edf-8244-3a93e25b067b","fields":{"slug":"/unit-test/"},"frontmatter":{"title":"단위 테스트 이해하기"}}},{"node":{"id":"8ae82b3f-5b72-555c-89fe-9939dcf8377c","fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"title":"JUnit과 AssertJ 활용법"}}},{"node":{"id":"91a7a622-00f8-5cca-b6c1-e4f7db7ee31e","fields":{"slug":"/about-tdd/"},"frontmatter":{"title":"TDD 이해하기"}}},{"node":{"id":"10e0dab4-d2e7-52df-8daa-31bfef1b08b6","fields":{"slug":"/static-with-memory-structure/"},"frontmatter":{"title":"static을 더 잘 사용하기"}}},{"node":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","fields":{"slug":"/about-garbage-collection/"},"frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리"}}},{"node":{"id":"0bf99b61-98a4-5c40-b8ce-05a918d212f7","fields":{"slug":"/garbage-collection-tuning/"},"frontmatter":{"title":"Garbage Collection 튜닝에 대해"}}},{"node":{"id":"61bd95c2-424a-54c8-96d9-bec4c8a4f58c","fields":{"slug":"/garbage-collection-algorithms/"},"frontmatter":{"title":"Garbage Collection 알고리즘"}}},{"node":{"id":"c87443bb-4e35-55e7-94d5-a5cb70d2dbc8","fields":{"slug":"/cautions-for-using-collections-in-Java/"},"frontmatter":{"title":"Java에서 컬렉션을 사용할 때 주의할 점"}}},{"node":{"id":"c2d7615d-6232-5fce-8794-f4c790106bb5","fields":{"slug":"/2023-retrospection/"},"frontmatter":{"title":"2023년 회고록"}}},{"node":{"id":"def28d41-907f-5432-8060-ed5429114882","fields":{"slug":"/compare-of-datetime-and-timestamp/"},"frontmatter":{"title":"[MySQL] DATETIME vs TIMESTAMP"}}},{"node":{"id":"9bf8ca89-e021-526b-a7b5-2cce0b1e366f","fields":{"slug":"/add-feat-and-issue-number-automatically/"},"frontmatter":{"title":"[git&github] IntelliJ에서 커밋 메시지 작성 시, 자동으로 커밋 타입과 이슈 번호 추가하기"}}},{"node":{"id":"01318426-7520-5a57-92ff-c917e1483247","fields":{"slug":"/difference-of-controller-and-restcontroller/"},"frontmatter":{"title":"[Spring] @Controller와 @RestController 비교하기"}}},{"node":{"id":"bc68fa05-ec4a-5e12-a9b8-4e58769887df","fields":{"slug":"/deploy-spring-boot-in-aws-ec2-manually/"},"frontmatter":{"title":"[Infra] AWS EC2에 Spring Boot 수작업으로 배포하기"}}},{"node":{"id":"122a1e9c-6fe5-5e7f-b797-a31f54d086b0","fields":{"slug":"/what-is-ami-architecture-of-ec2/"},"frontmatter":{"title":"CPU 아키텍처란?"}}},{"node":{"id":"c23a12ff-7b48-57ef-91ed-81f5386d680a","fields":{"slug":"/apply-issue-and-pr-template/"},"frontmatter":{"title":"[github] Github Repository에 Issue, PR Template 적용하기"}}},{"node":{"id":"b1dc584d-3c69-5ae8-82a8-09b015fa3d02","fields":{"slug":"/oauth-test/"},"frontmatter":{"title":"Spring Boot에서 Rest Assured로 인수 테스트할 때 OAuth 로그인 처리하기"}}},{"node":{"id":"9f43b8a7-b5ce-5766-b984-3ed0775d698f","fields":{"slug":"/ioc-container-and-di/"},"frontmatter":{"title":"[Spring] 스프링 컨테이너, 그리고 IoC/DI"}}},{"node":{"id":"e1b2a9fb-d6e3-5f65-9f50-d3a30c2518d1","fields":{"slug":"/what-is-jdbc/"},"frontmatter":{"title":"[Java] JDBC 파헤쳐보기"}}},{"node":{"id":"81b7fb10-f532-5f48-a797-379c3bb99bee","fields":{"slug":"/understanding-transaction-and-concurrency-problem/"},"frontmatter":{"title":"[MySQL] 트랜잭션과 트랜잭션 격리 수준"}}},{"node":{"id":"adfb7cc4-25f1-5b31-8060-e40d763b0afe","fields":{"slug":"/sovle-concurrency-problem/"},"frontmatter":{"title":"[ListyWave] 리스트 수정 시, 동시성 이슈 발생 확인 및 해결기"}}},{"node":{"id":"5ecb4a12-dc98-589f-94e0-695fb2d84fab","fields":{"slug":"/restore-using-binarylog/"},"frontmatter":{"title":"[MySQL] 바이너리 로그로 데이터 복구하기"}}},{"node":{"id":"c375e6a2-7e6c-5607-a579-04d3ab5f3188","fields":{"slug":"/understanding-generic/"},"frontmatter":{"title":"[Java] 제네릭 이해하기"}}},{"node":{"id":"83ad74c1-0d46-5f86-92fc-998642e4367d","fields":{"slug":"/covariant-invariant-and-pecs/"},"frontmatter":{"title":"[Java] 배열의 공변, 제네릭의 불공변. 그리고 PECS"}}},{"node":{"id":"7b9b6854-62e7-5f25-afbf-d5459fa5d021","fields":{"slug":"/commands-of-docker/"},"frontmatter":{"title":"[Docker] 도커의 기본적인 명령어들"}}},{"node":{"id":"d77e8b24-f01d-5673-8c55-d93e2d110c4f","fields":{"slug":"/enhance-speed-ci-workflow/"},"frontmatter":{"title":"[Infra] Github Actions를 이용한 CI 작업 속도를 캐싱으로 개선하기"}}},{"node":{"id":"b4550a40-b215-5e9a-a6a7-8c27bfb63e25","fields":{"slug":"/continuous-deploy-using-github-actions-and-docker/"},"frontmatter":{"title":"[Infra] Github Actions와 Docker를 이용해 배포 자동화 구축하기"}}},{"node":{"id":"e38bb1ed-1a51-5947-a1d2-52aaae42ac97","fields":{"slug":"/build-monitoring-system/"},"frontmatter":{"title":"[Infra] Prometheus와 Grafana, 그리고 Docker를 이용해 모니터링 대시보드 구축하기"}}},{"node":{"id":"961e4fc3-1d57-55a3-99fd-9e1233cef1dd","fields":{"slug":"/june-3rd/"},"frontmatter":{"title":"[회고] 06.10 ~ 06.16"}}},{"node":{"id":"fcade266-d38c-5c36-a3b7-87d56d9be862","fields":{"slug":"/june-4th-and-5th/"},"frontmatter":{"title":"[회고] 06.17 ~ 06.30"}}},{"node":{"id":"7b64a367-9192-557d-b45d-0e3bc68d44d3","fields":{"slug":"/thread-in-jvm/"},"frontmatter":{"title":"Java Thread 1 - Java의 Thread에 대해 알아보자"}}},{"node":{"id":"9e5a98c2-ba89-5b36-8e72-0028211a2c5b","fields":{"slug":"/status-and-control-thread-in-java/"},"frontmatter":{"title":"Java Thread 2 - Java Thread의 상태와 행동을 제어하는 방법"}}},{"node":{"id":"45a781cf-0e04-559c-a853-d1609dab1bd4","fields":{"slug":"/synchronize-threads/"},"frontmatter":{"title":"Java Thread 3 - Thread 동기화하기"}}},{"node":{"id":"236f7305-5647-51fe-800e-61577d25cd0c","fields":{"slug":"/july-1st/"},"frontmatter":{"title":"[회고] 07.01 ~ 07.07"}}},{"node":{"id":"abad5436-5cba-50a3-8fda-72440c646a78","fields":{"slug":"/solid/"},"frontmatter":{"title":"객체지향 설계 원칙: SOLID"}}},{"node":{"id":"f113bb3f-df7e-589a-b3c1-378c812ac8da","fields":{"slug":"/insert-dummy-data-to-db/"},"frontmatter":{"title":"[Spring] 스프링 애플리케이션 동작과 동시에 DB에 더미 데이터 삽입하기"}}},{"node":{"id":"7890e82c-9f9c-52ed-9724-2efc1ddf8aef","fields":{"slug":"/procedure-function-package/"},"frontmatter":{"title":"[DB] 프로시저, 함수, 패키지에 대해"}}},{"node":{"id":"ac276a35-d955-59ae-9f71-28ad65030c42","fields":{"slug":"/july-2nd-3rd-4th/"},"frontmatter":{"title":"[회고] 07.08 ~ 07.23"}}},{"node":{"id":"4a801b76-317f-5129-a330-84fc989993c8","fields":{"slug":"/inner-class/"},"frontmatter":{"title":"[Java] inner 클래스와 종류에 대해"}}},{"node":{"id":"549069af-32e1-578d-a8c0-7524f6305a7d","fields":{"slug":"/execute-and-executeUpdate-of-jdbc/"},"frontmatter":{"title":"[JDBC] execute(String)과 execute(). executeUpdate(String)와 executeUpdate()의 차이"}}},{"node":{"id":"e0484580-3f9a-597b-bdb4-386532933e65","fields":{"slug":"/log-and-disk/"},"frontmatter":{"title":"EC2 CPU 사용량이 급격히 늘어난 문제 해결"}}},{"node":{"id":"3b97179a-f8a3-521b-a603-cfa1453ea898","fields":{"slug":"/august-1st/"},"frontmatter":{"title":"[회고] 07.29 ~ 08.04"}}},{"node":{"id":"5e74fe27-5b86-593d-bade-e5c49c12e0fc","fields":{"slug":"/august-2st/"},"frontmatter":{"title":"[회고] 08.05 ~ 08.11"}}}]},"previous":{"fields":{"slug":"/covariant-invariant-and-pecs/"},"frontmatter":{"title":"[Java] 배열의 공변, 제네릭의 불공변. 그리고 PECS"}},"next":{"fields":{"slug":"/10-web-attacks/"},"frontmatter":{"title":"11장. 웹 공격 기술"}}},"pageContext":{"id":"7b9b6854-62e7-5f25-afbf-d5459fa5d021","series":null,"previousPostId":"83ad74c1-0d46-5f86-92fc-998642e4367d","nextPostId":"b78b4291-fdd7-58a7-af5a-12a262962280"}},"staticQueryHashes":[],"slicesMap":{}}