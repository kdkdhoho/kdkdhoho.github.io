{"componentChunkName":"component---src-templates-blog-post-js","path":"/소프트웨어-테스트/TestContainer-vs-H2-DB/","result":{"data":{"site":{"siteMetadata":{"title":"김동호 블로그"}},"markdownRemark":{"id":"f2358b97-5d49-54be-86a0-70c2476fc2ce","excerpt":"1. 들어가며 Spring Boot로 백엔드 API를 개발할 때, 데이터베이스와 연동되는 테스트는 필수적입니다. 기존에는 운영 환경(MySQL)과 100% 동일한 환경을 보장하기 위해 TestContainers를 사용했습니다. 하지만 프로젝트 규모가 커짐에 따라 GitHub…","html":"<h1 id=\"1-들어가며\" style=\"position:relative;\"><a href=\"#1-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"1 들어가며 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 들어가며</h1>\n<p>Spring Boot로 백엔드 API를 개발할 때, 데이터베이스와 연동되는 테스트는 필수적입니다.<br>\n기존에는 운영 환경(MySQL)과 100% 동일한 환경을 보장하기 위해 TestContainers를 사용했습니다.</p>\n<p>하지만 프로젝트 규모가 커짐에 따라 <strong>GitHub Actions에서 수행되는 CI 과정의 빌드 시간이 3분을 넘어가기 시작</strong>했습니다. 이는 잦은 배포에 하나의 병목 지점이 되었습니다.<br>\n이를 해결하기 위해 <strong>인메모리 DB인 H2로 전환</strong>을 결정했고, 결과적으로 <strong>빌드 시간을 1분으로 단축</strong>할 수 있었습니다.</p>\n<p>이 과정에서 왜 TestContainers가 느린지, 그리고 테스트 환경 불일치 문제는 어떻게 관리했는지에 대한 분석을 기록해보려고 합니다.</p>\n<hr>\n<h1 id=\"2-testcontainers-vs-h2-성능-병목의-근본적-원인\" style=\"position:relative;\"><a href=\"#2-testcontainers-vs-h2-%EC%84%B1%EB%8A%A5-%EB%B3%91%EB%AA%A9%EC%9D%98-%EA%B7%BC%EB%B3%B8%EC%A0%81-%EC%9B%90%EC%9D%B8\" aria-label=\"2 testcontainers vs h2 성능 병목의 근본적 원인 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. TestContainers vs H2: 성능 병목의 근본적 원인</h1>\n<p>TestContainers를 사용할 때 발생하는 약 2분의 지연은 어디서 오는 걸까요? 단순히 DB 엔진의 차이를 넘어 인프라 구조적인 차이가 큽니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8bd9087c874c9f4c872f1bbd57e71708/2bef9/thumbnail.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.43037974683544%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClElEQVR42mWS6U4aURiGuZHeQf/2LnpF/dM0jT+aJjZd0iWxda0rqFUQwY1lgIGRbdhGBpDBjcEFZFGk6tMZaE2bfsmcSc45efJ+53ssGFU+qRFM5UmoGlGlhJQrEVfLqAcn5jH39/d/fXf9vfZ1k0w5Ru/25vedwb7FXFqdDoIYJhSOkEhl8AZEPIEQx/rpP0CzdF1HTqZIJlJI0QiZVBZZlmk2mwNgoqwzuRnl+6aEVUgRk1MEDLDH52MrtIsvoTxAr3s99NMG2YM9NnLzbOaWEUoOCgcaZ/UmP29vsaRPmkz5snx1x5iXNLbFOKFEhqAUxebyIiTz/KnTegPBSGYTtpiUPjMnvGR6dxJHOMhuXqV13R203Gh1CMkKEaOV9R1f/2/f8uMJRvqgbrdLz0xXr2OXAox7HEwLS1g33rAguVnwOhCzUVpXVwOg2x9mZtVNMJHGvrGFV4rh8ovEcyrmy9ntdhZti5y2WiyGjLvxJaak13xwDmETh4zOnOykk1y22wOgzeVhzRPAF95lxxjItpFsWwiR3itizq5Wq6FXq1TrFywFfUyKq0z5x5h3vmBGXGBCcOKOR2nf9LAcGpN0eENY13f6sJGpOVwegU9jMyyvbfRbvrsbKKFfXLBiAD/+sDIuWLGGx5kIOHm+OMu78WcUkhEsuZLG/rGOUj7EH4kyOmvD5Qsyt7bN6MIq2eLBg2eNdoeIrBopXUzLw3wLvGIlP8LTofc8evyE5bdvsVQMqaO5AmbSvWKJWEImpRiSZxSy6j557ehBG1OLdqfLeeuS8lmJop6n1tYR42mGhr9wdFwdvGGlUiGdyXBeKdNQFZR0GlVVDYmr/4mtaRr5vbwRQKNyUkJVChQLKg3DAFPsXw1qAEy+ziOEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TestContainers와 H2 비교\"\n        title=\"\"\n        src=\"/static/8bd9087c874c9f4c872f1bbd57e71708/f058b/thumbnail.png\"\n        srcset=\"/static/8bd9087c874c9f4c872f1bbd57e71708/c26ae/thumbnail.png 158w,\n/static/8bd9087c874c9f4c872f1bbd57e71708/6bdcf/thumbnail.png 315w,\n/static/8bd9087c874c9f4c872f1bbd57e71708/f058b/thumbnail.png 630w,\n/static/8bd9087c874c9f4c872f1bbd57e71708/40601/thumbnail.png 945w,\n/static/8bd9087c874c9f4c872f1bbd57e71708/2bef9/thumbnail.png 1024w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 id=\"21-인프라-라이프사이클과-오버헤드\" style=\"position:relative;\"><a href=\"#21-%EC%9D%B8%ED%94%84%EB%9D%BC-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4%EA%B3%BC-%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C\" aria-label=\"21 인프라 라이프사이클과 오버헤드 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 인프라 라이프사이클과 오버헤드</h2>\n<ul>\n<li><strong>컨테이너 초기화 비용</strong>: H2는 JVM 내에서 객체가 생성되는 수준으로 즉시 실행됩니다. 반면 TestContainers는 Docker Daemon에 요청을 보내고, 이미지를 Pull 하고, 컨테이너를 생성/실행하는 무거운 과정을 거칩니다.</li>\n<li><strong>Ready-Check 메커니즘</strong>: 컨테이너가 뜬 후에도 내부의 MySQL 프로세스가 완전히 올라올 때까지 <em>Wait Strategy</em> 가 동작하며 추가로 수~수십 초를 대기합니다.</li>\n<li><strong>Cleanup 프로세스</strong>: 테스트 종료 후 <em>Ryuk</em> 컨테이너(TestContainers의 리소스 정리용 컨테이너)가 리소스를 정리하는 과정 또한 CI 환경에서는 모두 비용입니다.</li>\n</ul>\n<h2 id=\"22-io-관점의-차이-memory-vs-disknetwork\" style=\"position:relative;\"><a href=\"#22-io-%EA%B4%80%EC%A0%90%EC%9D%98-%EC%B0%A8%EC%9D%B4-memory-vs-disknetwork\" aria-label=\"22 io 관점의 차이 memory vs disknetwork permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2 I/O 관점의 차이 (Memory vs Disk/Network)</h2>\n<p>I/O 성능은 이 두 방식의 격차를 가장 크게 만드는 요인입니다.</p>\n<ul>\n<li><strong>저장 매체 (RAM vs Storage)</strong>: H2는 JVM Heap 메모리에 데이터를 저장하므로 디스크 I/O가 0입니다. 반면, MySQL은 기본적으로 영속성을 위해 Docker 내부의 가상 파일 시스템(<em>Virtual File System</em>)에 데이터를 기록하며 실제 디스크 I/O를 유발합니다.</li>\n<li><strong>전송 계층 (Method Call vs Network Stack)</strong>:\n<ul>\n<li><strong>H2</strong>: 동일 프로세스 내 통신으로 비용이 사실상 없습니다.</li>\n<li><strong>TestContainers:</strong> 애플리케이션(Host)에서 컨테이너(Guest)로 데이터를 보낼 때 TCP/IP 네트워크 스택과 Docker Bridge Network를 통과해야 하며, 이 과정에서 컨텍스트 스위칭이 발생합니다.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-리스크-관리-환경-불일치를-어떻게-극복했는가\" style=\"position:relative;\"><a href=\"#3-%EB%A6%AC%EC%8A%A4%ED%81%AC-%EA%B4%80%EB%A6%AC-%ED%99%98%EA%B2%BD-%EB%B6%88%EC%9D%BC%EC%B9%98%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B7%B9%EB%B3%B5%ED%96%88%EB%8A%94%EA%B0%80\" aria-label=\"3 리스크 관리 환경 불일치를 어떻게 극복했는가 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 리스크 관리: '환경 불일치'를 어떻게 극복했는가?</h2>\n<p>이렇게 H2 DB로 전환함에 따라 속도를 얻은 대신 잃게 되는 가장 큰 가치는 <strong>운영 환경과의 동일성</strong>입니다.<br>\nH2에 MySQL 모드가 있긴 합니다만, SQL Parser 수준의 호환성을 지원할 뿐, MySQL과 완전히 동일한 방식으로 동작하지는 않습니다.</p>\n<p>따라서 특정 구현체에 종속되지 않도록 다음과 같은 전략으로 이 차이를 극복했습니다.</p>\n<ol>\n<li><strong>프로덕션 코드에서 모두 JPA에 의존한다.</strong></li>\n</ol>\n<p>프로덕션 코드에서 DB와 통신하는 모든 코드는 JPQL과 Spring Data JPA를 사용함으로써 JPA에 의존하도록 했습니다.<br>\nJPA를 사용하면 구현체에 따라 알아서 SQL을 만들어주기에 구현체를 변경하더라도 안전합니다.</p>\n<ol start=\"3\">\n<li><strong>테스트 격리 시, Truncate SQL 대신 JPA의 <code class=\"language-text\">deleteAllInBatch()</code> 사용</strong></li>\n</ol>\n<p>기존에는 <em>DatabaseCleaner</em> 라는 객체 안에서 Junit5의 <code class=\"language-text\">@BeforeEach</code> 단계마다 Truncate SQL을 통해 직접 DB CleanUp을 수행했습니다.<br>\n이를 위해 외래키 제약 조건을 잠시 해제했다가 다시 설정해줬는데요. 이때 MySQL과 H2의 쿼리가 달랐습니다.</p>\n<p>MySQL은 <code class=\"language-text\">SET FOREIGN_KEY_CHECKS = 0;</code>, H2는 <code class=\"language-text\">SET REFERENTIAL_INTEGRITY FALSE;</code>를 사용합니다. 이 차이로 테스트 환경이 달라져 실패가 발생했습니다.</p>\n<p>그래서 Truncate SQL 대신 <code class=\"language-text\">deleteAllInBatch()</code>를 순서대로 호출해 벤더 종속 없이 데이터를 정리했습니다.</p>\n<blockquote>\n<p>물론 위 방법은 삭제 순서를 반드시 지켜야하며 모든 엔티티마다 삭제 코드를 반드시 추가해야 한다는 수고로움이 있긴 했습니다.</p>\n</blockquote>\n<hr>\n<h1 id=\"4-testcontainers를-포기할-수-없다면-최적화-대안\" style=\"position:relative;\"><a href=\"#4-testcontainers%EB%A5%BC-%ED%8F%AC%EA%B8%B0%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4%EB%A9%B4-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%8C%80%EC%95%88\" aria-label=\"4 testcontainers를 포기할 수 없다면 최적화 대안 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. TestContainers를 포기할 수 없다면? (최적화 대안)</h1>\n<p>만약 프로덕션 코드에서 특정 DB에 종속적인 SQL으로 구현된 로직이 있거나, 운영 DB와 동일한 환경에서 테스트를 해야 한다면 TestContainers 사용이 불가피할 수 있습니다.</p>\n<p>이 경우에는 아래 방법들을 고려하여 TestContainers를 이용한 테스트 속도를 향상해볼 수 있습니다.</p>\n<ul>\n<li><strong><a href=\"https://java.testcontainers.org/features/reuse/\">Reusable Containers</a> (v2.0.3+):</strong> 테스트가 끝나도 컨테이너를 유지하여 다음 테스트 시 재사용합니다. 하지만 GitHub Actions 같은 일회성 CI 환경에서는 적용이 어렵다는 한계가 있습니다.</li>\n<li><strong>CI 환경 Docker Image 캐싱:</strong> <a href=\"https://docs.github.com/en/actions/reference/workflows-and-actions/dependency-caching\">GitHub Actions의 캐시 기능</a>을 이용해 이미지 Pull 시간을 단축할 수 있습니다.</li>\n<li><strong>MySQL 설정 최적화:</strong> <code class=\"language-text\">innodb_flush_log_at_trx_commit=0</code> 등 데이터 유실을 감수하더라도 속도를 극대화하는 옵션을 <code class=\"language-text\">withCommand</code>로 주입하여 초기화 속도를 높일 수 있습니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// MySQL 컨테이너 기동 속도 최적화 예시</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">MySQLContainer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mysql:8.0\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">withCommand</span><span class=\"token punctuation\">(</span>\n        <span class=\"token string\">\"--innodb_flush_log_at_trx_commit=0\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"--sync_binlog=0\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"--innodb_use_native_aio=0\"</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h1 id=\"5-마치며\" style=\"position:relative;\"><a href=\"#5-%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"5 마치며 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 마치며</h1>\n<p>CI 빌드 시간을 3분에서 1분으로 단축함에 따라 더 잦은 배포가 가능하게 되었고, 이는 생산성과 시스템 안정성 향상을 야기할 수 있었습니다.</p>\n<p>중요한 것은 <strong>어떤 도구가 더 좋은가</strong>가 아니라, <strong>현재 우리 팀의 상황에서 어떤 불편함을 해결해야 하는가</strong>를 파악하고 그에 따른 기회비용을 관리하는 능력이라고 생각합니다.</p>\n<h1 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h1>\n<ul>\n<li><a href=\"https://testcontainers.com/\">Testcontainers 공식 문서</a></li>\n<li><a href=\"https://docs.github.com/en/actions/reference/workflows-and-actions/dependency-caching\">GitHub Actions Dependency Caching</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">1. 들어가며</a></p>\n</li>\n<li>\n<p><a href=\"#2-testcontainers-vs-h2-%EC%84%B1%EB%8A%A5-%EB%B3%91%EB%AA%A9%EC%9D%98-%EA%B7%BC%EB%B3%B8%EC%A0%81-%EC%9B%90%EC%9D%B8\">2. TestContainers vs H2: 성능 병목의 근본적 원인</a></p>\n<ul>\n<li><a href=\"#21-%EC%9D%B8%ED%94%84%EB%9D%BC-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4%EA%B3%BC-%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C\">2.1 인프라 라이프사이클과 오버헤드</a></li>\n<li><a href=\"#22-io-%EA%B4%80%EC%A0%90%EC%9D%98-%EC%B0%A8%EC%9D%B4-memory-vs-disknetwork\">2.2 I/O 관점의 차이 (Memory vs Disk/Network)</a></li>\n<li><a href=\"#3-%EB%A6%AC%EC%8A%A4%ED%81%AC-%EA%B4%80%EB%A6%AC-%ED%99%98%EA%B2%BD-%EB%B6%88%EC%9D%BC%EC%B9%98%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B7%B9%EB%B3%B5%ED%96%88%EB%8A%94%EA%B0%80\">3. 리스크 관리: '환경 불일치'를 어떻게 극복했는가?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-testcontainers%EB%A5%BC-%ED%8F%AC%EA%B8%B0%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4%EB%A9%B4-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%8C%80%EC%95%88\">4. TestContainers를 포기할 수 없다면? (최적화 대안)</a></p>\n</li>\n<li>\n<p><a href=\"#5-%EB%A7%88%EC%B9%98%EB%A9%B0\">5. 마치며</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></p>\n</li>\n</ul>","frontmatter":{"title":"CI 빌드 속도 66% 단축기: 테스트 환경의 DB를 TestContainers(MySQL)에서 H2로 전환하며 마주한 고민들","date":"2026년 2월 13일","description":"CI 최적화를 위해 테스트 DB 환경을 교체하며 분석한 성능 병목 지점과 '환경 불일치' 관리 전략을 공유하기 위해 작성한 글입니다.","tags":["TestContainers","H2","CI/CD","Testing"],"series":null}},"previous":{"fields":{"slug":"/JPA/JPA-기본기/"},"frontmatter":{"title":"JPA 기본기"}},"next":{"fields":{"slug":"/인프라/React-앱-배포-방식을-EC2에서-S3와-CloudFront로-변경한-이유/"},"frontmatter":{"title":"React 배포 방식을 EC2에서 S3와 CloudFront로 변경한 이유"}}},"pageContext":{"id":"f2358b97-5d49-54be-86a0-70c2476fc2ce","previousPostId":"fee5fca3-57f1-559f-9f35-e453c4699a8a","nextPostId":"f9dc65c9-ff5d-5d46-a8fe-a3c9d9e4409f"}},"staticQueryHashes":["1475414628","2841359383","3539066558"],"slicesMap":{}}