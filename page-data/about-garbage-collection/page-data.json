{"componentChunkName":"component---src-templates-post-jsx","path":"/about-garbage-collection/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","excerpt":"Garbage Collection를 알아야 하는 이유 Garbage Collection(이하 GC)을 공부하다보니, GC를 너무 믿어서는 안되겠다고 생각됐다. 우형에서 발생한 일도 그렇고 토스에서 발생한 일을 보니 모두 애플리케이션의 메모리 관련 치명적 에러는 모두 이 GC와 관련이 있었기 때문이다. 더군다나 네이버 D2 글에서도 GC에 대해 잘 알고 있…","html":"<h2>Garbage Collection를 알아야 하는 이유</h2>\n<p>Garbage Collection(이하 GC)을 공부하다보니, <strong>GC를 너무 믿어서는 안되겠다</strong>고 생각됐다.</p>\n<p><a href=\"https://techblog.woowahan.com/2628/\">우형에서 발생한 일</a>도 그렇고 <a href=\"https://www.youtube.com/watch?v=w4fWgLgop5U\">토스에서 발생한 일</a>을 보니</p>\n<p>모두 애플리케이션의 메모리 관련 치명적 에러는 모두 이 <em>GC</em>와 관련이 있었기 때문이다.</p>\n<p>더군다나 <a href=\"https://d2.naver.com/helloworld/1329\">네이버 D2 글</a>에서도 <strong>GC에 대해 잘 알고 있을수록 실력이 좋은 Java 개발자</strong>라고 하셨다.</p>\n<p>실력이 좋은 Java 개발자가 되기 위해 이 GC에 대해 알아보자.</p>\n<h2>GC란?</h2>\n<p>GC는 <strong>JVM 기반 애플리케이션에서 동적으로 할당되는 메모리를 알아서 관리해주는 기술</strong>이다.</p>\n<blockquote>\n<p>JVM의 메모리 구조는 <a href=\"https://kdkdhoho.github.io/static-with-memory-structure/\">static을 더 잘 사용하기</a> 글 참고</p>\n</blockquote>\n<p>프로세스가 실행하다보면 필연적으로 새로운 메모리를 malloc 및 free 하게 된다.</p>\n<p>C, C++의 경우 Native하게 Memory를 직접 관리할 수 있다.</p>\n<p>하지만 우리의 JAVA는 탄생 배경부터 개발자로 하여금 OS에 직접 의존하지 않아도 되도록, 중간 계층인 JVM을 통해 시스템 자원에 접근하게 된다.</p>\n<p>따라서 malloc 되었지만 더이상 사용하지 않아 필요없어진 쓰레기 메모리들을 대신 처리해주는 역할이 필요하다.</p>\n<p>그 작업을 GC가 해주는 것이다.</p>\n<h2>GC의 장단점</h2>\n<h3>장점</h3>\n<ol>\n<li>개발자가 개발 중간중간 메모리를 관리할 필요가 없어진다.</li>\n<li>(완벽하진 않지만) 자체적으로 메모리 누수를 관리해준다.</li>\n</ol>\n<h3>단점</h3>\n<ol>\n<li>\n<p>GC가 동작할 때 ❗️ <strong>STOP THE WORLD</strong> ❗️가 발생한다.</p>\n<blockquote>\n<p>Stop the world: GC 쓰레드가 동작하는 순간에, 다른 쓰레드들은 동작하지 않는 현상이다.<br>\nGC를 튜닝한다는 말은 주로 이 Stop the world 시간이 짧아지도록 한다는 말이다.</p>\n</blockquote>\n</li>\n</ol>\n<h2>GC의 기본 동작 원리</h2>\n<p>이 GC는 다양한 알고리즘이 존재한다.</p>\n<p>하지만 뒤에 나올 ZGC를 제외한 모든 알고리즘은 <strong>Generational Collection</strong>이라는 기술을 사용한다.</p>\n<p>Generational Collection이란, <del>직역하면 세대로 수집한다는 의미</del> 대부분의 애플리케이션에서 경험적으로 관찰된 몇 가지 속성을 활용하여, 사용하지 않는 객체를 회수하는 데 필요한 작업을 최소화하는 기술이다.</p>\n<p>관찰된 몇 가지 속성 중 가장 핵심적인 것은 <strong>Weak Generational Hypothesis</strong>이다.</p>\n<p>Weak Generational Hypothesis이란 대부분의 객체는 잠깐 동안만 필요하다는 가설이다.</p>\n<p>아래 그림은 객체의 수명에 대한 분포도인데, 간단하게 X축은 객체의 수명, Y축은 분포도이다.</p>\n<p>즉, <strong>애플리케이션에서 수명이 짧은 객체들이 훨씬 많이 분포한다</strong>는 의미이다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 543px; '>\n      <a class='gatsby-resp-image-link' href='/static/0571b10c68e420d95dcf22e0b9c6bb36/10880/distribution_for_lifetimes_of_objects.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 65.29411764705883%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXUlEQVR42q2TWW+CQBSF+f8/pbW+9KkvTZMuBlCpqW1tY4oLgwzbALI0CpzOYFCCfZOTnFy4w3ycm8xI+/0eRVFCiBACwzCg6zoopahVlof1MAyxXC6xWCyqKvY2Jb6TttsYQZwhz/PKRVFUrt/bqtfaEjDxA4l6AUZznqYseOMEFbWdoAb+1z8C15aHl29HtLDvIqFpM8hzt0rYycjE9jEQCcXIeQcjC+Dzl9NtwqcGML8UqBsWHmf2KeGlIw9UDfcfNnJ+ZFj8C+IlSLJdBdzxnjjTR9fARsKyDRy9vqGnmrjVNrhWTFypFu6mDmIOLfnm8yTnI5dNoDwcoz800VMI+irBjbJGT17j4d2E9mNjuvIxM1jllROB+hFWdgDKYtjcOg3wafiI+G3LsgxSkqSQhxrU8QTKaAKTunBZBMsNQBwGk3vDn4XFrXK8kFcGxw+5A9jeoc/CCGma4g/qwu+fhJcGiQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='객체의 수명에 대한 분포도' title='' src='/static/0571b10c68e420d95dcf22e0b9c6bb36/10880/distribution_for_lifetimes_of_objects.png' srcset='/static/0571b10c68e420d95dcf22e0b9c6bb36/e7570/distribution_for_lifetimes_of_objects.png 170w,\n/static/0571b10c68e420d95dcf22e0b9c6bb36/f46e7/distribution_for_lifetimes_of_objects.png 340w,\n/static/0571b10c68e420d95dcf22e0b9c6bb36/10880/distribution_for_lifetimes_of_objects.png 543w' sizes='(max-width: 543px) 100vw, 543px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>객체의 수명에 대한 분포도</figcaption>\n  </figure></p>\n<p>따라서 이러한 경험적 관찰 결과를 통해, Heap 영역에 있는 모든 객체에 대해 검사하지 않고 객체의 수명에 기반한 Collecting을 통해 보다 효율적인 방법을 모색한 것이다.</p>\n<blockquote>\n<p><del>객체 세상은 요절의 비율이 높다</del></p>\n</blockquote>\n<p>그렇다면 이 나이는 어떻게 측정해서 수집한다는 건지 보다 자세히 알아보자.</p>\n<p>일단 기본적으로 메모리 구조는 다음과 같다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; '>\n      <a class='gatsby-resp-image-link' href='/static/773b890738e3964e0bc8cd9c2db8b217/b87a0/default_arrangement_of_generations_int_the_serial_collector.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 27.647058823529413%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXUlEQVR42pXKy0/aAACA8f7BXrzt4s2LJxe3i8Zk0WxLoygPZVGJSGexyMvyqH2ABVKn1KI4dCDr49MYT7ssfsdfPoH/FAbBPxIRhQGdjs1kMn6jlycKX1/BcCy8ew/3/obOoIfltbGHXfp/XEbTB8QDBTFTZleuc1jSOalfcGb0aFpd1NYvZKNP8cLj/PKO3s1vhEQuhemY5BsKseM4G8oWYm6TpqfjPrrMraaZ/ZRi4XuW5ZTCxlGN/aKJ2r4imddYTJRINm6R20Msd4zwJb3OYfWIHeUHsUKCryciohxD9Zp0R10+rCSZ+Rhnfj3DUuyYtb0SW1KdTNniW6bC5/QZ26pH1higOiOEXFWi0DiloBWRGjI/9Tz1Sw3z2kJ3DBJSibhUY09pki0byLUWp5pNRe9QNh0q9oCq7aE5t7SvhghREBGGIdOnKZbVon/dJ/RD/L8+k/EYP/B5T8/WSqtl0PrW/QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Serial GC의 기본적인 메모리 공간' title='' src='/static/773b890738e3964e0bc8cd9c2db8b217/b87a0/default_arrangement_of_generations_int_the_serial_collector.png' srcset='/static/773b890738e3964e0bc8cd9c2db8b217/e7570/default_arrangement_of_generations_int_the_serial_collector.png 170w,\n/static/773b890738e3964e0bc8cd9c2db8b217/f46e7/default_arrangement_of_generations_int_the_serial_collector.png 340w,\n/static/773b890738e3964e0bc8cd9c2db8b217/b87a0/default_arrangement_of_generations_int_the_serial_collector.png 456w' sizes='(max-width: 456px) 100vw, 456px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Serial GC의 기본적인 메모리 공간</figcaption>\n  </figure></p>\n<p>자세히 살펴보면 Young, Old로 크게 한번 나뉜다.<br>\n쉽게 유추할 수 있듯이 상대적으로 젊은 객체는 Young, 늙은 객체는 Old에 저장된다.</p>\n<p>이제 Young을 자세히 들여다보자.<br>\n1개의 <code class=\"language-text\">Eden</code>과 2개의 <code class=\"language-text\">Survivor</code> 영역으로 나뉜다.</p>\n<blockquote>\n<p>각 영역 별 특징으로는 다음과 같다.</p>\n<ul>\n<li>Eden 영역에는 처음 생성되는 대부분의 객체가 저장된다.</li>\n<li>Survivor 영역은 적어도 하나는 항상 비어있다.</li>\n</ul>\n</blockquote>\n<p>이 구조를 기반으로 나이를 증가하는 과정은 다음과 같다.</p>\n<ol>\n<li>처음 생성된 객체는 Eden 영역에 쌓인다.</li>\n<li>쌓이다보면 모두 차게 되는데, 이때 Eden에 존재하는 객체 중 유효한 객체만이 Survivor 영역으로 이동한다.</li>\n<li>이때!! 이동하는 객체에 나이를 증가시킨다.</li>\n<li>마찬가지로 Survivor 영역이 모두 차게 되면, 유효한 객체만이 반대편의 Survivor 영역으로 이동한다. 바로 이때!! 나이가 증가한다.</li>\n</ol>\n<p>자, 그럼 위 과정을 계속해서 반복해서 GC의 동작 원리를 상세히 알아보자.</p>\n<ol>\n<li>Eden 혹은 Survivor 영역이 모두 차면 Young Generation 영역만 수집하는 <strong>Minor Collection</strong>이 발생한다.<br>\n(적은 양의 객체만 참조하기에 Minor Collection은 비교적 빠르게 수행된다.)</li>\n<li>Minor Collection이 진행되면서 특정 나이가 된 객체는 Old 영역으로 이동한다.</li>\n<li>진행되다 보면 Old Generation이 모두 차게 된다. 이때는 전체 영역을 Collecting하는 <strong>Major Collection</strong>이 발생한다.<br>\n(전체 객체를 확인해야 하기에 Minor에 비해 상당한 시간이 걸린다.)</li>\n</ol>\n<h2>이어서</h2>\n<p>다음으로는 GC 알고리즘의 종류와 각 특징에 대해 알아보자.</p>\n<blockquote>\n<h3>참고</h3>\n<ul>\n<li><a href=\"https://youtu.be/FMUpVA0Vvjw?feature=shared\">https://youtu.be/FMUpVA0Vvjw?feature=shared</a> <br></li>\n<li><a href=\"https://youtu.be/vZRmCbl871I?feature=shared\">https://youtu.be/vZRmCbl871I?feature=shared</a> <br></li>\n<li><a href=\"https://mangkyu.tistory.com/118\">https://mangkyu.tistory.com/118</a> <br></li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-45794DA6-AB96-4856-A96D-FDE5F7DEE498\">https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-45794DA6-AB96-4856-A96D-FDE5F7DEE498</a> <br></li>\n<li><a href=\"https://stackoverflow.com/questions/70664562/criteria-for-default-garbage-collector-hotspot-jvm-11-17\">https://stackoverflow.com/questions/70664562/criteria-for-default-garbage-collector-hotspot-jvm-11-17</a> <br></li>\n<li><a href=\"https://medium.com/javarevisited/java-17-vs-java-11-exploring-the-latest-features-and-improvements-6d13290e4e1a\">https://medium.com/javarevisited/java-17-vs-java-11-exploring-the-latest-features-and-improvements-6d13290e4e1a</a> <br></li>\n<li><a href=\"https://www.optaplanner.org/blog/2021/09/15/HowMuchFasterIsJava17.html\">https://www.optaplanner.org/blog/2021/09/15/HowMuchFasterIsJava17.html</a> <br></li>\n<li><a href=\"https://www.baeldung.com/jvm-garbage-collectors\">https://www.baeldung.com/jvm-garbage-collectors</a> <br></li>\n</ul>\n</blockquote>","frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리","date":"December 08, 2023","update":null,"tags":["java","garbage-collection"],"series":null},"fields":{"slug":"/about-garbage-collection/","readingTime":{"minutes":7.11}}},"seriesList":{"edges":[{"node":{"id":"a30ff988-ea74-5562-b241-90fbff73a3da","fields":{"slug":"/kissoft-retrospection/"},"frontmatter":{"title":"키스소프트 현장실습 회고"}}},{"node":{"id":"3b94cbd6-f64a-5d82-96a2-0761602c250b","fields":{"slug":"/dbcp/"},"frontmatter":{"title":"DBCP와 HikariCP 이해하기"}}},{"node":{"id":"c418073e-50be-5fe1-807d-478c9c47f640","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"무중단 배포 이해하기"}}},{"node":{"id":"c5760ea9-e137-5edf-8244-3a93e25b067b","fields":{"slug":"/unit-test/"},"frontmatter":{"title":"단위 테스트 이해하기"}}},{"node":{"id":"8ae82b3f-5b72-555c-89fe-9939dcf8377c","fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"title":"JUnit과 AssertJ 활용법"}}},{"node":{"id":"91a7a622-00f8-5cca-b6c1-e4f7db7ee31e","fields":{"slug":"/about-tdd/"},"frontmatter":{"title":"TDD 이해하기"}}},{"node":{"id":"10e0dab4-d2e7-52df-8daa-31bfef1b08b6","fields":{"slug":"/static-with-memory-structure/"},"frontmatter":{"title":"static을 더 잘 사용하기"}}},{"node":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","fields":{"slug":"/about-garbage-collection/"},"frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리"}}},{"node":{"id":"0bf99b61-98a4-5c40-b8ce-05a918d212f7","fields":{"slug":"/garbage-collection-tuning/"},"frontmatter":{"title":"Garbage Collection 튜닝에 대해"}}},{"node":{"id":"61bd95c2-424a-54c8-96d9-bec4c8a4f58c","fields":{"slug":"/garbage-collection-algorithms/"},"frontmatter":{"title":"Garbage Collection 알고리즘"}}},{"node":{"id":"c87443bb-4e35-55e7-94d5-a5cb70d2dbc8","fields":{"slug":"/cautions-for-using-collections-in-Java/"},"frontmatter":{"title":"Java에서 컬렉션을 사용할 때 주의할 점"}}},{"node":{"id":"c2d7615d-6232-5fce-8794-f4c790106bb5","fields":{"slug":"/2023-retrospection/"},"frontmatter":{"title":"2023년 회고록"}}},{"node":{"id":"def28d41-907f-5432-8060-ed5429114882","fields":{"slug":"/compare-of-datetime-and-timestamp/"},"frontmatter":{"title":"[MySQL] DATETIME vs TIMESTAMP"}}},{"node":{"id":"9bf8ca89-e021-526b-a7b5-2cce0b1e366f","fields":{"slug":"/add-feat-and-issue-number-automatically/"},"frontmatter":{"title":"[git&github] IntelliJ에서 커밋 메시지 작성 시, 자동으로 커밋 타입과 이슈 번호 추가하기"}}},{"node":{"id":"01318426-7520-5a57-92ff-c917e1483247","fields":{"slug":"/difference-of-controller-and-restcontroller/"},"frontmatter":{"title":"[Spring] @Controller와 @RestController 비교하기"}}},{"node":{"id":"bc68fa05-ec4a-5e12-a9b8-4e58769887df","fields":{"slug":"/deploy-spring-boot-in-aws-ec2-manually/"},"frontmatter":{"title":"[Infra] AWS EC2에 Spring Boot 수작업으로 배포하기"}}},{"node":{"id":"122a1e9c-6fe5-5e7f-b797-a31f54d086b0","fields":{"slug":"/what-is-ami-architecture-of-ec2/"},"frontmatter":{"title":"CPU 아키텍처란?"}}},{"node":{"id":"c23a12ff-7b48-57ef-91ed-81f5386d680a","fields":{"slug":"/apply-issue-and-pr-template/"},"frontmatter":{"title":"[github] Github Repository에 Issue, PR Template 적용하기"}}},{"node":{"id":"b1dc584d-3c69-5ae8-82a8-09b015fa3d02","fields":{"slug":"/oauth-test/"},"frontmatter":{"title":"Spring Boot에서 Rest Assured로 인수 테스트할 때 OAuth 로그인 처리하기"}}},{"node":{"id":"9f43b8a7-b5ce-5766-b984-3ed0775d698f","fields":{"slug":"/ioc-container-and-di/"},"frontmatter":{"title":"[Spring] 스프링 컨테이너, 그리고 IoC/DI"}}},{"node":{"id":"e1b2a9fb-d6e3-5f65-9f50-d3a30c2518d1","fields":{"slug":"/what-is-jdbc/"},"frontmatter":{"title":"[Java] JDBC 마스터하기"}}},{"node":{"id":"81b7fb10-f532-5f48-a797-379c3bb99bee","fields":{"slug":"/understanding-transaction-and-concurrency-problem/"},"frontmatter":{"title":"[MySQL] 트랜잭션과 트랜잭션 격리 수준"}}},{"node":{"id":"5ecb4a12-dc98-589f-94e0-695fb2d84fab","fields":{"slug":"/restore-using-binarylog/"},"frontmatter":{"title":"[MySQL] 바이너리 로그로 데이터 복구하기"}}}]},"previous":{"fields":{"slug":"/os-interview-study-retrospection/"},"frontmatter":{"title":"[JSCODE] - OS 면접 스터디 회고록"}},"next":{"fields":{"slug":"/garbage-collection-tuning/"},"frontmatter":{"title":"Garbage Collection 튜닝에 대해"}}},"pageContext":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","series":null,"previousPostId":"1e76511b-5bde-54b8-982a-c4e4fc53cc8c","nextPostId":"0bf99b61-98a4-5c40-b8ce-05a918d212f7"}},"staticQueryHashes":[],"slicesMap":{}}