{"componentChunkName":"component---src-templates-post-jsx","path":"/about-garbage-collection/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","excerpt":"Garbage Collection를 알아야 하는 이유 Garbage Collection(이하 GC)을 공부하다보니, GC를 너무 믿어서는 안되겠다고 생각됐다.\n우형에서 발생한 일도 그렇고 토스에서 발생한 일을 보니 모두 애플리케이션의 메모리 관련 치명적 에러는 모두 이 GC와 관련이 있었기 때문이다.\n더군다나 네이버 D2 글에서도 GC에 대해 잘 알고 있…","html":"<h2>Garbage Collection를 알아야 하는 이유</h2>\n<p>Garbage Collection(이하 GC)을 공부하다보니, GC를 너무 믿어서는 안되겠다고 생각됐다.<br>\n<a href=\"https://techblog.woowahan.com/2628/\">우형에서 발생한 일</a>도 그렇고 <a href=\"https://www.youtube.com/watch?v=w4fWgLgop5U\">토스에서 발생한 일</a>을 보니 모두 애플리케이션의 메모리 관련 치명적 에러는 모두 이 <em>GC</em>와 관련이 있었기 때문이다.<br>\n더군다나 <a href=\"https://d2.naver.com/helloworld/1329\">네이버 D2 글</a>에서도 <strong>GC에 대해 잘 알고 있을수록 실력이 좋은 Java 개발자</strong>라고 했다.</p>\n<p>실력이 좋은 Java 개발자가 되기 위해 이 GC에 대해 알아보자.</p>\n<h2>GC란?</h2>\n<p>Garbage Collection(이하 GC)은 <strong>JVM 기반 애플리케이션에서 동적으로 할당되는 메모리 공간을 알아서 관리해주는 기술</strong>이다.</p>\n<blockquote>\n<p>JVM의 메모리 구조는 <a href=\"https://kdkdhoho.github.io/static-with-memory-structure/\">static을 더 잘 사용하기</a> 글을 참고</p>\n</blockquote>\n<p>프로세스는 필연적으로 새로운 데이터를 Heap 영역에 malloc(할당) 및 free(해제) 하게 된다.<br>\nC나 C++의 경우 데이터가 저장된 메모리 공간을 직접 관리해야 한다.<br>\n하지만 Java는 탄생 배경부터 개발자가 운영체제에 직접 의존하지 않아도 되도록 중간 계층인 <strong>JVM을 통해 시스템 자원에 접근</strong>하게 된다.<br>\n따라서 JVM이 메모리 공간이 할당되었지만 더이상 사용되지 않아 필요없어진 메모리를 대신 처리해주는 역할을 수행하는 것이다.<br>\n그 작업을 우리는 GC 라고 부르는 것이다.</p>\n<h2>GC의 특징</h2>\n<p>GC로 인해 <strong>개발자는 직접 메모리 공간을 관리할 필요가 없어진다</strong>.<br>\n즉, 개발자는 개발에만 집중할 수 있게 된다.<br>\n또한 완벽하진 않지만 GC 덕분에 (완벽하진 않지만) Memory Leak 을 예방할 수 있다.</p>\n<p>하지만, 그만큼 희생도 따르는 법.<br>\nGC가 메모리 공간을 청소할 때 ❗️ <strong>STOP THE WORLD</strong> ❗현상이 발생한다.<br>\nStop the world는 <strong>GC 쓰레드가 동작하는 순간에, 다른 쓰레드들은 동작하지 않는 현상</strong>이다.<br></p>\n<blockquote>\n<p>참고) GC를 튜닝한다는 말은 주로 이 Stop the world 시간이 짧아지도록 한다는 말이다.<br>\n<a href=\"https://d2.naver.com/helloworld/37111\">Naver D2 - Garbage Collection 튜닝</a></p>\n</blockquote>\n<h2>GC의 기본 동작 원리</h2>\n<p>GC는 다양한 알고리즘이 존재한다.<br>\n하지만 뒤에 나올 ZGC를 제외한 모든 알고리즘은 <strong>Generational Collection</strong>이라는 기술을 사용한다.<br>\nGenerational Collection은 대부분의 애플리케이션에서 경험적으로 관찰된 몇 가지 속성을 활용하여 탄생한 알고리즘이다.<br>   , 하는 기술이다.</p>\n<p>관찰된 몇 가지 속성 중 가장 핵심이 되는 개념은 <strong>Weak Generational Hypothesis</strong>이다.<br>\nWeak Generational Hypothesis이란 <strong>대부분의 객체는 잠깐 동안만 필요하다는 가설</strong>이다.<br>\n아래 그림은 객체의 평균 생명주기 분포도를 나타낸 그래프다. X축은 객체가 할당된 시간, Y축은 객체가 할당된 정도이다.<br>\n그래프를 해석해보면 <strong>애플리케이션에서 수명이 짧은 객체들이 훨씬 많이 분포한다</strong>는 의미이다.<br>\n오라클 문서에서도 \"<em>왼쪽의 날카로운 피크는 할당된 직후 회수할 수 있는(즉, \"소멸된\") 객체를 나타냅니다.</em>\" 라고 표현한다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 543px; '>\n      <a class='gatsby-resp-image-link' href='/static/0571b10c68e420d95dcf22e0b9c6bb36/10880/distribution_for_lifetimes_of_objects.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 65.29411764705883%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXUlEQVR42q2TWW+CQBSF+f8/pbW+9KkvTZMuBlCpqW1tY4oLgwzbALI0CpzOYFCCfZOTnFy4w3ycm8xI+/0eRVFCiBACwzCg6zoopahVlof1MAyxXC6xWCyqKvY2Jb6TttsYQZwhz/PKRVFUrt/bqtfaEjDxA4l6AUZznqYseOMEFbWdoAb+1z8C15aHl29HtLDvIqFpM8hzt0rYycjE9jEQCcXIeQcjC+Dzl9NtwqcGML8UqBsWHmf2KeGlIw9UDfcfNnJ+ZFj8C+IlSLJdBdzxnjjTR9fARsKyDRy9vqGnmrjVNrhWTFypFu6mDmIOLfnm8yTnI5dNoDwcoz800VMI+irBjbJGT17j4d2E9mNjuvIxM1jllROB+hFWdgDKYtjcOg3wafiI+G3LsgxSkqSQhxrU8QTKaAKTunBZBMsNQBwGk3vDn4XFrXK8kFcGxw+5A9jeoc/CCGma4g/qwu+fhJcGiQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='객체 생명주기 평균 분포도 출처: https://docs.oracle.com/en/java/javase/16/gctuning/garbage-collector-implementation.html' title='' src='/static/0571b10c68e420d95dcf22e0b9c6bb36/10880/distribution_for_lifetimes_of_objects.png' srcset='/static/0571b10c68e420d95dcf22e0b9c6bb36/e7570/distribution_for_lifetimes_of_objects.png 170w,\n/static/0571b10c68e420d95dcf22e0b9c6bb36/f46e7/distribution_for_lifetimes_of_objects.png 340w,\n/static/0571b10c68e420d95dcf22e0b9c6bb36/10880/distribution_for_lifetimes_of_objects.png 543w' sizes='(max-width: 543px) 100vw, 543px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>객체 생명주기 평균 분포도 출처: https://docs.oracle.com/en/java/javase/16/gctuning/garbage-collector-implementation.html</figcaption>\n  </figure></p>\n<p>즉, 이러한 경험적 관찰 결과를 바탕으로 Heap 영역에 있는 모든 객체에 대해 검사하지 않고 객체의 수명에 기반한 Collecting을 수행한다.<br>\n결과적으로 사용하지 않는 객체를 회수하는 데에 필요한 작업을 최소화하였고, ZGC를 제외한 모든 GC 알고리즘이 Generational Collection 기술을 채택한 것이다.</p>\n<p>그렇다면 이 객체가 할당된 세대, 혹은 나이는 어떻게 측정할까?<br>\n객체의 나이를 측정하기 위한 메모리 공간은 아래와 같다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; '>\n      <a class='gatsby-resp-image-link' href='/static/773b890738e3964e0bc8cd9c2db8b217/b87a0/default_arrangement_of_generations_int_the_serial_collector.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 27.647058823529413%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXUlEQVR42pXKy0/aAACA8f7BXrzt4s2LJxe3i8Zk0WxLoygPZVGJSGexyMvyqH2ABVKn1KI4dCDr49MYT7ssfsdfPoH/FAbBPxIRhQGdjs1kMn6jlycKX1/BcCy8ew/3/obOoIfltbGHXfp/XEbTB8QDBTFTZleuc1jSOalfcGb0aFpd1NYvZKNP8cLj/PKO3s1vhEQuhemY5BsKseM4G8oWYm6TpqfjPrrMraaZ/ZRi4XuW5ZTCxlGN/aKJ2r4imddYTJRINm6R20Msd4zwJb3OYfWIHeUHsUKCryciohxD9Zp0R10+rCSZ+Rhnfj3DUuyYtb0SW1KdTNniW6bC5/QZ26pH1higOiOEXFWi0DiloBWRGjI/9Tz1Sw3z2kJ3DBJSibhUY09pki0byLUWp5pNRe9QNh0q9oCq7aE5t7SvhghREBGGIdOnKZbVon/dJ/RD/L8+k/EYP/B5T8/WSqtl0PrW/QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Serial GC의 기본적인 메모리 공간' title='' src='/static/773b890738e3964e0bc8cd9c2db8b217/b87a0/default_arrangement_of_generations_int_the_serial_collector.png' srcset='/static/773b890738e3964e0bc8cd9c2db8b217/e7570/default_arrangement_of_generations_int_the_serial_collector.png 170w,\n/static/773b890738e3964e0bc8cd9c2db8b217/f46e7/default_arrangement_of_generations_int_the_serial_collector.png 340w,\n/static/773b890738e3964e0bc8cd9c2db8b217/b87a0/default_arrangement_of_generations_int_the_serial_collector.png 456w' sizes='(max-width: 456px) 100vw, 456px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Serial GC의 기본적인 메모리 공간</figcaption>\n  </figure></p>\n<p>자세히 살펴보면 Young, Old로 크게 한번 나뉜다.<br>\n이름에서 유추할 수 있듯이 상대적으로 젊은 객체는 Young, 늙은 객체는 Old에 저장된다.</p>\n<p>Old는 뭐가 없어 보인다. Young 영역을 자세히 살펴보자.<br>\n1개의 Eden과 2개의 Survivor, 그리고 1개의 Virtual 공간이 보인다.<br></p>\n<p>각 영역 별 특징으로는 다음과 같다.</p>\n<ol>\n<li><strong>Eden 영역에는 처음 생성되는 대부분의 객체가 저장된다.</strong></li>\n<li><strong>Survivor 영역 중 적어도 하나는 항상 비어있다.</strong></li>\n</ol>\n<br>\n<br>\n<p>이 구조를 기반으로 나이를 증가하는 과정은 다음과 같다.</p>\n<ol>\n<li>처음 생성된 객체는 Eden 영역에 차곡차곡 쌓인다.</li>\n<li>쌓이다가 결국 공간이 꽉 차면 이때 Eden에 존재하는 객체 중, 필요있을만한 객체를 모두 Survivor 영역으로 이동한다.</li>\n<li>이때, <strong>이동하는 객체에 나이를 증가시킨다.</strong></li>\n<li>마찬가지로 Survivor 영역도 모두 차게 되면, 필요있을만한 객체만이 반대편의 Survivor 영역으로 이동한다. 이때에도 마찬가지로 나이를 증가시킨다.</li>\n</ol>\n<h3>요약</h3>\n<p>이제, 위 정보를 토대로 GC의 전체적인 동작 방식을 정리해보자.</p>\n<ol>\n<li>Eden 혹은 Survivor 영역이 모두 차면 Young Generation 영역만 수집하는 <strong>Minor Collection</strong>이 발생한다.<br>\n(적은 양의 객체만 참조하기에 Minor Collection은 비교적 빠르게 수행된다.)</li>\n<li>Minor Collection이 진행되면서 특정 나이가 된 객체는 Old 영역으로 이동한다.</li>\n<li>진행되다 보면 Old Generation이 모두 차게 된다. 이때는 전체 영역을 Collecting하는 <strong>Major Collection</strong>이 발생한다.<br>\n(전체 객체를 확인해야 하기에 Minor에 비해 상당한 시간이 걸린다.)</li>\n</ol>\n<h2>이어서</h2>\n<p>다음으로는 GC 알고리즘의 종류와 각 특징에 대해 알아보자.</p>\n<blockquote>\n<h3>참고</h3>\n<ul>\n<li><a href=\"https://youtu.be/FMUpVA0Vvjw?feature=shared\">https://youtu.be/FMUpVA0Vvjw?feature=shared</a> <br></li>\n<li><a href=\"https://youtu.be/vZRmCbl871I?feature=shared\">https://youtu.be/vZRmCbl871I?feature=shared</a> <br></li>\n<li><a href=\"https://mangkyu.tistory.com/118\">https://mangkyu.tistory.com/118</a> <br></li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-45794DA6-AB96-4856-A96D-FDE5F7DEE498\">https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-45794DA6-AB96-4856-A96D-FDE5F7DEE498</a> <br></li>\n<li><a href=\"https://stackoverflow.com/questions/70664562/criteria-for-default-garbage-collector-hotspot-jvm-11-17\">https://stackoverflow.com/questions/70664562/criteria-for-default-garbage-collector-hotspot-jvm-11-17</a> <br></li>\n<li><a href=\"https://medium.com/javarevisited/java-17-vs-java-11-exploring-the-latest-features-and-improvements-6d13290e4e1a\">https://medium.com/javarevisited/java-17-vs-java-11-exploring-the-latest-features-and-improvements-6d13290e4e1a</a> <br></li>\n<li><a href=\"https://www.optaplanner.org/blog/2021/09/15/HowMuchFasterIsJava17.html\">https://www.optaplanner.org/blog/2021/09/15/HowMuchFasterIsJava17.html</a> <br></li>\n<li><a href=\"https://www.baeldung.com/jvm-garbage-collectors\">https://www.baeldung.com/jvm-garbage-collectors</a> <br></li>\n</ul>\n</blockquote>","frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리","date":"December 08, 2023","update":null,"tags":["java","garbage-collection"],"series":null},"fields":{"slug":"/about-garbage-collection/","readingTime":{"minutes":8.125}}},"seriesList":{"edges":[{"node":{"id":"a30ff988-ea74-5562-b241-90fbff73a3da","fields":{"slug":"/kissoft-retrospection/"},"frontmatter":{"title":"키스소프트 현장실습 회고"}}},{"node":{"id":"aedd8f5b-dd45-5a14-9b57-3a48cdc0b641","fields":{"slug":"/what-is-varargs/"},"frontmatter":{"title":"[Java] Varargs는 어떻게 사용하고, 사용했을 때 장점이 무엇일까?"}}},{"node":{"id":"d41198ca-d162-523b-84f8-128b247a19b4","fields":{"slug":"/apply-https/"},"frontmatter":{"title":"[셀럽잇] HTTPS 적용기"}}},{"node":{"id":"3b94cbd6-f64a-5d82-96a2-0761602c250b","fields":{"slug":"/dbcp/"},"frontmatter":{"title":"DBCP와 HikariCP 이해하기"}}},{"node":{"id":"c418073e-50be-5fe1-807d-478c9c47f640","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"무중단 배포 이해하기"}}},{"node":{"id":"c5760ea9-e137-5edf-8244-3a93e25b067b","fields":{"slug":"/unit-test/"},"frontmatter":{"title":"단위 테스트 이해하기"}}},{"node":{"id":"8ae82b3f-5b72-555c-89fe-9939dcf8377c","fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"title":"JUnit과 AssertJ 활용법"}}},{"node":{"id":"91a7a622-00f8-5cca-b6c1-e4f7db7ee31e","fields":{"slug":"/about-tdd/"},"frontmatter":{"title":"TDD 이해하기"}}},{"node":{"id":"10e0dab4-d2e7-52df-8daa-31bfef1b08b6","fields":{"slug":"/static-with-memory-structure/"},"frontmatter":{"title":"static을 더 잘 사용하기"}}},{"node":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","fields":{"slug":"/about-garbage-collection/"},"frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리"}}},{"node":{"id":"0bf99b61-98a4-5c40-b8ce-05a918d212f7","fields":{"slug":"/garbage-collection-tuning/"},"frontmatter":{"title":"Garbage Collection 튜닝에 대해"}}},{"node":{"id":"61bd95c2-424a-54c8-96d9-bec4c8a4f58c","fields":{"slug":"/garbage-collection-algorithms/"},"frontmatter":{"title":"Garbage Collection 알고리즘"}}},{"node":{"id":"c87443bb-4e35-55e7-94d5-a5cb70d2dbc8","fields":{"slug":"/cautions-for-using-collections-in-Java/"},"frontmatter":{"title":"Java에서 컬렉션을 사용할 때 주의할 점"}}},{"node":{"id":"c2d7615d-6232-5fce-8794-f4c790106bb5","fields":{"slug":"/2023-retrospection/"},"frontmatter":{"title":"2023년 회고록"}}},{"node":{"id":"def28d41-907f-5432-8060-ed5429114882","fields":{"slug":"/compare-of-datetime-and-timestamp/"},"frontmatter":{"title":"[MySQL] DATETIME vs TIMESTAMP"}}},{"node":{"id":"9bf8ca89-e021-526b-a7b5-2cce0b1e366f","fields":{"slug":"/add-feat-and-issue-number-automatically/"},"frontmatter":{"title":"[git&github] IntelliJ에서 커밋 메시지 작성 시, 자동으로 커밋 타입과 이슈 번호 추가하기"}}},{"node":{"id":"01318426-7520-5a57-92ff-c917e1483247","fields":{"slug":"/difference-of-controller-and-restcontroller/"},"frontmatter":{"title":"[Spring] @Controller와 @RestController 비교하기"}}},{"node":{"id":"bc68fa05-ec4a-5e12-a9b8-4e58769887df","fields":{"slug":"/deploy-spring-boot-in-aws-ec2-manually/"},"frontmatter":{"title":"[Infra] AWS EC2에 Spring Boot 수작업으로 배포하기"}}},{"node":{"id":"122a1e9c-6fe5-5e7f-b797-a31f54d086b0","fields":{"slug":"/what-is-ami-architecture-of-ec2/"},"frontmatter":{"title":"CPU 아키텍처란?"}}},{"node":{"id":"c23a12ff-7b48-57ef-91ed-81f5386d680a","fields":{"slug":"/apply-issue-and-pr-template/"},"frontmatter":{"title":"[github] Github Repository에 Issue, PR Template 적용하기"}}},{"node":{"id":"b1dc584d-3c69-5ae8-82a8-09b015fa3d02","fields":{"slug":"/oauth-test/"},"frontmatter":{"title":"Spring Boot에서 Rest Assured로 인수 테스트할 때 OAuth 로그인 처리하기"}}},{"node":{"id":"9f43b8a7-b5ce-5766-b984-3ed0775d698f","fields":{"slug":"/ioc-container-and-di/"},"frontmatter":{"title":"[Spring] 스프링 컨테이너, 그리고 IoC/DI"}}},{"node":{"id":"e1b2a9fb-d6e3-5f65-9f50-d3a30c2518d1","fields":{"slug":"/what-is-jdbc/"},"frontmatter":{"title":"[Java] JDBC 파헤쳐보기"}}},{"node":{"id":"81b7fb10-f532-5f48-a797-379c3bb99bee","fields":{"slug":"/understanding-transaction-and-concurrency-problem/"},"frontmatter":{"title":"[MySQL] 트랜잭션과 트랜잭션 격리 수준"}}},{"node":{"id":"5ecb4a12-dc98-589f-94e0-695fb2d84fab","fields":{"slug":"/restore-using-binarylog/"},"frontmatter":{"title":"[MySQL] 바이너리 로그로 데이터 복구하기"}}},{"node":{"id":"c375e6a2-7e6c-5607-a579-04d3ab5f3188","fields":{"slug":"/understanding-generic/"},"frontmatter":{"title":"[Java] 제네릭 이해하기"}}},{"node":{"id":"83ad74c1-0d46-5f86-92fc-998642e4367d","fields":{"slug":"/covariant-invariant-and-pecs/"},"frontmatter":{"title":"[Java] 배열의 공변, 제네릭의 불공변. 그리고 PECS"}}},{"node":{"id":"7b9b6854-62e7-5f25-afbf-d5459fa5d021","fields":{"slug":"/commands-of-docker/"},"frontmatter":{"title":"[Docker] 도커의 기본적인 명령어들"}}},{"node":{"id":"d77e8b24-f01d-5673-8c55-d93e2d110c4f","fields":{"slug":"/enhance-speed-ci-workflow/"},"frontmatter":{"title":"[Infra] Github Actions를 이용한 CI 작업 속도를 캐싱으로 개선하기"}}},{"node":{"id":"b4550a40-b215-5e9a-a6a7-8c27bfb63e25","fields":{"slug":"/continuous-deploy-using-github-actions-and-docker/"},"frontmatter":{"title":"[Infra] Github Actions와 Docker를 이용해 배포 자동화 구축하기"}}},{"node":{"id":"e38bb1ed-1a51-5947-a1d2-52aaae42ac97","fields":{"slug":"/build-monitoring-system/"},"frontmatter":{"title":"[Infra] Prometheus와 Grafana, 그리고 Docker를 이용해 모니터링 대시보드 구축하기"}}},{"node":{"id":"32c6a1e4-f349-5a2a-991c-1ea625582325","fields":{"slug":"/june-3rd/"},"frontmatter":{"title":"[회고] 06.10 ~ 06.16"}}},{"node":{"id":"312b3fe7-7d78-543d-ae7c-4e861503d3e4","fields":{"slug":"/june-4th-and-5th/"},"frontmatter":{"title":"[회고] 06.17 ~ 06.30"}}},{"node":{"id":"7b64a367-9192-557d-b45d-0e3bc68d44d3","fields":{"slug":"/thread-in-jvm/"},"frontmatter":{"title":"Java Thread 1 - Java의 Thread에 대해 알아보자"}}},{"node":{"id":"9e5a98c2-ba89-5b36-8e72-0028211a2c5b","fields":{"slug":"/status-and-control-thread-in-java/"},"frontmatter":{"title":"Java Thread 2 - Java Thread의 상태와 행동을 제어하는 방법"}}},{"node":{"id":"45a781cf-0e04-559c-a853-d1609dab1bd4","fields":{"slug":"/synchronize-threads/"},"frontmatter":{"title":"Java Thread 3 - Thread 동기화하기"}}},{"node":{"id":"5b94aaf7-2bae-58b4-9376-927208822c83","fields":{"slug":"/july-1st/"},"frontmatter":{"title":"[회고] 07.01 ~ 07.07"}}},{"node":{"id":"abad5436-5cba-50a3-8fda-72440c646a78","fields":{"slug":"/solid/"},"frontmatter":{"title":"객체지향 설계 원칙: SOLID"}}},{"node":{"id":"f113bb3f-df7e-589a-b3c1-378c812ac8da","fields":{"slug":"/insert-dummy-data-to-db/"},"frontmatter":{"title":"[Spring] 스프링 애플리케이션 동작과 동시에 DB에 더미 데이터 삽입하기"}}}]},"previous":{"fields":{"slug":"/os-interview-study-5week/"},"frontmatter":{"title":"[JSCODE] - OS 면접 스터디 5주차"}},"next":{"fields":{"slug":"/os-interview-study-retrospection/"},"frontmatter":{"title":"[JSCODE] - OS 면접 스터디 회고록"}}},"pageContext":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","series":null,"previousPostId":"fa7523ff-1ef3-530d-a49b-3cc2cd88ac17","nextPostId":"1e76511b-5bde-54b8-982a-c4e4fc53cc8c"}},"staticQueryHashes":[],"slicesMap":{}}