{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"TDD란? Test Driven Development. 테스트 주도 개발이다. 보통 '~~ 주도 개발' 이라고 이름이 붙으면, 개발할 때 '~~' 를 1순위로 여기며 개발하는 방법론을 의미한다. 즉, 테스트 주도 개발은 테스트를 1순위로 여기며 개발하는 개발 방법론이다. 개발 방법론! 어떻게 하나? 결론: 테스트 코드 작성 -> 프로덕션 코드 작성 -> …","fields":{"slug":"/about-tdd/"},"frontmatter":{"date":"November 29, 2023","title":"TDD에 대해","tags":["tdd"]},"rawMarkdownBody":"\n## TDD란?\n\nTest Driven Development. 테스트 주도 개발이다.\n\n보통 '_~~ 주도 개발_' 이라고 이름이 붙으면, 개발할 때 '_~~_' 를 1순위로 여기며 개발하는 **방법론**을 의미한다.\n\n즉, 테스트 주도 개발은 테스트를 1순위로 여기며 개발하는 **개발 방법론**이다.\n\n**개발 방법론!**\n\n## 어떻게 하나?\n\n결론: _테스트 코드 작성 -> 프로덕션 코드 작성 -> 리팩터링_ 순으로 진행한다.\n\n### 1. 테스트 코드 작성\n\n우선 구현하려는 기능에 대해 단위 테스트를 작성한다.\n\n작성하고 돌리면 당연히 실패한다. 왜? 아직 프로덕션 코드가 없으니까.<br>\n어쩌면 컴파일 조차 안될 것이다.\n\n### 2. 프로덕션 코드 작성\n\n이제 기능을 구현한다.\n\n테스트 코드와 프로덕션 코드를 이상없이 작성했다면 테스트가 통과할 것이다.\n\n이때 중요한 점은, 코드 품질은 신경쓰지 않아도 된다.\n\n### 3. 리팩터링\n\n코드 품질은 이제 신경쓴다.\n\n돌아가는 쓰레기를 만들었다면, 이제 이쁜 쓰레기로 만들 차례이다.\n\n테스트 코드, 프로덕션 코드 모두 리팩터링을 진행한다.\n\n## 왜 하나?\n\nTDD를 해본 경험으로 이야기하자면, 버그가 생길 확률이 현저하게 떨어진다. <br>\n(높은 테스트 커버리지는 덤)\n\n확실히 테스트 코드로 내가 구현하려는 기능에 대해 확실한 **안전 장치**를 걸고 기능을 추가하니까, 아무래도 안전하다.\n\n구현하려는 기능에 대한 도메인 이해도가 어느 정도 있고, 주어진 시간이 충분하다면 나는 TDD를 가급적 할 것이다.\n\n주변 지인들에게도 추천할 것이다.\n\n## 단점은?\n\n기능을 작성하는 데까지 시간이 오래 걸린다.\n\n아무래도 돌다리르 건널 때 두들겨보고 건너는 개념인데, 이 두들기는 시간이 상당하다.\n\n체감 상 바로 프로덕션 코드를 작성할 때에 비해 2~3배는 걸리는 것 같다.\n\n또, 내가 구현하려는 기능에 대해 설계 방법이나 감이 잘 오지 않거나 개발 초기 단계라서 변화가 매우 빠른 상황이라면 나는 비추한다.\n\nTDD는 테스트 코드를 필연적으로 낳게 되는데, 이 테스트 코드는 위 상황에서는 걸림돌이기 때문이다.\n\nTDD는 개발 **방법론**일 뿐이니 너무 맹신하지말자.\n\n무엇이든 **상황에 맞게 판단**하자."},{"excerpt":"이 글의 목적 JUnit과 AssertJ의 학습 테스트 코드를 통해 단위 테스트를 처음 해보려는 사람에게 어떻게 쓰는지 간단한 가이드 라인 제시 단위 테스트하면서 잘 사용하지 않는 기능에 대해 나만의 치트 시트 역할 전체 코드 자세한 전체 코드는 이 곳에 올려놓았습니다. 위 레포지토리를 로컬에 clone하고 step3 브랜치로 이동하면, 학습 테스트가 존…","fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"date":"November 28, 2023","title":"JUnit과 AssertJ 활용법","tags":["unit test","JUnit","AssertJ"]},"rawMarkdownBody":"\n## 이 글의 목적\n\n- JUnit과 AssertJ의 학습 테스트 코드를 통해 단위 테스트를 처음 해보려는 사람에게 어떻게 쓰는지 간단한 가이드 라인 제시\n- 단위 테스트하면서 잘 사용하지 않는 기능에 대해 나만의 치트 시트 역할\n\n## 전체 코드\n\n자세한 전체 코드는 [이 곳](https://github.com/kdkdhoho/java-racingcar)에 올려놓았습니다.\n\n위 레포지토리를 로컬에 clone하고 step3 브랜치로 이동하면, 학습 테스트가 존재합니다.\n\n## 코드 바로 보기\n\n### 1. 배열 또는 리스트를 테스트하기\n```java\npublic class AssertJWithIterableStudyTest {\n\n    @Test\n    void filteredOnTest() {\n        List<Member> members = members();\n\n        assertThat(members).filteredOn(Member::job, \"woowa developer\")\n                .hasSize(2)\n                .containsOnly(\n                        new Member(2, \"woowa developer\"),\n                        new Member(4, \"woowa developer\")\n                );\n    }\n\n    @Test\n    void containsExactlyVScontainsOnly() {\n        List<Member> members = members();\n\n        // contains: 순서 상관없이 주어진 요소가 있기만 하면 된다.\n        assertThat(members).extracting(\"id\")\n                .contains(5, 3, 2, 4, 1);\n\n        // containsOnly: 순서 상관없이 주어진 요소만 있어야 한다.\n        assertThat(members).extracting(\"id\")\n                .containsOnly(5, 4, 3, 2, 1);\n\n        // containsExactly: 순서, 주어진 요소 모두 동일해야 한다.\n        assertThat(members).extracting(\"id\")\n                .containsExactly(1, 2, 3, 4, 5);\n    }\n\n    @Test\n    void extractingTest1() {\n        List<Member> members = members();\n\n        assertThat(members).extracting(\"id\")\n                .containsExactly(1, 2, 3, 4, 5);\n    }\n\n    @Test\n    void extractingTest2() {\n        List<Member> members = members();\n\n        assertThat(members).extracting(\"id\", \"job\")\n                .containsExactly(\n                        tuple(1, \"job seeker\"),\n                        tuple(2, \"woowa developer\"),\n                        tuple(3, \"student\"),\n                        tuple(4, \"woowa developer\"),\n                        tuple(5, \"delivery hero\")\n                );\n    }\n\n    /**\n     * [실행 결과]\n     * Multiple Failures (3 failures)\n     * -- failure 1 --\n     * expected: 2\n     * but was: 1\n     * at StringTest$IterableTestUsingAssertJ.lambda$softAssertionsTest$0(StringTest$IterableTestUsingAssertJ.java:103)\n     * -- failure 2 --\n     * expected: 3\n     * but was: 1\n     * at StringTest$IterableTestUsingAssertJ.lambda$softAssertionsTest$0(StringTest$IterableTestUsingAssertJ.java:104)\n     * -- failure 3 --\n     * expected: 4\n     * but was: 1\n     */\n    @Test\n    @Disabled\n    void softAssertionsTest() {\n        SoftAssertions.assertSoftly(softly -> {\n            softly.assertThat(1).isEqualTo(1);\n            softly.assertThat(1).isEqualTo(2);\n            softly.assertThat(1).isEqualTo(3);\n            softly.assertThat(1).isEqualTo(4);\n        });\n    }\n\n    public static List<Member> members() {\n        return List.of(\n                new Member(1, \"job seeker\"),\n                new Member(2, \"woowa developer\"),\n                new Member(3, \"student\"),\n                new Member(4, \"woowa developer\"),\n                new Member(5, \"delivery hero\")\n        );\n    }\n}\n\nclass Member {\n    private final int id;\n    private final String job;\n\n    public Member(int id, String job) {\n        this.id = id;\n        this.job = job;\n    }\n\n    public String job() {\n        return job;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Member member = (Member) o;\n        return id == member.id;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}\n```\n\n### 2. 예외 검증하기\n\n```java\npublic class ExceptionAssertionStudyTest {\n\n    private void throwIllegalStateException() {\n        throw new IllegalStateException(\"예외 1번\");\n    }\n\n    @Test\n    void exceptionTest_1() {\n        assertThatThrownBy(this::throwIllegalStateException)\n                .isInstanceOf(IllegalStateException.class)\n                .hasMessage(\"예외 1번\")\n                .hasMessageContaining(\"1번\")\n                .hasMessageEndingWith(\"1번\");\n    }\n\n    @Test\n    void exceptionTest_2() {\n        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> throwIllegalStateException())\n                .withMessage(\"예외 1번\")\n                .withMessageContaining(\"예외\")\n                .withMessageContaining(\"1번\")\n                .withMessageStartingWith(\"예외\")\n                .withMessageEndingWith(\"1번\");\n    }\n\n    /**\n     * 아래 Exception들 미리 제공\n     * assertThatNullPointerException\n     * assertThatIllegalArgumentException\n     * assertThatIllegalStateException\n     * assertThatIOException\n     */\n    @Test\n    void exceptionTest_3() {\n        assertThatIllegalStateException().isThrownBy(this::throwIllegalStateException)\n                .withMessage(\"예외 1번\")\n                .withMessageContaining(\"예외\")\n                .withMessageContaining(\"1번\")\n                .withMessageStartingWith(\"예외\")\n                .withMessageEndingWith(\"1번\");\n    }\n\n    @Test\n    void notExceptionTest() {\n        assertThatNoException().isThrownBy(AssertJWithIterableStudyTest::members);\n    }\n}\n```\n\n### 3. 테스트 메서드에 파라미터 전달하여 테스트하기\n\n```java\npublic class ParameterizedStudyTest {\n\n    /**\n     * [ValueSource가 지원하는 타입]\n     * short (with the shorts attribute)\n     * byte (bytes attribute)\n     * int (ints attribute)\n     * long (longs attribute)\n     * float (floats attribute)\n     * double (doubles attribute)\n     * char (chars attribute)\n     * java.lang.String (strings attribute)\n     * java.lang.Class (classes attribute)\n     */\n    @ParameterizedTest\n    @ValueSource(ints = {2, 4, 6})\n    void parameterizedTest_with_valueSource(int number) {\n        assertThat(number % 2 == 0).isTrue();\n    }\n\n    @ParameterizedTest\n    @NullSource\n    void parameterizedTest_with_nullSource(String input) {\n        assertThat(input == null).isTrue();\n    }\n\n    @ParameterizedTest\n    @EmptySource\n    void parameterizedTest_with_emptySource_Array(int[] numbers) {\n        assertThat(numbers.length).isZero();\n    }\n\n    @ParameterizedTest\n    @EmptySource\n    void parameterizedTest_with_emptySource_List(List<Integer> numbers) {\n        assertThat(numbers.size()).isZero();\n    }\n\n    @ParameterizedTest\n    @EmptySource\n    void parameterizedTest_with_emptySource_String(String input) {\n        assertThat(input).isEqualTo(\"\");\n    }\n\n    @ParameterizedTest\n    @NullAndEmptySource\n    @ValueSource(strings = {\" \", \"\\t\", \"\\n\"})\n    void parameterizedTest_with_NullAndEmptySource(String input) {\n        assertThat(Strings.isNullOrEmpty(input) || input.isBlank()).isTrue();\n    }\n\n    private enum Direction {\n        NORTH, EAST, SOUTH, WEST;\n    }\n\n    // pass all 4 directions\n    @ParameterizedTest\n    @EnumSource(value = Direction.class)\n    void parameterizedTest_with_EnumSource_All_Passing(Direction direction) {\n        assertThat(direction).isIn(Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = Direction.class, names = {\"NORTH\", \"SOUTH\"})\n    void parameterizedTest_with_EnumSource_names_filter(Direction direction) {\n        assertThat(direction).isIn(Direction.NORTH, Direction.SOUTH);\n        assertThat(direction).isNotIn(Direction.EAST, Direction.WEST);\n    }\n\n    @ParameterizedTest\n    @EnumSource(\n            value = Direction.class,\n            names = {\"NORTH\", \"SOUTH\", \"EAST\"}, // Enum의 value 이름과 매칭한다. 대소문자 구분한다.\n            mode = EnumSource.Mode.EXCLUDE\n    )\n    void parameterizedTest_with_EnumSource_names_filter_exclude(Direction direction) {\n        assertThat(direction).isNotIn(Direction.NORTH, Direction.SOUTH);\n        assertThat(direction).isIn(Direction.EAST, Direction.WEST);\n    }\n\n    @ParameterizedTest\n    @CsvSource({\"test,TEST\", \"java,JAVA\"})\n    void parameterizedTest_with_CsvSource(String input, String expected) {\n        assertThat(input.toUpperCase()).isEqualTo(expected);\n    }\n\n    @ParameterizedTest\n    @CsvSource(value = {\"test:TEST\", \"java:JAVA\"}, delimiter = ':')\n    void parameterizedTest_with_CsvSource_Using_Delimiter(String input, String expected) {\n        assertThat(input.toUpperCase()).isEqualTo(expected);\n    }\n\n    @ParameterizedTest\n    @CsvFileSource(resources = \"/csvFile.txt\", numLinesToSkip = 1)\n    void parameterizedTest_with_CsvSource_Using_CsvFile(String input, String expected) {\n        assertThat(input.toUpperCase()).isEqualTo(expected);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"provideStringForIsBlank\")\n    void parameterizedTest_with_MethodSource(String input, boolean expected) {\n        assertThat(StringUtils.isBlank(input)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> provideStringForIsBlank() {\n        List<String> inputs = new ArrayList<>();\n        for (int i = 0; i < 4; i++) {\n            if (i == 3) {\n                String input = \"not Empty\";\n                inputs.add(input);\n                continue;\n            }\n\n            String input = \" \".repeat(i);\n            inputs.add(input);\n        }\n\n        return Stream.of(\n                Arguments.of(inputs.get(0), true),\n                Arguments.of(inputs.get(1), true),\n                Arguments.of(inputs.get(2), true),\n                Arguments.of(inputs.get(3), false)\n        );\n    }\n\n    private static class BlankStringArgumentsProvider implements ArgumentsProvider {\n\n        @Override\n        public Stream<? extends Arguments> provideArguments(ExtensionContext context) throws Exception {\n            return Stream.of(\n                    Arguments.of((String) null),\n                    Arguments.of(\"\"),\n                    Arguments.of(\" \")\n            );\n        }\n    }\n\n    @ParameterizedTest\n    @ArgumentsSource(BlankStringArgumentsProvider.class)\n    void parameterizedTest_with_MethodSource_Using_ArgumentsProvider(String input) {\n        assertThat(StringUtils.isBlank(input)).isTrue();\n    }\n\n    static Stream<Arguments> arguments = Stream.of(\n            Arguments.of(null, true),\n            Arguments.of(\"\", true),\n            Arguments.of(\" \", true),\n            Arguments.of(\"Not Empty\", false)\n    );\n\n    private static class SlashyDateConverter implements ArgumentConverter {\n\n        @Override\n        public Object convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            if (!(source instanceof String)) {\n                throw new IllegalArgumentException(\"문자열이 아닙니다. 입력값:\" + source);\n            }\n\n            try {\n                String[] parts = ((String) source).split(\"/\");\n                int year = Integer.parseInt(parts[0]);\n                int month = Integer.parseInt(parts[1]);\n                int day = Integer.parseInt(parts[2]);\n\n                return LocalDate.of(year, month, day);\n            } catch (NumberFormatException e) {\n                e.printStackTrace();\n                throw new IllegalArgumentException(\"숫자가 아닙니다. 입력값:\" + source);\n            }\n        }\n    }\n\n    @ParameterizedTest\n    @CsvSource({\"2023/11/28\", \"2023/12/28\"})\n    void parameterizedTest_with_CustomConverter(@ConvertWith(SlashyDateConverter.class) LocalDate date) {\n        assertThat(date.getYear()).isEqualTo(2023);\n        assertThat(date.getMonth()).isGreaterThan(Month.OCTOBER);\n        assertThat(date.getDayOfMonth()).isEqualTo(28);\n    }\n\n    @ParameterizedTest(name = \"{index} - Parameter is {0}\")\n    @EnumSource(value = Direction.class, names = {\"SOUTH\", \"NORTH\"})\n    void displayNameTest(Direction direction) {\n    }\n}\n```\n\n### 4. 두 객체 리스트의 필드 비교하기\n\n```java\npublic class UsingRecursiveComparisonStudyTest {\n\n    @Test\n    void usingRecursiveComparisonTest_1() {\n        List<Member> members = List.of(\n                new Member(1, \"backend developer\"),\n                new Member(2, \"DBA\"),\n                new Member(3, \"frontend developer\")\n        );\n\n        List<Member> other = List.of(\n                new Member(1, \"DBA\"),\n                new Member(2, \"frontend developer\"),\n                new Member(3, \"backend developer\")\n        );\n\n        assertThat(members).usingRecursiveComparison()\n                .comparingOnlyFields(\"job\")\n                .ignoringCollectionOrder()\n                .isEqualTo(other);\n    }\n\n    @Test\n    void usingRecursiveComparisonTest_2() {\n        Member member = new Member(1, \"DBA\");\n        Member other = new Member(2, \"DBA\");\n\n        assertThat(member).usingRecursiveComparison()\n                .comparingOnlyFields(\"job\")\n                .isEqualTo(other);\n    }\n}\n```\n\n## 마치며\n\n더 나은 방법이 있거나 제안이 있다면 언제든 댓글 달아주시면 감사하겠습니다!"},{"excerpt":"단위 테스트란? 애플리케이션에서 동작하는 기능 또는 메서드를 실행시키는 독립적인 단위의 테스트이다. 이때 기능이라는 말이 포함되어있다. 즉, 단위 테스트라고 해서 무조건 메서드만 테스트하는 건 아니다. 왜 단위 테스트를 하나? 잘 작성한 단위 테스트는 개발자가 작성한 단위(기능 또는 메서드)를 매우 빠르게 검증할 수 있다. 단위 테스트를 하지 않았을 때의…","fields":{"slug":"/unit-test/"},"frontmatter":{"date":"November 27, 2023","title":"단위 테스트","tags":["unit test"]},"rawMarkdownBody":"\n## 단위 테스트란?\n\n애플리케이션에서 동작하는 **기능 또는 메서드를 실행**시키는 **독립적인 단위의 테스트**이다.\n\n이때 기능이라는 말이 포함되어있다. 즉, 단위 테스트라고 해서 무조건 메서드만 테스트하는 건 아니다.\n\n## 왜 단위 테스트를 하나?\n\n잘 작성한 단위 테스트는 **개발자가 작성한 단위(기능 또는 메서드)를 매우 빠르게 검증**할 수 있다.\n\n### 단위 테스트를 하지 않았을 때의 문제점\n\n1. 테스트 코드를 프로덕션 코드에 작성해야한다.<br>\n   이는 배포하는 jar 파일의 크기에 영향을 줄 것이고 배포 시간에도 영향을 줄 것이다.\n\n2. 기능을 개발할 때마다 직접 실행시켜 동작을 확인해야한다.<br>\n   이는 작성한 기능에 대해 검증받는 시간의 주기가 길어질 것이다.<br>\n   즉, 버그를 낳을 확률이 증가한다.\n\n이 외에도 문제점이 다양하게 있겠지만, 이만하면 단위 테스트를 할 가치가 충분히 있어보인다.\n\n## JUnit\n\n이렇게 좋은 단위테스트를 어떻게 할까?<br>\n바로 [JUnit](https://junit.org/junit5/) 프레임워크를 사용한다.\n\n> 우테코 5기 최고 미남 [제리의 프레임워크 vs 라이브러리 vs API 테코톡](https://youtu.be/yKEwNVbAFC0?feature=shared)을 보면 프레임워크에 대해 알 수 있다.\n\nJUnit 홈페이지에 있는 소개글에 의하면 \"JVM 기반이며 Java 8 이상에 초점을 맞춰 다양한 스타일의 테스트를 지원한다\"고 한다.\n\n자세한 사용법은 [User Guide](https://junit.org/junit5/docs/current/user-guide/)를 참고하자.\n\n## 특징\n### 1. 메서드 실행 순서\n\n[공식 문서](https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order)에 의하면 테스트 실행 순서를 이렇게 설명한다.\n\n\"_기본적으로, 테스트 클래스와 메서드는 결정론적이지만 의도적으로 명확하지 않은 순서로 정렬이 된다._\"\n\n무슨 소리일까? 🤔\n\n결정론적 알고리즘에 대해 검색해보니 아래와 같이 설명한다.\n\n\"_예측한 그대로 동작하는 알고리즘이다. **어떤 특정한 입력이 들어오면 언제나 똑같은 과정을 거쳐서 언제나 똑같은 결과를 내놓는다**.\"_\n\n즉, 순서에 대한 보장은 할 수 없지만 입력과 출력은 매번 동일한 것이 보장된다. 라고 이해하면 될 것 같다.\n\n> 왜 이렇게 구현했을까 고민했을 땐, 테스트 순서로부터 독립성을 보장하기 위함이지 않을까한다.<br>\n> 좋은 단위 테스트는 독립적이어야한다. 테스트 순서에도 영향을 받아서는 안된다.\n\n```java\nclass TestOrderTest {\n\n    private static final AtomicInteger number = new AtomicInteger(1);\n\n    @Test\n    void C() {\n        System.out.println(\"Test C - \" + number.getAndIncrement());\n    }\n\n    @Test\n    void B() {\n        System.out.println(\"Test B - \" + number.getAndIncrement());\n    }\n\n    @Test\n    void A() {\n        System.out.println(\"Test A - \" + number.getAndIncrement());\n    }\n\n    @Test\n    void E() {\n        System.out.println(\"Test E - \" + number.getAndIncrement());\n    }\n\n    @Test\n    void D() {\n        System.out.println(\"Test D - \" + number.getAndIncrement());\n    }\n}\n```\n\n실제 위 예제 코드로 순서를 바꿔도 보고 그룹 단위로 변경해가며 실행하면 위에서 설명하는 특징을 실제로 보이는 것을 확인할 수 있다.\n\n> 만약 클래스에 작성한 테스트 코드의 순서대로 동작하고 싶다면 `@TestInstance(value = TestInstance.Lifecycle.PER_CLASS)`를 추가하자<br>\n> 혹은 `@TestMethodOrder(OrderAnnotation.class)`를 클래스 레벨에 추가하고, 각 메서드에 `@Order(int value)`로 조절하자\n\n> 클래스 간의 테스팅 순서도 조절할 수 있다고 한다. 이는 필요할 때 알아보자.\n\n### 2. AssertJ 활용\n\n[AssertJ](http://joel-costigliola.github.io/assertj/assertj-core-quick-start.html)는 \"_능수능란한 검증문 자바 라이브러리_\" 라고 설명한다.\n\n단순히 말해서 유용한 Assertion문을 선언할 수 있도록 도와주는 라이브러리라고 생각하자.\n\nAssertJ는 메서드 체이닝 가능한 assert문을 지원하는 라이브러리이다.<br>\n이를 이용해서 더욱 가독성 좋은 단위 테스트를 작성할 수 있다.<br>\n아래 코드로 비교해보자.\n\n```java\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Test\nvoid assertJTest() {\n    // junit 메서드 사용\n    assertEquals(expected, actual);\n\n    // assertJ 메서드 사용\n    assertThat(actual).isEqualTo(expected);\n}\n```\n\n> 자세한 사용법은 [Java Doc](http://javadoc.io/doc/org.assertj/assertj-core) 참고\n\n추가적인 장점으로는 실패 메시지가 자세하다는 점과 다양한 검증 메서드를 지원한다고 한다.<br>\n심지어 [JUnit 공식 사이트](https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions-third-party)에서도 써드파티 Assertion 라이브러리로 AssertJ를 권장한다.\n\n## Junit vs AssertJ\n\nJunit은 프레임워크고 AssertJ는 라이브러리이다.\n\nAssertJ를 이용해 단위 테스트 코드를 작성하고, JUnit에게 `@Test`와 같은 어노테이션으로 메서드를 위임하여 실행시킨다. "}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}