{"componentChunkName":"component---src-templates-blog-post-js","path":"/네트워크/네트워크-책-스터디/08-authentication-of-http/","result":{"data":{"site":{"siteMetadata":{"title":"김동호의 기록"}},"markdownRemark":{"id":"5d7757dc-8f8d-577b-b387-4caf98b517c0","excerpt":"들어가며 이번엔 HTTP 표준이 설명하는 여러 가지 인증 방식에 대해 알아보겠다. Basic 인증 이름 그대로 가장 기본적인 인증 방식이다. 클라이언트가 Http Request를 보낼 때  헤더에 ID와 패스워드를 Base6…","html":"<h2 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h2>\n<p>이번엔 HTTP 표준이 설명하는 여러 가지 인증 방식에 대해 알아보겠다.</p>\n<h2 id=\"basic-인증\" style=\"position:relative;\"><a href=\"#basic-%EC%9D%B8%EC%A6%9D\" aria-label=\"basic 인증 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Basic 인증</h2>\n<p>이름 그대로 가장 기본적인 인증 방식이다.</p>\n<p>클라이언트가 Http Request를 보낼 때 <code class=\"language-text\">Authorization</code> 헤더에 ID와 패스워드를 Base64 형식으로 인코딩 한 값을 담아 보내는 방식이다.<br>\n이때 값 앞에 <code class=\"language-text\">\"Basic \"</code>을 Prefix로 담아 함께 보내어 Basic 인증임을 나타낸다.</p>\n<p>Basic 인증은 아래와 같은 요청이 서버로 전달된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">GET /my HTTP/1.1\nAuthoization: Basic Z3Vlc3Q35wervc32= </code></pre></div>\n<p>가장 단순하며 간편한 인증 방식이다.<br>\n하지만 Base64 형식은 <a href=\"https://www.base64decode.org/\">온라인 디코더 사이트</a>도 있는만큼 매우 위험한 인증 방식이다.<br>\n따라서 잘 사용하진 않는다.</p>\n<h2 id=\"digest-인증\" style=\"position:relative;\"><a href=\"#digest-%EC%9D%B8%EC%A6%9D\" aria-label=\"digest 인증 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DIGEST 인증</h2>\n<p>편리하지만 안전하지 않은 Basic 인증을 보완하기 위해 탄생한 기술이다.<br>\nDIGEST 인증에는 <em>챌린지 리스폰스</em> 방식이 사용되고 있어 패스워드를 그대로 보낼 일은 없다.</p>\n<p>챌린지 리스폰스 방식은 최초에 상대방에게 인증 요구를 보내고 그 결과로 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산한다.<br>\n이 값을 상대에게 송신하여 인증하는 방법이다.<br>\n리스폰스 코드는 패스워드와 챌린지 코드를 이용해 계산한 결과이다. 이 결과값을 보내기에 패스워드가 통신되는 일은 없다.</p>\n<p>좀 더 자세히 살펴보면 인증 순서에 따른 요청 및 응답 내용은 아래와 같다.</p>\n<ol>\n<li>클라이언트가 리소스에 접근</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">GET /my HTTP/1.1\nHost: listywave.com</code></pre></div>\n<ol start=\"2\">\n<li>서버는 인증이 필요하다는 상태 코드와 함께 패스워드와 챌린지 코드(nonce)를 송신</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Digest realm=&quot;my&quot;, nonce=&quot;MoSq25=sddfAMi217wsnDS&quot;, algorithm=MD5, qop=&quot;auth</code></pre></div>\n<ol start=\"3\">\n<li>클라이언트는 패스워드와 챌린지 코드를 통해 리스폰스 코드를 계산해서 송신</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">GET /my HTTP/1.1\nHost: listywave.com\nAuthorization: Digest username=&quot;kdkdhoho&quot;, realm=&quot;my&quot;, nonce=&quot;MoSq25=sddfAMi217wsnDS&quot;, uri=&quot;/my&quot;, algorithm=MD5, response=&quot;df563836bnfasf7acfasdfc78&quot;, qop=&quot;auth&quot;, nc=000000001, cnonce=&quot;0827c27c29c271&quot;</code></pre></div>\n<ol start=\"4\">\n<li>서버는 인증 성공 시 <code class=\"language-text\">200 OK</code>를 응답하고, 실패했을 경우 다시 <code class=\"language-text\">401 Unauthorized</code>를 응답한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">HTTP/1.1 200 OK\nAuthentication-Info: rspauth=&quot;fvacacwararact3c5ttcctyct7tcc4t7y&quot;, cnonce=&quot;0827c27c29c271&quot;, nc=000000001, qop=&quot;auth&quot;</code></pre></div>\n<p>하지만 Digest 방식도 사용상의 문제와 부족한 보안성 때문에 잘 사용하지는 않는다.</p>\n<h2 id=\"ssl-클라이언트-인증\" style=\"position:relative;\"><a href=\"#ssl-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%9D%B8%EC%A6%9D\" aria-label=\"ssl 클라이언트 인증 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL 클라이언트 인증</h2>\n<p>위 두 방식은 사용자 ID와 패스워드를 통해 인증을 진행한다.<br>\nSSL 클라이언트 인증의 경우에는 클라이언트가 <strong>클라이언트 인증서</strong>를 서버로 전송해 인증한다.</p>\n<p>클라이언트가 클라이언트 인증서를 서버로 전송하기 위해서는 사전에 미리 가지고 있어야 한다.<br>\n이를 위해선 서버가 미리 증명서를 구매하여 사용자에게 배포를 해야 한다.<br>\n다른 말로 인증을 위한 비용이 상당하다는 것이다.<br>\n따라서 웹 애플리케이션 인증만을 위한 용도로는 사용하지 않고 후술할 Form 방식과 함께 사용되어 2-Factor 인증으로 사용한다.</p>\n<h2 id=\"form-방식\" style=\"position:relative;\"><a href=\"#form-%EB%B0%A9%EC%8B%9D\" aria-label=\"form 방식 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Form 방식</h2>\n<p>Form 방식은 HTTP 프로토콜로 스펙이 정의되어 있지는 않다.<br>\n하지만 많은 웹사이트에서 채택 중이며 대부분의 경우 로그인 페이지를 통해 사용자의 인증 정보를 폼에 입력 후 서버로 전송하면, 서버는 해당 값을 토대로 사용자를 식별하고 그에 따른 인증 처리를 하는 방식으로 채택 중이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9c59e807258884b8c8889affd6decef8/d53ff/form-auth-example.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 96.20253164556962%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAABoElEQVR42q2Uy0vEMBDG9+8VD75Q96D4Qj2I4EXUg6y4PmDrPkA8WUU9C4J42IMIorB0VdqmSdM26WfSfeiKbnfVwFeGmeaXyUySDP55ZHr5SUqZKI7jvwM1SI9eYF2BLUC1WoVpmjAMA4yxVHhPGVqWhXq93n+GeuUoihIFQdCWECLRZ1/Lnwp0HAe2bbfBP4lzDt/304GuS+C4Hniosuwi3+fgSl2BUsZg1IXkbxCBq5fQ3m8lRJhk+SOw0TiJ2wcP0wWC+aKH+RLFXJFi5ZhgueIl9kKZYtqg2DI9sOaWPzf9CzDGzT3BWJ4ge0AwqTSxT7BUtjFjuBhXdvaQYFTF105cUNYF+NHlQFmdksJXMd7pkzxpzq+uHldbEyLq7xzKZtp3TxEGcxTDeYaRPYrZI6LqRrBYcTFV8DCUpxhQ8dUTpubEaTUEHl8E1k99bJwybJ4x7FxS5C4odq8ots895eMqzlG6Dtpz4rQt6zo6r8/wHAvEbkjbzmsNpGaB207vd1mvKtRRi9SnpTBqSNtBIBCGsl2iXzXl3x/YfoDvEiq/mkSMcbMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Form 방식의 로그인 페이지 (출처: https://gundogmuseray.medium.com/easy-way-to-stop-worry-about-client-side-auth-with-firebase-and-sveltekit-d17cdcccb663)\"\n        title=\"\"\n        src=\"/static/9c59e807258884b8c8889affd6decef8/f058b/form-auth-example.png\"\n        srcset=\"/static/9c59e807258884b8c8889affd6decef8/c26ae/form-auth-example.png 158w,\n/static/9c59e807258884b8c8889affd6decef8/6bdcf/form-auth-example.png 315w,\n/static/9c59e807258884b8c8889affd6decef8/f058b/form-auth-example.png 630w,\n/static/9c59e807258884b8c8889affd6decef8/40601/form-auth-example.png 945w,\n/static/9c59e807258884b8c8889affd6decef8/d53ff/form-auth-example.png 1068w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 id=\"세션-및-토큰\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EC%85%98-%EB%B0%8F-%ED%86%A0%ED%81%B0\" aria-label=\"세션 및 토큰 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세션 및 토큰</h2>\n<p>HTTP 프로토콜은 Stateless 하다.<br>\n방금 전에 로그인에 성공했지만 다음 요청마다 로그인을 새로 해야 한다.<br>\n이를 개선하기 위해 쿠키[<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>] 가 도입되었고 여기에 세션[<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>]이나 토큰[<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>] 을 이용해 사용자 인증 정보를 유지한다.</p>\n<p>세션과 토큰은 현재 대부분의 경우 사용 중인 방식이다.<br>\n이 둘을 잘 이해하고 사용할 줄 아는 것은 매우 중요하다는 의미이며 다른 포스팅에서 집중적으로 알아볼 예정이다.</p>\n<br>\n<br>\n<br>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-2\"><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies\">MDN - 쿠키</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Session\">MDN - 세션</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\"><a href=\"https://opentutorials.org/course/3405/22008\">오픈튜토리얼스 - AccessToken</a><a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","tableOfContents":"<ul>\n<li><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">들어가며</a></li>\n<li><a href=\"#basic-%EC%9D%B8%EC%A6%9D\">Basic 인증</a></li>\n<li><a href=\"#digest-%EC%9D%B8%EC%A6%9D\">DIGEST 인증</a></li>\n<li><a href=\"#ssl-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%9D%B8%EC%A6%9D\">SSL 클라이언트 인증</a></li>\n<li><a href=\"#form-%EB%B0%A9%EC%8B%9D\">Form 방식</a></li>\n<li><a href=\"#%EC%84%B8%EC%85%98-%EB%B0%8F-%ED%86%A0%ED%81%B0\">세션 및 토큰</a></li>\n</ul>","frontmatter":{"title":"8장. 누가 액세스하고 있는지를 확인하는 인증","date":"2024년 4월 10일","description":"HTTP 표준에서 설명하는 여러 인증 방법에 대해 알아보자","tags":["Network"],"series":"그림으로 배우는 Http & Network Basic"}},"previous":{"fields":{"slug":"/데이터베이스/restore-using-binarylog/"},"frontmatter":{"title":"[MySQL] 바이너리 로그로 데이터 복구하기"}},"next":{"fields":{"slug":"/네트워크/네트워크-책-스터디/09-advanced-http-protocol/"},"frontmatter":{"title":"9장. HTTP에 기능을 추가한 프로토콜"}}},"pageContext":{"id":"5d7757dc-8f8d-577b-b387-4caf98b517c0","previousPostId":"a9719807-4394-5222-88fb-9f57f75be775","nextPostId":"2ce4d16c-5b0d-56d9-9850-4ca875f0b0ef"}},"staticQueryHashes":["1475414628","2841359383"],"slicesMap":{}}