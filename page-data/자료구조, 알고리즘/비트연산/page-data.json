{"componentChunkName":"component---src-templates-blog-post-js","path":"/자료구조, 알고리즘/비트연산/","result":{"data":{"site":{"siteMetadata":{"title":"김동호 블로그"}},"markdownRemark":{"id":"4edd7839-0cb2-5bd2-aad4-9629380a8e9b","excerpt":"비트 연산의 정의와 기초 논리 비트 연산은 데이터를 비트(Bit) 단위로 조작하는 연산 방식이다. 컴퓨터는 모든 정보를 이진수 형태로 저장/처리하며, 비트 연산은 이러한 개별 비트의 상태를 직접 제어함으로써 최적의 성능과 메모리 효율을 달성하게 해준다. 비트 연산은 산술 연산보다 CPU…","html":"<h1 id=\"비트-연산의-정의와-기초-논리\" style=\"position:relative;\"><a href=\"#%EB%B9%84%ED%8A%B8-%EC%97%B0%EC%82%B0%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EA%B8%B0%EC%B4%88-%EB%85%BC%EB%A6%AC\" aria-label=\"비트 연산의 정의와 기초 논리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비트 연산의 정의와 기초 논리</h1>\n<p><strong>비트 연산은 데이터를 비트(Bit) 단위로 조작하는 연산 방식</strong>이다.<br>\n컴퓨터는 모든 정보를 이진수 형태로 저장/처리하며, 비트 연산은 이러한 개별 비트의 상태를 직접 제어함으로써 최적의 성능과 메모리 효율을 달성하게 해준다.<br>\n비트 연산은 산술 연산보다 CPU 사이클 소모가 훨씬 적기에 임베디드 시스템, 그래픽스, 암호화 및 네트워크 프로토콜 설계에서 핵심적인 역할을 수행한다.</p>\n<p>가장 기본적인 비트 연산자는 AND(&#x26;), OR(|), XOR(^), NOT(~) 이 있다.<br>\n기본적으로 불 대수의 원리를 따르며 두 비트의 사이의 관계를 정의한다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">A &#x26; B</th>\n<th align=\"center\">A | B</th>\n<th align=\"center\">A ^ B</th>\n<th align=\"center\">~A</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"시프트shift-연산과-산술적-의미\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%ED%94%84%ED%8A%B8shift-%EC%97%B0%EC%82%B0%EA%B3%BC-%EC%82%B0%EC%88%A0%EC%A0%81-%EC%9D%98%EB%AF%B8\" aria-label=\"시프트shift 연산과 산술적 의미 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시프트(Shift) 연산과 산술적 의미</h1>\n<p><strong>시프트 연산은 비트 열을 왼쪽이나 오른쪽으로 밀어내는 연산</strong>이다.<br>\n이를 활용하면 정수형 데이터의 <strong>배수 연산을 매우 빠르게 처리</strong>할 수 있다.</p>\n<p>왼쪽 시프트(<code class=\"language-text\">&lt;&lt;</code>)는 비트들을 왼쪽으로 이동하며, 오른쪽에 새로 생기는 빈 공간에는 0을 할당한다.<br>\n비트를 왼쪽으로 한 칸 밀 때마다 원래 값에 2를 곱한 것과 같은 효과를 낸다. (예: x &#x3C;&#x3C; 3 == x * 2^3)</p>\n<p>오른쪽 시프트(<code class=\"language-text\">>></code>)는 비트들을 오른쪽으로 이동하며, 이동 방식에 따라 논리적 시프트와 산술적 시프트로 나뉜다.<br>\n논리적 시프트는 왼쪽에 새로 생기는 빈 공간을 0으로 할당한다.<br>\n산술적 시프트는 부호 비트를 유지하며 빈 공간을 채운다. 이는 음수 값을 유지하며 2로 나누는 연산을 수행할 때 필수적이다.</p>\n<h1 id=\"비트-연산-활용\" style=\"position:relative;\"><a href=\"#%EB%B9%84%ED%8A%B8-%EC%97%B0%EC%82%B0-%ED%99%9C%EC%9A%A9\" aria-label=\"비트 연산 활용 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비트 연산 활용</h1>\n<h2 id=\"비트-마스크\" style=\"position:relative;\"><a href=\"#%EB%B9%84%ED%8A%B8-%EB%A7%88%EC%8A%A4%ED%81%AC\" aria-label=\"비트 마스크 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비트 마스크</h2>\n<p>비트 연산의 가장 대표적인 활용 사례는 비트마스크이다.<br>\n이는 여러 Boolean 상태 정보를 하나의 정수형 변수에 담아 관리하는 기법이다.</p>\n<p>예를 들어 8비트 정수 하나로 8가지 옵션의 ON/OFF 상태를 표현</p>\n<h2 id=\"알고리즘-최적화\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"알고리즘 최적화 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘 최적화</h2>\n<p>어떤 정수가 2의 거듭제곱인지 판별할 때, 반복문을 돌리는 대신 <code class=\"language-text\">n &amp; (n - 1) == 0</code> 인지만 판별하면 된다.<br>\n예를 들어 N이 4일 경우, 4 &#x26; 3 == 100 &#x26; 011 == 0 이 된다.<br>\n반대로 N이 5일 경우, 5 &#x26; 4 == 100 &#x26; 101 == 100 이 된다.</p>\n<p>또한 홀수와 짝수를 판별할 때 모듈러 연산(n % 2) 대신, 가장 낮은 자리 비트를 검사하는 <code class=\"language-text\">n &amp; 1</code> 연산을 사용하면 하드웨어 수준에서 더 빠르게 처리된다.<br>\n홀수의 경우 가장 낮은 자리의 비트는 0이, 짝수인 경우 1이 와야 한다는 점을 이용한 것이다.<br>\n<code class=\"language-text\">n &amp; 1</code>의 결과가 0일 경우 짝수, 1일 경우 홀수가 된다.<br>\n예를 들어 N이 4일 경우, 4 &#x26; 1 == 100 &#x26; 1 == 0이, N이 5일 경우 5 &#x26; 1 == 101 &#x26; 1 == 1</p>\n<h1 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h1>\n<p>비트 연산은 소스 코드의 가독성을 해칠 수 있다. 비트 연산을 모르는 개발자나 연산 자체가 한눈에 들어오지 않는 경우가 있기 때문이다.<br>\n하지만 시스템 성능을 끌어올려야 하는 상황에서는 대체 불가능한 도구이다.<br>\n현대의 컴파일러들은 산술 연산을 비트 연산으로 자동 최적화해주기도 하지만, 개발자가 비트 수준에서 데이터 구조를 이해하고 직접 조작할 수 있는 능력은 효율적인 데이터 구조 설계와 저수준의 시스템을 프로그래밍하는 중요한 역량이 될 것이다.</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%B9%84%ED%8A%B8-%EC%97%B0%EC%82%B0%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EA%B8%B0%EC%B4%88-%EB%85%BC%EB%A6%AC\">비트 연산의 정의와 기초 논리</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8B%9C%ED%94%84%ED%8A%B8shift-%EC%97%B0%EC%82%B0%EA%B3%BC-%EC%82%B0%EC%88%A0%EC%A0%81-%EC%9D%98%EB%AF%B8\">시프트(Shift) 연산과 산술적 의미</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B9%84%ED%8A%B8-%EC%97%B0%EC%82%B0-%ED%99%9C%EC%9A%A9\">비트 연산 활용</a></p>\n<ul>\n<li><a href=\"#%EB%B9%84%ED%8A%B8-%EB%A7%88%EC%8A%A4%ED%81%AC\">비트 마스크</a></li>\n<li><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%B5%9C%EC%A0%81%ED%99%94\">알고리즘 최적화</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></p>\n</li>\n</ul>","frontmatter":{"title":"비트 연산","date":"2026년 1월 17일","dateISO":"2026-01-17","description":"비트 연산에 대해 학습한 내용을 정리한 글입니다.","tags":["알고리즘","비트 연산"]}},"previous":{"fields":{"slug":"/자료구조, 알고리즘/해시/"},"frontmatter":{"title":"해시(Hash) 자료구조"}},"next":{"fields":{"slug":"/영어/문법-공부/"},"frontmatter":{"title":"로즈리의 Grammar Holic 정리"}}},"pageContext":{"id":"4edd7839-0cb2-5bd2-aad4-9629380a8e9b","previousPostId":"f2569bf2-7927-501e-8536-f85d71e9dd01","nextPostId":"c3f4086d-0a2c-55a5-8e34-14b44728d160"}},"staticQueryHashes":["2476208942","2637872971","3414707483"],"slicesMap":{}}