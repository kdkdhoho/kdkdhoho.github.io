{"componentChunkName":"component---src-templates-blog-post-js","path":"/자료구조, 알고리즘/dijkstra/","result":{"data":{"site":{"siteMetadata":{"title":"김동호 블로그"}},"markdownRemark":{"id":"8ec63347-7fc9-5a6d-a396-e73fdb3deb74","excerpt":"…","html":"<h1 id=\"1-다익스트라-알고리즘\" style=\"position:relative;\"><a href=\"#1-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"1 다익스트라 알고리즘 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 다익스트라 알고리즘</h1>\n<p>다익스트라 알고리즘은 <strong>특정 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘</strong>입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 283px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/15e7f0e482eaf27a979c089b3c1c6b18/bde6a/thumbnail.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.48101265822784%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9UlEQVR42oVUbW+yQBD0//+f52PTpIlt0rSfrDUaC7SiaBFEEZA359k5uOvZ1vQSwnHZnZ2d2WOAfp3PZ/PWe7OaBths5FWjaRu0bYtra9CjqMcGiuMYURR1eHmOZHiPh3sXj49TuK6jzn8D7gB9H4fnZ3jLJWIBORwOQmiDIAjU9263Q1KccHv7hqcnB2H4qYqXZWlANZmB5hQsFhiPx1itViqwruvL0pJQVZW03eB0OiFJEsznc3X2k6GsNE2xXq8VEJmthaHCkcSzsGh7SWyti6JAst+jkgLlcIhWvg1glmWqqtJGWOwlMJXv5O4OpRSzteXDVjXblUj1Ppsh2m47QAaQHbWzxebZzHXh99qyyFL2PGdx5vGMer+8viIWrRUgDxmU9kzYDqszyRdtw8/OBK3h5UQ1igh1Z4xpmU5SE66FgOi2tAG2k3oRhHm2gQaQtJlAkDAMjXtqZHpALQc70YW+z6IBJAgrMUhXZDuj0eiCIQEmk4nqwHbcAFZSIExrfLw7ig2vl22MGg2LYS635ng8Xr96peRN/A8Z0n9ijNffwq+KhYDRND2rehJ+3HcNmGc5PG+KbTQVhlt5EuX4XpJr3uGbGwQyKpns7Sm4ypB65XkBHUPnyIKi8+fgeh4cp5PjLzDLlOu/LupHw/4C0oD/ATl42vSk6CqrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"다익스트라 알고리즘\"\n        title=\"\"\n        src=\"/static/15e7f0e482eaf27a979c089b3c1c6b18/bde6a/thumbnail.png\"\n        srcset=\"/static/15e7f0e482eaf27a979c089b3c1c6b18/c26ae/thumbnail.png 158w,\n/static/15e7f0e482eaf27a979c089b3c1c6b18/bde6a/thumbnail.png 283w\"\n        sizes=\"(max-width: 283px) 100vw, 283px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>그래프의 모든 간선의 가중치에 음수가 없을 때만 다익스트라 알고리즘을 적용할 수 있는데요.<br>\n기본적으로 <strong>시작 노드를 기준으로 다른 노드까지의 최단 거리를 더하면서 갱신하는 구조</strong>이기 때문에 음수 가중치가 존재하는 순간 올바른 계산이 불가능해지기 떄문입니다.</p>\n<h1 id=\"2-알고리즘-순서\" style=\"position:relative;\"><a href=\"#2-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%88%9C%EC%84%9C\" aria-label=\"2 알고리즘 순서 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 알고리즘 순서</h1>\n<p>알고리즘이 동작하는 순서에 대해 자세히 살펴보겠습니다.</p>\n<ol>\n<li>특정 노드를 시작으로, 매 Round가 수행되는 개념으로 진행됩니다.</li>\n<li>각 Round는 한 노드에서 이동할 수 있는 다른 노드까지의 최단 경로를 갱신합니다.</li>\n<li>이때 탐색 범위 확장을 위해 최단 경로가 갱신된 노드로부터 다시 한번 Round를 수행합니다.</li>\n<li>위 과정을 반복하다보면 시작 노드로부터 연결된 모든 노드를 방문하게 되고, 결과적으로 방문한 모든 노드의 최단 경로가 기록됩니다.</li>\n</ol>\n<h1 id=\"3-구현\" style=\"position:relative;\"><a href=\"#3-%EA%B5%AC%ED%98%84\" aria-label=\"3 구현 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 구현</h1>\n<p>다익스트라 알고리즘은 구현 방법이 두 가지로 나뉩니다.</p>\n<p>하나는 기본형, 하나는 우선순위 큐를 이용한 개선된 구현 방법이 있습니다.</p>\n<h2 id=\"31-기본형\" style=\"position:relative;\"><a href=\"#31-%EA%B8%B0%EB%B3%B8%ED%98%95\" aria-label=\"31 기본형 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 기본형</h2>\n<p>기본형의 경우, 매 Round마다 아직 방문하지 않았으면서 최단 경로가 갱신된 노드를 찾는 코드가 포함됩니다.<br>\n아래는 기본형을 구현한 Python 코드입니다.</p>\n<blockquote>\n<p>백준의 <a href=\"https://www.acmicpc.net/problem/1753\">최단경로</a> 문제를 기준으로 작성해보았습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">INF <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span>\n\nn<span class=\"token punctuation\">,</span> m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># n: 노드 개수, m: 간선 개수</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 시작 노드</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\ndist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 모든 노드에 대해 최단거리를 기록하는 배열</span>\nvisited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 연결 그래프 완성</span>\n    <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> w <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        graph<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    dist<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token comment\"># 시작 노드의 거리를 0으로 초기화</span>\n    dijkstra<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 다익스트라 알고리즘 실행</span>\n    \n<span class=\"token keyword\">def</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n        curr <span class=\"token operator\">=</span> not_visited_and_min_dist_node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> curr <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">break</span>\n\n        <span class=\"token keyword\">for</span> nxt<span class=\"token punctuation\">,</span> weight <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> visited<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">continue</span>\n            <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight <span class=\"token operator\">&lt;</span> dist<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 연결된 노드까지의 최단 경로가 갱신이 되는 경우</span>\n                dist<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dist<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight <span class=\"token comment\"># 새로운 최단 경로 값을 기록합니다.</span>\n\n        visited<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        \n<span class=\"token comment\"># 방문하지 않았으면서 최단 경로가 갱신된 노드를 찾는 메서드</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">not_visited_and_min_dist_node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    min_dist <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span>\n    result <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> min_dist<span class=\"token punctuation\">:</span>\n            min_dist <span class=\"token operator\">=</span> dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            result <span class=\"token operator\">=</span> i\n            \n    <span class=\"token keyword\">return</span> result\n\n\nmain<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>매 Round마다 노드를 순회하면서 다음 Round에서 실행될 노드를 찾는 과정이 포함됩니다.<br>\n따라서 노드의 개수를 V라고 했을 때, <strong>기본형의 시간 복잡도는 O(V^2)</strong> 입니다.</p>\n<p>사실 간선의 개수를 E라고 했을 때, 원래 시간 복잡도는 O(E + V^2) 입니다. 하지만 어떤 그래프든 O(E)의 상한값을 O(V^2)로 치환할 수 있기 때문에 O(V^2)로 간소화합니다.</p>\n<h2 id=\"32-최적화형\" style=\"position:relative;\"><a href=\"#32-%EC%B5%9C%EC%A0%81%ED%99%94%ED%98%95\" aria-label=\"32 최적화형 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 최적화형</h2>\n<p>우선순위 큐를 이용한 최적화 방식은, 다음 Round에 수행할 노드를 O(logV) 만에 구할 수 있게 됩니다.</p>\n<blockquote>\n<p>이번에도 동일한 문제를 기준으로 코드를 작성해보았습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> heapq <span class=\"token keyword\">import</span> heappop<span class=\"token punctuation\">,</span> heappush\n\nINF <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span>\n\nn<span class=\"token punctuation\">,</span> m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\ndist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 모든 노드에 대해 최단 거리를 기록하는 배열</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> w <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        graph<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    dist<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token comment\"># 시작 노드의 거리를 0으로 초기화</span>\n    dijkstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span> <span class=\"token comment\"># 다익스트라 알고리즘 실행</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INF\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    min_heap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># (거리, 노드) 쌍의 튜플을 우선순위 큐(최소 힙)에 저장합</span>\n\n    <span class=\"token keyword\">while</span> min_heap<span class=\"token punctuation\">:</span>\n        w<span class=\"token punctuation\">,</span> curr <span class=\"token operator\">=</span> heappop<span class=\"token punctuation\">(</span>min_heap<span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\"># 다익스트라 알고리즘은 최단 경로가 갱신된 노드로부터 Round를 수행합니다.</span>\n        <span class=\"token comment\"># 따라서 우선순위 큐에 있던 거리가 dist 배열에 저장된 거리보다 큰 경우 Round를 진행하지 않습니다.</span>\n        <span class=\"token keyword\">if</span> w <span class=\"token operator\">></span> dist<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token builtin\">next</span><span class=\"token punctuation\">,</span> weight <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight <span class=\"token operator\">&lt;</span> dist<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 연결된 노드까지의 최단 경로가 갱신이 되는 경우</span>\n                dist<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dist<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight <span class=\"token comment\"># 최단 경로를 갱신합니다.</span>\n                heappush<span class=\"token punctuation\">(</span>min_heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">next</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 우선순위 큐에 (새롭게 갱신된 거리, 노드 번호) 튜플을 삽입합니다.</span>\n\n\nmain<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>우선순위 큐를 통해 매 Round에서 실행될 노드를 찾는 연산이 O(V^2)에서 O(logV)로 줄었기 떄문에, 결과적으로 <strong>최적화형의 시간 복잡도는 O(ElogV)가 됩니다</strong>.</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">1. 다익스트라 알고리즘</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%88%9C%EC%84%9C\">2. 알고리즘 순서</a></p>\n</li>\n<li>\n<p><a href=\"#3-%EA%B5%AC%ED%98%84\">3. 구현</a></p>\n<ul>\n<li><a href=\"#31-%EA%B8%B0%EB%B3%B8%ED%98%95\">3.1. 기본형</a></li>\n<li><a href=\"#32-%EC%B5%9C%EC%A0%81%ED%99%94%ED%98%95\">3.2. 최적화형</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"다익스트라 알고리즘","date":"2026년 2월 14일","dateISO":"2026-02-14","description":"다익스트라 알고리즘의 특징, 원리, 기본형 구현, 최적화형 구현에 대해 기록했습니다.","tags":["algorithm","dijkstra"]}},"previous":{"fields":{"slug":"/Linux/cpu-사용량-급증-트러블슈팅/"},"frontmatter":{"title":"[Ubuntu] CPU 사용량 급증 트러블슈팅"}},"next":{"fields":{"slug":"/자료구조, 알고리즘/그래프-탐색/"},"frontmatter":{"title":"그래프, 그래프 탐색 알고리즘"}}},"pageContext":{"id":"8ec63347-7fc9-5a6d-a396-e73fdb3deb74","previousPostId":"a52ed615-3999-5c56-90cf-9964461e0c51","nextPostId":"8300441e-cf92-5349-ace0-11e81e7d6435"}},"staticQueryHashes":["2476208942","2637872971","3414707483"],"slicesMap":{}}