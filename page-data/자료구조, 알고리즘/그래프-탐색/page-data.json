{"componentChunkName":"component---src-templates-blog-post-js","path":"/자료구조, 알고리즘/그래프-탐색/","result":{"data":{"site":{"siteMetadata":{"title":"김동호 블로그"}},"markdownRemark":{"id":"8300441e-cf92-5349-ace0-11e81e7d6435","excerpt":"…","html":"<h1 id=\"1-그래프\" style=\"position:relative;\"><a href=\"#1-%EA%B7%B8%EB%9E%98%ED%94%84\" aria-label=\"1 그래프 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 그래프</h1>\n<p>자료구조에는 <strong>선형 자료구조</strong>(배열, 리스트, 스택, 큐 등)와 <strong>비선형 자료구조</strong>(그래프, 트리 등)이 있습니다.</p>\n<p>선형 자료구조는 데이터의 순서가 중요한 자료구조입니다.<br>\n반면 <strong>비선형 자료구조는 데이터의 관계를 표현한 자료구조</strong>입니다.</p>\n<p>그래프는 노드와 간선으로 표현할 수 있습니다.<br>\n<strong>노드는 데이터 자체</strong>를 의미하고, <strong>간선은 관계</strong>를 의미합니다.</p>\n<p>간선은 단방향과 양방향으로 또 나뉩니다.<br>\n단방향은 한 노드에서 다른 한 노드로만 향하는 관계일 때 사용되며, 양방향은 양 노드가 서로를 향하는 관계일 때 사용됩니다.<br>\n이때 양방향은 방향성을 반드시 표현하지 않아도 됩니다.</p>\n<p>그래프에서 '<em><strong>연결 요소</strong></em>' 라는 단어가 있습니다.<br>\n연결 요소는 연결된 노드를 하나의 집합으로 묶어서 부르는 것을 의미합니다.<br>\n예를 들어 아래 그림의 경우 연결 요소는 5개입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 432px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/25e4a932caa1091466a153cad58307c4/0e0c3/%EC%97%B0%EA%B2%B0%EC%9A%94%EC%86%8C.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.291139240506325%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACKElEQVR42kVTia6cMBDj/3+y6rEPFgi5E8iB6wndV6RRRMh4bMdMNzr63RBTxKEV5uULy7rAegMXHJy3Y/Vcr3Ki1AullVHPc3+XYE0DsDcYq6FZMXhEdeBynuVwWYdszACK0Q/gY15g1hXmUPAcdl55DLtJbGqtkdmBUzZKgd92rO8Fy/yF+fUHyzJjfb2QtRl8eq2oPqDyfDo0MivFgEAizhlMxsr0Og4XHlTvlRLJrlxo9w3LhvfP32jnI/FufbAWNerYUWhVY98YRqWTSM3n+e1EDQk9ZfSYca4KRTs07tWY0LjfEn10YQzc9330NJ5tOQ+EAaiOg17EZ8rdkehf2jVB6A1BnPfYtg3lvFAF7DBjeiZICHzPMuTpnzRvVho+shPlqNc8ACwvJeUEa3kRSkH8FpYySFhV9sgZUSg9A7CQeu/9YXcxDmR3aI1SPrHA+N6kyEgsGXvxhHlvvOELgYT8rh7AGMN3Y/WkTdMNGX2GfJ4msowbUuViZD2th34tSMoM3wegMf/ZFAEkkHga4j9PSyUQszlvcOvOqBhkKxkNQ76dV0bHiPkPYGsVAtoZEblNMdh5xoJ5TEqPyZ7SPGWFlIYdkWukfFFyMPRuU7ivh9Qk3AtfrLMojEbeDmw/fvFv0fzE34kMT0p1xsIT4BYransSwIra0tdIG9rwmYCPV5UbmtMDZckNyoHPr9rz9ZRkkLaI15Ux6YxRJ3hkdCQJzjn8BQUA8Tm5JIZ5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"연결 요소 예시\"\n        title=\"\"\n        src=\"/static/25e4a932caa1091466a153cad58307c4/0e0c3/%EC%97%B0%EA%B2%B0%EC%9A%94%EC%86%8C.png\"\n        srcset=\"/static/25e4a932caa1091466a153cad58307c4/c26ae/%EC%97%B0%EA%B2%B0%EC%9A%94%EC%86%8C.png 158w,\n/static/25e4a932caa1091466a153cad58307c4/6bdcf/%EC%97%B0%EA%B2%B0%EC%9A%94%EC%86%8C.png 315w,\n/static/25e4a932caa1091466a153cad58307c4/0e0c3/%EC%97%B0%EA%B2%B0%EC%9A%94%EC%86%8C.png 432w\"\n        sizes=\"(max-width: 432px) 100vw, 432px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>'<em><strong>가중치</strong></em>' 라는 단어도 있습니다.<br>\n한 노드에서 다른 노드로 향할 때, 간선의 크기를 의미합니다.<br>\n예를 들어, 서울이 노드 A, 부산이 노드 B라고 할 때, A에서 B로 향하는 가중치는 10이라고 표현할 수 있습니다.</p>\n<h1 id=\"2-그래프-탐색-알고리즘\" style=\"position:relative;\"><a href=\"#2-%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"2 그래프 탐색 알고리즘 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 그래프 탐색 알고리즘</h1>\n<p>그래프를 탐색하는 방법(알고리즘)에는 크게 두 가지가 있습니다. DFS와 BFS 입니다.</p>\n<h2 id=\"21-dfs-depth-first-search\" style=\"position:relative;\"><a href=\"#21-dfs-depth-first-search\" aria-label=\"21 dfs depth first search permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. DFS (Depth First Search)</h2>\n<h3 id=\"211-특징\" style=\"position:relative;\"><a href=\"#211-%ED%8A%B9%EC%A7%95\" aria-label=\"211 특징 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.1. 특징</h3>\n<p>깊이 우선 탐색이라 불리는 DFS는, 그래프를 탐색할 때 다음 노드를 먼저 방문하는 식으로 탐색합니다.<br>\n이미지로 표현하면 다음과 같습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9cddb8a9afa760f7b656e2036115ab14/0b533/dfs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.92405063291139%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACjUlEQVR42mNgIAD+///PCKLnLFttOHfVOnsGSgDMsKysLJ4dZ24/3njsyv+Fy9dpgsTq6+uZSDYMpombm0F88qK1WycvXHPGzdtbHyrPRLKhS5cuFbT38JABMtXN9MwU7excdIFseTU1NcWTJ08KE2VIff1+FhC9auNOxZV7Tr6fvXrbdQ8bG9FV+06fW7z10Aegq2SmLF2/dtnOo/+Xb9/tAFI7c+YZVpzeXLVqFTOInV9Raz53/Z4fy3cePVZfWCi0Bmjgyt3HP3Z0dMgt23lk5oLN+/839EyMBlsO1AMLbwwwZ84cXnl5eQkgUyk8Oto5LCwMHGaVra3i3d1T5EHs8PBw2eS0NF8gU4GDg0Nu2+LFfCjhCQpgEL18x16rFXtOfOictmBOVVWV9NIdR68s3Lx/U31oKBs4OKDqlmw50L9g0/6Xy7fs0qzrnFQ6f9O+n9MWr4yHhtl/pm3btrGD2BNmL4zafub2/6VbDixYtGiR4qKtB/8s3rr/Wnd3NzfYa///g4Njxa6j67afufW/rXeK16JNu/PWH774f8bStVUwB8L8LgTEmuFRUT7FxcViIIFZ85cYTFywQBkpTYLVhsbFSSelpXkDmapAIL1643ZtoJc5wKYsWLfDbOnWQ8eL61oLm5omqM5du/Po/HXbM2Cux5bQpy1Zmzd54dpDzd3d8umFlclz1u48NGvVRiewojW7jxedevz5/5q9x6csWbfd/8zTb//X7juzEyS3//9/FlisI4NVu47tAgXNzCXLPZfvOFR34sHH/wvW72yHhOHEiXzzVm9Omj5/uUIoAwPzvJUb46csWKaN7CJ0F05fvEpr4erN8fX19iytE2aLz12+PnnC7NniIEUA8V0+q8tYkZ0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"DFS의 노드 탐색 순서 (출처: Wikipedia - 깊이 우선 탐색)\"\n        title=\"\"\n        src=\"/static/9cddb8a9afa760f7b656e2036115ab14/0b533/dfs.png\"\n        srcset=\"/static/9cddb8a9afa760f7b656e2036115ab14/c26ae/dfs.png 158w,\n/static/9cddb8a9afa760f7b656e2036115ab14/6bdcf/dfs.png 315w,\n/static/9cddb8a9afa760f7b656e2036115ab14/0b533/dfs.png 500w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"212-용도\" style=\"position:relative;\"><a href=\"#212-%EC%9A%A9%EB%8F%84\" aria-label=\"212 용도 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.2. 용도</h3>\n<p>DFS를 주로 사용하는 경우는 다음과 같습니다.</p>\n<ul>\n<li>연결 요소의 크기 구하기</li>\n<li>연결 요소의 개수 구하기</li>\n<li>Flood Fill\n<ul>\n<li>2차원 배열의 데이터가 주어지고, 특정 위치의 연결 요소의 크기를 구하는 경우가 있을 때, 이 크기를 DFS를 이용하여 구할 수 있습니다. (<a href=\"https://www.acmicpc.net/problem/2667\">대표적인 문제</a>)</li>\n</ul>\n</li>\n<li>이분 그래프 판별</li>\n<li>사이클 존재 파악 및 사이클 크기 구하기</li>\n</ul>\n<h3 id=\"213-기본-구현\" style=\"position:relative;\"><a href=\"#213-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%ED%98%84\" aria-label=\"213 기본 구현 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.3. 기본 구현</h3>\n<p>DFS를 구현할 때 가장 먼저, 주어진 노드와 간선 정보를 그래프 형태로 저장해야 합니다.<br>\n그래프를 저장할 때는 <strong>인접 행렬</strong>과 <strong>인접 그래프</strong> 방식으로 구현할 수 있습니다.</p>\n<ol>\n<li>인접 행렬</li>\n</ol>\n<p>2차원 배열을 만들고, 연결 정보를 이 배열에 저장합니다.<br>\n만약 <code class=\"language-text\">arr</code> 라는 이름의 변수가 있다고 가정하면 노드 x에서 노드 y로 향하는 간선의 정보는 <code class=\"language-text\">arr[x][y]</code>로 접근할 수 있습니다.</p>\n<p>간선의 개수가 k개이고, 모든 간선의 가중치가 1인 양방향 그래프인 경우 아래 코드와 같이 저장할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> n <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># k: 간선의 개수</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    arr<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    arr<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span></code></pre></div>\n<ol start=\"2\">\n<li>인접 그래프</li>\n</ol>\n<p>각 노드에 연결된 노드를 리스트 형태로 저장합니다.<br>\n만약 n개의 노드와 k개의 간선이 있다고 가정하면, 인접 그래프로 저장하는 코드는 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">graph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># k: 간선의 개수</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></code></pre></div>\n<p>인접 행렬은 공간을 더 많이 차지하는 대신, O(1) 만에 연결 정보를 조회할 수 있는 장점이 있습니다.<br>\n반면, 인접 그래프는 공간을 더 효울적으로 사용하는 대신, 그래프를 탐색할 때 연결된 노드 개수만큼 선형적으로 늘어난다는 단점이 있습니다.</p>\n<p>따라서 문제 요구사항이나 제약 조건에 따라 적절한 방식을 사용하는 것이 좋겠습니다.</p>\n<p>이제 DFS 탐색을 위해서는 다음과 같이 작성할 수 있는데요. 인접 그래프 형태로 저장했다고 가정하고 구현해보겠습니다.<br>\n이때 한 노드를 중복 방문하는 것을 방지하기 위해 <code class=\"language-text\">visited = [False] * n</code> 과 같이 배열 형태로 값을 기록하는데요. 방문 처리는 DFS 함수 내부의 첫 번째 라인에서 수행하는 것이 권장됩니다.</p>\n<p>특정 노드에 방문했을 때 해야 할 일(방문 표시, 결과 합산 등)이 한곳에 모여 있어 코드가 깔끔하고 별도로 처리해줄 필요가 없어 실수할 확률이 줄어듭니다. 또한 재귀 함수는 자기 자신을 정의하는 함수라는 측면에서도 자연스럽습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 파이썬의 기본 재귀 호출 한도는 보통 1,000회로 제한됩니다.  </span>\n<span class=\"token comment\"># 따라서 `sys` 모듈의 `setrecursionlimit=n`으로 최대 한도를 설정합니다.</span>\n<span class=\"token keyword\">import</span> sys\nsys<span class=\"token punctuation\">.</span>setrecursionlimit<span class=\"token punctuation\">(</span>n<span class=\"token operator\">**</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 그래프</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># k: 간선의 개수</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n    \n<span class=\"token comment\"># 노드 방문 여부</span>\nvisited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> n\n\n<span class=\"token comment\"># DFS 로직</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>curr_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    visited<span class=\"token punctuation\">[</span>curr_node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    \n    <span class=\"token keyword\">for</span> next_node <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>curr_node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> visited<span class=\"token punctuation\">[</span>next_node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n        dfs<span class=\"token punctuation\">(</span>next_node<span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 DFS 코드를 기반으로, 문제에서 필요한 해를 구하는 코드를 추가하면 됩니다.</p>\n<h3 id=\"214-이분-그래프\" style=\"position:relative;\"><a href=\"#214-%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84\" aria-label=\"214 이분 그래프 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.4. 이분 그래프</h3>\n<p>이분 그래프란, 모든 정점을 빨간색, 혹은 파란색으로 칠했을 때, 모든 간선에 대해서 각 간선이 빨간색이랑 파란색을 포함하도록 색칠할 수 있는 그래프입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f5732da6a620c82a6001acc2737e814b/0b533/%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.27848101265823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABh0lEQVR42oVU207CQBA9VCVeIVRUkGIpVkS8JF5elAejJsbENw1R/8H4C7yoH+Mn+qDOlrNkupS6yUlnZ3bncnY6gLN+gQXBGbcF1z4EPPP9Bk5/gBJyVnL5BagOgDcRgwynHr9rD8DrE9CcFlgrNwWHghPK1mbt64JjwRH+cZgYikBXUvNFDhWggm0b3RZQMWdFnsvLzucFMEtTYltQE6wKdnl2n2dMhhtZWdpNy/Cj5Drlc8G1CrpDuSKI88o2kWcplwURszNfqRINUuCrOwfqzkS5sfOalxjxZFebmXrqXsigY1/WEDmRTelXgqrSrVBXV7pyVtlG6KkXa/BxlvkQdsV0EJJjqEdKlV1RRJuG7qjS9xhIy7b8KKPsZJlsSmyBjsNji1QsqaCeoilI2waYocOmclZweIswP/G6mvswoaOHIui973DidkGXHHtTfoiAPiTgM+6lw/pOKXa0jPa3uMAN7lI6d2DUZEI9QmbGp6Q6xGLeBMKHtND7uFWyB8GXlDtE5w+z4B7h6kuPfwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"이분 그래프 예시 (출처: Wikipedia)\"\n        title=\"\"\n        src=\"/static/f5732da6a620c82a6001acc2737e814b/0b533/%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C.png\"\n        srcset=\"/static/f5732da6a620c82a6001acc2737e814b/c26ae/%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C.png 158w,\n/static/f5732da6a620c82a6001acc2737e814b/6bdcf/%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C.png 315w,\n/static/f5732da6a620c82a6001acc2737e814b/0b533/%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C.png 500w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이분 그래프도 DFS 알고리즘을 이용해서 판별할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n\n<span class=\"token comment\"># 이분 그래프 판별 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">is_bipartite_graph</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">,</span> color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    colors<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> color\n    \n    <span class=\"token keyword\">for</span> nxt <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> colors<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 이미 방문을 한 적이 있는 노드</span>\n            <span class=\"token keyword\">if</span> color<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> color<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 연결된 노드와 현재 노드의 색상이 같으면 이분 그래프가 아니게 된다.</span>\n                answer <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n            <span class=\"token keyword\">continue</span>\n        \n        <span class=\"token comment\"># 연결된 노드를 탐색하면서 현재 노드와 다른 색상으로 칠한다. </span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> is_bipartite_graph<span class=\"token punctuation\">(</span>nxt<span class=\"token punctuation\">,</span> colors<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n          <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\nn<span class=\"token punctuation\">,</span> m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nsys<span class=\"token punctuation\">.</span>setrecursionlimit<span class=\"token punctuation\">(</span>n<span class=\"token operator\">**</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 그래프 생성</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n      \ncolors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 색상 기록 배열. 0: 방문하지 않은 노드, 1: 빨간색, -1: 파란색</span>\nanswer <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> colors<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 아직 방문하지 않았다면</span>\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> is_bipartite_graph<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n          answer <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n          <span class=\"token keyword\">break</span>\n        \n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>answer<span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"215-사이클-존재-유무-파악-및-사이클-크기-구하기\" style=\"position:relative;\"><a href=\"#215-%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%A1%B4%EC%9E%AC-%EC%9C%A0%EB%AC%B4-%ED%8C%8C%EC%95%85-%EB%B0%8F-%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%81%AC%EA%B8%B0-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\"215 사이클 존재 유무 파악 및 사이클 크기 구하기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.5. 사이클 존재 유무 파악 및 사이클 크기 구하기</h3>\n<p>그래프에 사이클이 존재하는지 판별할 수 있고, 사이클의 크기도 DFS를 통해 구할 수 있습니다.</p>\n<p>기본 구현(Python)은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">depth  <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> n <span class=\"token comment\"># 각 노드의 방문 깊이(순서)를 기록하는 배열입니다.</span>\nhas_cycle <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n\n<span class=\"token comment\"># cur: 현재 방문한 노드 번호입니다.</span>\n<span class=\"token comment\"># prev: 이전에 방문한 노드 번호입니다.</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">,</span> prev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> nxt <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> prev <span class=\"token operator\">!=</span> nxt<span class=\"token punctuation\">:</span> <span class=\"token comment\"># curr과 연결된 노드인 경우</span>\n            <span class=\"token keyword\">if</span> depth<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 해당 노드에 처음 방문하는 경우</span>\n                depth<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> depth<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n                dfs<span class=\"token punctuation\">(</span>nxt<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">elif</span> depth<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> depth<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 연결된 노드가 현재 노드보다 먼저 방문한 경우 -> 사이클 존재</span>\n                has_cycle <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n                size <span class=\"token operator\">=</span> depth<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> depth<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token comment\"># 사이클의 사이즈를 구한다.    </span></code></pre></div>\n<p>대표적인 문제로는 <a href=\"https://www.acmicpc.net/problem/20426\">백준의 아침은 고구마야</a>가 있으니 위를 참고하여 풀어보는 것도 좋겠습니다.</p>\n<hr>\n<h2 id=\"22-bfs\" style=\"position:relative;\"><a href=\"#22-bfs\" aria-label=\"22 bfs permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. BFS</h2>\n<h3 id=\"221-특징\" style=\"position:relative;\"><a href=\"#221-%ED%8A%B9%EC%A7%95\" aria-label=\"221 특징 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.1. 특징</h3>\n<p>너비 우선 탐색이라 불리는 BFS(Breadth First Search)는 그래프 상에서 특정 노드를 기준으로, 연결된 노드를 먼저 탐색하는 방식입니다.</p>\n<p>말보단 아래 이미지를 보는 것이 이해가 훨씬 쉽습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 187px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/deb2a2324a722f3a1074d5016a667371/47fe2/bfs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.67088607594937%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAABTklEQVR42p2Uhw7DIAxE+f8/zd57UD1LV6GmadJYQmBsDvtscP5Cuq7zZVn6qqp827ZX7t79Mi7L4vM898Mw2AB4HMfngPu+G0iWZTZYb9v2DBAwpO97X9e1b5rGRmj7O0IEMKIChPUjDgGgAADEcfzeT9PU0sa2rut9QFUV3kiZVKk2FzBTGIr1LX33jTfAOMAAjIhUZbXPT0A2NRClqwhlIzJVOyxQCHpIGTD1WlEUh0NqnWmazPcQIUYAcCAdZoQUkyR568g8zxYhPErXGTAolONGBpzgjBM340jazKTNAfyIWvsAqPJQgM0BhBEFIA6jEwVOamxs4hZw/JnRoygyfwPUpqqJcDOgpBw2tl4LNjLR54HOgCYnUj/JRQ+LcvY0Qxtrd3ZAP034GZyBXL4UeFOR7nxZly8FMLhT25y9ittvGcLhTy1F+ncjfAGhutRjqaJK1gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"BFS\"\n        title=\"\"\n        src=\"/static/deb2a2324a722f3a1074d5016a667371/47fe2/bfs.png\"\n        srcset=\"/static/deb2a2324a722f3a1074d5016a667371/c26ae/bfs.png 158w,\n/static/deb2a2324a722f3a1074d5016a667371/47fe2/bfs.png 187w\"\n        sizes=\"(max-width: 187px) 100vw, 187px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"222-용도\" style=\"position:relative;\"><a href=\"#222-%EC%9A%A9%EB%8F%84\" aria-label=\"222 용도 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.2. 용도</h3>\n<ul>\n<li><strong>가중치가 모두 1인 그래프에서 최단 거리 구하기</strong> ()</li>\n<li>단계별 확산 시뮬레이션</li>\n<li>그래프에서 depth 단위로 끊어서 탐색하기</li>\n</ul>\n<h3 id=\"223-기본-구현\" style=\"position:relative;\"><a href=\"#223-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%ED%98%84\" aria-label=\"223 기본 구현 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.3. 기본 구현</h3>\n<p>DFS는 재귀 함수로 구현하는 반면, BFS는 <strong>큐</strong>를 이용해서 구현합니다.</p>\n<p>인접 그래프 형태의 자료구조에서는 다음과 같이 작성하는 것이 기본 형태입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    visited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> n\n    q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    \n    visited<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n        curr <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        \n        <span class=\"token keyword\">for</span> <span class=\"token builtin\">next</span> <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> visited<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">continue</span>\n                \n            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">)</span>\n            visited<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></code></pre></div>\n<p>이때 유의해야 할 점은, <strong>방문 여부를 처리할 때 반드시 큐에 넣기 전에 해야 한다는 점</strong>입니다.<br>\n큐에서 뺄 때 처리하면, 중복된 노드가 큐에 여러 번 들어갈 수 있어 불필요한 연산이 수행될 수 있기 때문입니다.</p>\n<p>만약 2차원 격자에서 BFS 방식으로 탐색하려면 다음과 같이 작성하는 것이 기본 형태입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\ndx <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\ndy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span>start_x<span class=\"token punctuation\">,</span> start_y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    visited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> n <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>start_x<span class=\"token punctuation\">,</span> start_y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    \n    visited<span class=\"token punctuation\">[</span>start_x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>start_y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>start_x<span class=\"token punctuation\">,</span> start_y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n        x<span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        \n        <span class=\"token keyword\">for</span> d <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            next_x<span class=\"token punctuation\">,</span> next_y <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> dx<span class=\"token punctuation\">[</span>d<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">+</span> dy<span class=\"token punctuation\">[</span>d<span class=\"token punctuation\">]</span>\n            \n            <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> in_array<span class=\"token punctuation\">(</span>next_x<span class=\"token punctuation\">,</span> next_y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">continue</span>\n            <span class=\"token keyword\">if</span> visited<span class=\"token punctuation\">[</span>next_x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>next_y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">continue</span>\n                \n            visited<span class=\"token punctuation\">[</span>next_x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>next_y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>next_x<span class=\"token punctuation\">,</span> next_y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"224-그래프에서-depth-단위로-끊어서-탐색하기\" style=\"position:relative;\"><a href=\"#224-%EA%B7%B8%EB%9E%98%ED%94%84%EC%97%90%EC%84%9C-depth-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%81%8A%EC%96%B4%EC%84%9C-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0\" aria-label=\"224 그래프에서 depth 단위로 끊어서 탐색하기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.4. 그래프에서 depth 단위로 끊어서 탐색하기</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token comment\"># 생략</span>\n\nvisited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> n\nq <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nq<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\nvisited<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n\n<span class=\"token comment\"># while문이 실행될 때마다 시작 노드(n)를 기준으로 거리가 1씩 증가하는 노드들만 탐색하게 된다.</span>\n<span class=\"token comment\"># (거리가 1인 노드들 -> 거리가 2인 노드들 -> ...)</span>\n<span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n    size <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        curr <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> nxt <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>curr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> visited<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">continue</span>\n                \n            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>nxt<span class=\"token punctuation\">)</span>\n            visited<span class=\"token punctuation\">[</span>nxt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></code></pre></div>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%EA%B7%B8%EB%9E%98%ED%94%84\">1. 그래프</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">2. 그래프 탐색 알고리즘</a></p>\n<ul>\n<li>\n<p><a href=\"#21-dfs-depth-first-search\">2.1. DFS (Depth First Search)</a></p>\n<ul>\n<li><a href=\"#211-%ED%8A%B9%EC%A7%95\">2.1.1. 특징</a></li>\n<li><a href=\"#212-%EC%9A%A9%EB%8F%84\">2.1.2. 용도</a></li>\n<li><a href=\"#213-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%ED%98%84\">2.1.3. 기본 구현</a></li>\n<li><a href=\"#214-%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84\">2.1.4. 이분 그래프</a></li>\n<li><a href=\"#215-%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%A1%B4%EC%9E%AC-%EC%9C%A0%EB%AC%B4-%ED%8C%8C%EC%95%85-%EB%B0%8F-%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%81%AC%EA%B8%B0-%EA%B5%AC%ED%95%98%EA%B8%B0\">2.1.5. 사이클 존재 유무 파악 및 사이클 크기 구하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#22-bfs\">2.2. BFS</a></p>\n<ul>\n<li><a href=\"#221-%ED%8A%B9%EC%A7%95\">2.2.1. 특징</a></li>\n<li><a href=\"#222-%EC%9A%A9%EB%8F%84\">2.2.2. 용도</a></li>\n<li><a href=\"#223-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%ED%98%84\">2.2.3. 기본 구현</a></li>\n<li><a href=\"#224-%EA%B7%B8%EB%9E%98%ED%94%84%EC%97%90%EC%84%9C-depth-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%81%8A%EC%96%B4%EC%84%9C-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0\">2.2.4. 그래프에서 depth 단위로 끊어서 탐색하기</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"그래프, 그래프 탐색 알고리즘","date":"2026년 2월 14일","dateISO":"2026-02-14","description":"그래프 자료구조와 그래프 탐색 알고리즘인 DFS, BFS에 대해 학습한 내용을 기록했습니다.","tags":["그래프","그래프 탐색 알고리즘","BFS","DFS"]}},"previous":{"fields":{"slug":"/자료구조, 알고리즘/dijkstra/"},"frontmatter":{"title":"다익스트라 알고리즘"}},"next":null},"pageContext":{"id":"8300441e-cf92-5349-ace0-11e81e7d6435","previousPostId":"8ec63347-7fc9-5a6d-a396-e73fdb3deb74","nextPostId":null}},"staticQueryHashes":["2476208942","2637872971","3414707483"],"slicesMap":{}}