{"componentChunkName":"component---src-templates-post-jsx","path":"/05-web-server/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"e210085d-c6e8-5cce-81f0-c7773af272fa","excerpt":"들어가며 이 글은 그림으로 배우는 Http & Network Basic을 읽고 학습한 내용을 정리한 글입니다. 이번 장은 WAS 대신 다양한 기능을 대신 수행해주는 웹 서버와 캐싱에 대해 알아보겠습니다. 1. 멀티 도메인을 가능하게 하는 가상 호스트 우선 멀티 도메인이란, WAS는 1대이지만 이를 가리키는 호스트(도메인)는 2개 이상인 상태를 의미한다.\n…","html":"<h2>들어가며</h2>\n<p>이 글은 <a href=\"https://m.yes24.com/Goods/Detail/15894097\">그림으로 배우는 Http &#x26; Network Basic</a>을 읽고 학습한 내용을 정리한 글입니다.</p>\n<p>이번 장은 WAS 대신 다양한 기능을 대신 수행해주는 <strong>웹 서버</strong>와 <strong>캐싱</strong>에 대해 알아보겠습니다.</p>\n<h2>1. 멀티 도메인을 가능하게 하는 가상 호스트</h2>\n<p>우선 멀티 도메인이란, WAS는 1대이지만 이를 가리키는 호스트(도메인)는 2개 이상인 상태를 의미한다.<br>\n웹 서버는 이 멀티 도메인을 수행할 수 있도록 <strong>가상 호스트</strong> 기능을 제공한다.</p>\n<p>Nginx에서도 <code class=\"language-text\">Server Block</code>으로 가상 호스트를 설정할 수 있다.<br>\n방법은 <a href=\"https://www.sabujak.org/2023/10/02/nginx-virtual-host%EA%B0%80%EC%83%81%ED%98%B8%EC%8A%A4%ED%8A%B8%EB%A1%9C-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%91%90-%EA%B0%9C-%EC%9A%B4%EC%98%81%ED%95%98%EA%B8%B0/\">이 블로그</a>에서 확인할 수 있다.</p>\n<p>가상 호스트를 통해 한 대의 WAS로 2개 이상의 사이트의 트래픽을 처리할 수 있을 것이다.<br>\n이를 통해 효율적인 운영이 가능해진다고 생각한다.</p>\n<h2>2. 프록시, 게이트웨이, 터널</h2>\n<p>HTTP는 클라이언트와 서버 외에 <strong>프록시, 게이트웨이, 터널과 같은 통신을 중계하는 프로그램</strong>과 서버를 연계하는 것도 가능하다.</p>\n<h3>2-1. 프록시</h3>\n<p>프록시 서버는 Forward Proxy, Reverse Proxy로 나눌 수 있다.<br>\n이 둘의 차이는 프록시 서버의 위치이며, 위치에 따라 얻을 수 있는 장점이 다를 수 있다.</p>\n<h4>2-1-1. Forward Proxy</h4>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/d1246f5af79f0b1fd3644137ef97896c/3643c/forward-proxy.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABK0lEQVR42q1STU+DQBDtn+dveKjxL3gwchAPTUPUyIHGpq1QhFKClDUgsLA8O5NApeHQQ19CMrPLvI/JTnBlTLrCzUKEv99ct23bf/8xdjZK2LQKN5/3eIk/0EoFWcuLHSmlBiK9w6fwDYuDA1XVCPd7CCHg+z6yLOMhKSXSNEWe52iahkk8z4NhGNB1HXVdnwiPGrh1H2BGC6iygR/4cF0Xs9mMSYkkjmNsNhs4jsNiZVny/XQ6haZp3A8cPu/fsRRb1KWE+BGsWFUVuznfYRcxSRKsVitYlsUpesLjL7j7esRrsqSGQXHm8zmiKOKeiNfrNRNQfALd2bbNrgcOSdHf7XAQae+GYtJwURS9O9pnt1MC1aZpslDnuifcHncWBMH13uE5LnlzYzN/ekwFrOOJdXwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Forward Proxy 구조' title='' src='/static/d1246f5af79f0b1fd3644137ef97896c/ca1dc/forward-proxy.png' srcset='/static/d1246f5af79f0b1fd3644137ef97896c/e7570/forward-proxy.png 170w,\n/static/d1246f5af79f0b1fd3644137ef97896c/f46e7/forward-proxy.png 340w,\n/static/d1246f5af79f0b1fd3644137ef97896c/ca1dc/forward-proxy.png 680w,\n/static/d1246f5af79f0b1fd3644137ef97896c/02d09/forward-proxy.png 1020w,\n/static/d1246f5af79f0b1fd3644137ef97896c/9d567/forward-proxy.png 1360w,\n/static/d1246f5af79f0b1fd3644137ef97896c/3643c/forward-proxy.png 1400w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Forward Proxy 구조</figcaption>\n  </figure></p>\n<p>클라이언트(브라우저)의 요청이 서버로 도착하기 위해 네트워크를 타기 전, 프록시 서버가 요청을 받아서 중계 및 전달하는 역할을 수행한다.<br>\n즉, 클라이언트 바로 뒤에 위치한다.</p>\n<p>이를 통해 미리 설정해놓은 <strong>특정 사이트 접근을 차단</strong>할 수 있으며 Proxy Server에 <strong>서버로부터 받은 응답을 캐싱</strong>한다면 더 빠른 응답을 내려줄 수 있다. 또한 클라이언트의 정보를 암호화하여 서버로 보낼 수 있다.</p>\n<blockquote>\n<p>단순히 'Proxy (Server)'라고 말한다면 바로 이 'Forward Proxy'를 의미한다.<br>\n실제로 면접에서 \"프록시와 리버스 프록시\"의 차이에 대해 설명해달라는 요청이 있었다.</p>\n</blockquote>\n<h4>2-1-2. Reverser Proxy</h4>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/0a1b2ae960f491920c5246bb22a4a058/249e2/reverse-proxy.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 35.29411764705882%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABNUlEQVR42p2Ry0rDQBiF80C6ER9CF8UXcOWLuOiiuHDjSttNcSFG1FKUFDFWxYgNdaFBhCIqCrUXTDImzY3MzDGZSMQsFPwXM5zDzOHw/RKS+XAJwihAcRhn4Jz/NAsy1YwyMMaElNKjUlvGtloXxsSbgFKK/44I1HQNHUMTRhiEcIgDm9g4vmlgbA3zxz2jh7XyOsx3knu2aUOu7mB381D8FYGr9Qr2z7fyhnHAcGYoWDqagXrbROzxBEmEk6aK0nQJ/ccnhGGIwA+gn3awMDWPudlFvD73s8DL6wt0765EoOu6IJaDsTlCq7uHkTnI29wbDzjYqIK+6KBfAIlFoMgKWo32d8OVWhlyO2Po+54ATGMKzw6Sm+WBnudj8Db8lbGUcYtgWuafwNONF8NSLy0gtsyBT6muCzMbSXwaAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Reverse Proxy 구조' title='' src='/static/0a1b2ae960f491920c5246bb22a4a058/ca1dc/reverse-proxy.png' srcset='/static/0a1b2ae960f491920c5246bb22a4a058/e7570/reverse-proxy.png 170w,\n/static/0a1b2ae960f491920c5246bb22a4a058/f46e7/reverse-proxy.png 340w,\n/static/0a1b2ae960f491920c5246bb22a4a058/ca1dc/reverse-proxy.png 680w,\n/static/0a1b2ae960f491920c5246bb22a4a058/249e2/reverse-proxy.png 810w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Reverse Proxy 구조</figcaption>\n  </figure></p>\n<p>Forward Proxy와 반대로 클라이언트의 요청이 네트워크를 타고 와서 서버로 도달하기 전, Proxy Server가 해당 요청을 받아 중계 및 전달하는 구조를 가진다.<br>\n즉, WAS 바로 앞에 위치한다.</p>\n<p>서버의 정보를 숨길 수 있으며 포트 포워딩, 로드 밸런싱 등의 역할도 수행할 수 있다.<br>\n흔히 사용하는 Nginx와 Apache Http Server가 Reverse Proxy로 수행될 수 있다.</p>\n<h3>2-2. 게이트웨이</h3>\n<p>다른 서버를 중계하는 역할을 수행한다. 프록시와 매우 유사한 역할이다.<br>\n하지만 게이트웨이는 그 다음에 있는 서버(Origin Server)가 HTTP 서버 이외의 서비스를 제공하는 서버가 된다.<br>\n클라이언트의 요청을 SSL과 같은 암호화하는 등으로 통신의 안정성을 높이는 역할을 수행한다.</p>\n<p>예를 들어 DBMS에 접속하기 전이나 쇼핑 사이트에서 결제 시스템 등과 연계해서 사용할 수 있다.</p>\n<h3>2-3. 터널</h3>\n<p>서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속들 주선한다.</p>\n<p>클라이언트와 서버가 SSL 같은 암호화 통신을 통해 안전하게 통신을 하기 위해 중간에 터널을 통해 통신 경로를 구축한다.<br>\n터널은 HTTP Request를 해석하려고 하지 않고 그대로 서버에 요청을 전달한다.<br>\n그리고 통신하고 있는 양단의 호스트의 접속이 끊어질 때 종료된다.</p>\n<h2>3. 캐싱</h2>\n<p>캐싱은 응답의 결과(리소스)를 중간 어딘가에 사본으로 저장해놓고, 동일한 요청이 있을 때 중간에 저장해놓은 사본을 응답하는 기능이다.<br>\n이를 통해 효율적인 통신이 수행될 수 있다.</p>\n<h3>3-1. 캐싱의 특징</h3>\n<p>네트워크에서 캐싱은 브라우저, CDN, Proxy Server 등과 같이 여러 곳에서 수행될 수 있다.<br>\n브라우저에 저장되는 캐시를 <code class=\"language-text\">Private Cache</code>, Proxy나 CDN과 같은 곳에 저장되는 캐시를 <code class=\"language-text\">Shared Cache</code>로 불린다.<br></p>\n<h3>3-2. 캐싱 정책</h3>\n<p>캐싱 데이터는 <strong>사본</strong>이기 때문에 Origin Server의 리소스가 변경되면 해당 캐싱 데이터는 더이상 사용되면 안되기 때문에 이를 위한 정책을 세우는 것이 중요하다.\n정책을 설정하는데 고려할 요소는 <strong>캐싱 데이터의 리소스 타입</strong>, <strong>캐싱 유효시간</strong>, <strong>버스팅 정책</strong>이 있다.</p>\n<h4>3-2-1. 정적 리소스 캐싱 정책 사례</h4>\n<p>예를 들어, JS, CSS 같은 정적 리소스 파일은 캐싱을 적용하기 좋다.<br>\n하지만 이 둘은 개발이 진행됨에 따라 자주 변경되고, JS와 CSS 버전이 동기화되지 않으면 화면이 깨진다.<br>\n캐싱는 <strong>URL을 기반으로 리소스를 구분하므로 리소스가 업데이트될 때 URL을 변경하면 손쉽게 JS, CSS 파일의 캐싱 데이터를 제거할 수 있다.</strong></p>\n<p>따라서 다음과 같이 캐싱 정책을 세울 수 있다.<br>\n캐시의 Max-Age를 최대치(1년)로 설정하고, <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag\">E-Tag</a>도 적용하며, JS, CSS 리소스에 변경사항이 생기면 캐시 데이터가 무효화되도록 URL에 버전을 적용한다.</p>\n<blockquote>\n<p><code class=\"language-text\">E-Tag</code>는 Http Response Header에 리소스의 특정 버전을 식별하는 식별자의 역할을 한다. 클라이언트는 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag#%EB%B3%80%EA%B2%BD%EB%90%98%EC%A7%80_%EC%95%8A%EC%9D%80_%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%9D%98_%EC%BA%90%EC%8B%B1\"><code class=\"language-text\">If-None-Match</code></a> 헤더를 통해 해당 식별자 값을 전달하여 현재 캐싱하고 있는 데이터의 버전을 전달하고, 서버는 해당 값을 통해 리소스의 버전을 비교할 수 있다.</p>\n</blockquote>\n<h4>3-2-2. WAS 캐싱 정책 사례</h4>\n<p>WAS의 경우 응답을 캐싱하지 않기를 원할 수 있다.<br>\n이때는 Http Response Header에 <code class=\"language-text\">Cache-Control: no-cache, private</code>을 추가하여 <a href=\"https://lalalilala.tistory.com/m/9\">휴리스틱 캐싱</a>을 방지할 수 있다.<br></p>\n<blockquote>\n<p>휴리스틱 캐싱은 브라우저가 임의로 Http Response를 캐싱하는 것을 의미한다.</p>\n</blockquote>\n<h3>Reference</h3>\n<blockquote>\n<ul>\n<li><a href=\"https://m.yes24.com/Goods/Detail/15894097\">그림으로 배우는 Http &#x26; Network Basic</a></li>\n</ul>\n</blockquote>","frontmatter":{"title":"5장. HTTP와 연계하는 웹서버","date":"February 14, 2024","update":null,"tags":["Network"],"series":"그림으로 배우는 Http & Network Basic"},"fields":{"slug":"/05-web-server/","readingTime":{"minutes":8.325}}},"seriesList":{"edges":[{"node":{"id":"a4d71417-67f6-5df5-a92a-fe77cee2c152","fields":{"slug":"/01-comprehension-about-web-and-network-basic/"},"frontmatter":{"title":"1장. 웹과 네트워크의 기본에 대해 알아보자"}}},{"node":{"id":"b30f24d3-925d-5fec-8b29-6f6226b97cd6","fields":{"slug":"/02-http-protocol/"},"frontmatter":{"title":"2장. 간단한 프로토콜 HTTP"}}},{"node":{"id":"807f22e3-dcd4-554f-908e-19ffa9b29d8c","fields":{"slug":"/03-http-detail/"},"frontmatter":{"title":"3장. HTTP 정보는 HTTP 메시지에 있다"}}},{"node":{"id":"bd0818e6-a370-5bc9-96d5-ad7d10929267","fields":{"slug":"/04-http-status-code/"},"frontmatter":{"title":"4장. 결과를 전달하는 HTTP 상태 코드"}}},{"node":{"id":"e210085d-c6e8-5cce-81f0-c7773af272fa","fields":{"slug":"/05-web-server/"},"frontmatter":{"title":"5장. HTTP와 연계하는 웹서버"}}},{"node":{"id":"5b14ad06-606e-5537-be91-65ab1aa467e5","fields":{"slug":"/06-http-header/"},"frontmatter":{"title":"6장. HTTP 헤더"}}},{"node":{"id":"84076d04-c12f-5e3f-889d-67a2bc4a604f","fields":{"slug":"/07-https/"},"frontmatter":{"title":"7장. 웹을 안전하게 지켜주는 HTTPS"}}}]},"previous":{"fields":{"slug":"/1-2-weeks/"},"frontmatter":{"title":"[ListyWave] 1, 2주차 회고"}},"next":{"fields":{"slug":"/who-and-how-manage-category/"},"frontmatter":{"title":"[ListyWave] SNS 서비스에서 카테고리를 관리하는 방법"}}},"pageContext":{"id":"e210085d-c6e8-5cce-81f0-c7773af272fa","series":"그림으로 배우는 Http & Network Basic","previousPostId":"3ca6b0c8-4f6e-535a-a4b2-ab89fe5b8004","nextPostId":"f4eff4de-0fd4-5ff2-aaa1-b78ceda19bc0"}},"staticQueryHashes":[],"slicesMap":{}}