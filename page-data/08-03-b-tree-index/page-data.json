{"componentChunkName":"component---src-templates-post-jsx","path":"/08-03-b-tree-index/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"0a33b9d9-8548-50e3-a895-0d1011aec7b1","excerpt":"B-Tree 인덱스 B-Tree 인덱스는 데이터베이스의 인덱싱 알고리즘에서 가장 일반적으로 사용되는 알고리즘이다. 가장 큰 특징은 칼럼의 원래 값을 변형하지 않고 인덱스 자료구조 내에서는 항상 정렬된 상태로 값들을 저장한다. 흔히 B-Tree를 Binary-Tree (이진 트리)로 생각한다. 하지만 Balanced-Tree의 약자로, Binary-Tree…","html":"<h2>B-Tree 인덱스</h2>\n<p>B-Tree 인덱스는 <u>데이터베이스의 인덱싱 알고리즘에서 가장 일반적으로 사용되는 알고리즘</u>이다.</p>\n<p>가장 큰 특징은 <u>칼럼의 원래 값을 변형하지 않고</u> 인덱스 자료구조 내에서는 <u>항상 정렬된 상태로 값들을 저장</u>한다.</p>\n<p>흔히 B-Tree를 Binary-Tree (이진 트리)로 생각한다. 하지만 Balanced-Tree의 약자로, Binary-Tree는 아니다.<br>\nBalanced-Tree는 균형잡힌 트리로, 노드가 한 쪽 방향으로 치우치지 않고 왼쪽 위부터 차곡차곡 쌓인다고 생각하면 된다.</p>\n<p>결국, <u>B-Tree 인덱스는 Balanced-Tree 자료구조를 이용한 인덱싱 알고리즘</u>이다.</p>\n<blockquote>\n<p><a href=\"https://www.baeldung.com/cs/balanced-trees\">Balacned Tree - Baeldung</a></p>\n</blockquote>\n<h3>1. B-Tree의 구조 및 특성</h3>\n<h4>구조</h4>\n<p>B-Tree를 이해하기 위해 B-Tree의 구조에 대해 알아보자.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/6b159fc7faa72f2a8538267147279524/4d915/b-tree-architecure.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 51.17647058823529%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABRklEQVR42q2Sy0oDUQyGv2mnV2yr9mJRrLjTUgR3Ln0at+K1Dl3MM7j0FfoSbhW8YQVF3Cj4GhOTw0wZbVUEAyEkh/z5T/7ATxaKj4incYbjaIu+1BjIisZNreX5zc7Bv4UlgQxnkuNE6q4xlIx62w04jQrs6JvVLO5J6VvAdyjfQe8NSjHDzLg5lBaBbCi7bY1rrhZIT2NnKpiyyj5A9wKqI1i/gpx7OJKKNhXZlwaHyvJAgcOoGg8sa6c3FdAAFLBtwE/QCO3b/2EyAeQYeF/yaZ0TdU/BPBPmM8AfzQCeoZBmqF/PJ0yHuoJHqEh6iAli6iYK2453ZdZdxiXUb6CZKKsqt17UbY+W38OCDmxabQzYV2XtFgPpunwgq055u1M7k1eYU2WXY3Yd9XkbYswtV8Fq17CYYlh0Sttd4g7fZyhZe/sA92aCFvoX8/wAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='B-Tree의 구조' title='' src='/static/6b159fc7faa72f2a8538267147279524/ca1dc/b-tree-architecure.png' srcset='/static/6b159fc7faa72f2a8538267147279524/e7570/b-tree-architecure.png 170w,\n/static/6b159fc7faa72f2a8538267147279524/f46e7/b-tree-architecure.png 340w,\n/static/6b159fc7faa72f2a8538267147279524/ca1dc/b-tree-architecure.png 680w,\n/static/6b159fc7faa72f2a8538267147279524/02d09/b-tree-architecure.png 1020w,\n/static/6b159fc7faa72f2a8538267147279524/9d567/b-tree-architecure.png 1360w,\n/static/6b159fc7faa72f2a8538267147279524/4d915/b-tree-architecure.png 1955w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>B-Tree의 구조</figcaption>\n  </figure></p>\n<p>Tree의 구조를 기본적으로 가진다.</p>\n<p>맨 위에는 1개의 <code class=\"language-text\">루트 노드</code>가 있다.<br>\n맨 아래에는 여러 개의 <code class=\"language-text\">리프 노드</code>가 있다.<br>\n루트 노드와 리프 노드 가운데는 <code class=\"language-text\">브랜치 노드</code>라고 한다.</p>\n<p>데이터베이스에서 실제 데이터와 인덱스는 따로 관리되는데, <u>리프 노드는 항상 실제 데이터를 찾아가기 위한 주소값을 가진다.</u></p>\n<p>여기서 <code class=\"language-text\">Balanced</code> 라는 이름에 걸맞게 노드가 한 쪽으로만 치우치지 않는다.<br>\n예를 들어 다음과 같은 형태이다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/25af7/not-balanced-tree.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 62.35294117647059%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWklEQVR42q1TS0oDQRB9k5/RGD9R/MTEjSAIbhwQQTELjyB4hexcRNEkGpgDiAfIFXIJN24FRVduBA8y5atKph1IbFAsKKqrP69fd70CfNaVXdzKIc4ky7jF/Ji+OlyUDD0YO/MBLDwAOUtaMo1IqojiOcvbsolevGOA91y7lJK5z16AhoLquNb6VMCcWxQy6Ese57zgRjbQkSUMCH5nwCvMt21P2t6ANYLWBkDWTUZSRFNmGAt84hGZNtCNTxlPjH1b5nlBSF+3C9ImQPAMHDwBVTd5JWWCVeyPNDbJUj3iv6kPTwYTn6zMyLLCfyzi1/YDaMJU3LN1Y7LZc8gHlkSteJL/C9sEdJQGf3ruJHsHph6B8tiCykgrHVEF3wWcNcGL55I+kH8F6mSccZMdWaTvoyd7BAptTqWjErpmA/hErwWiPkNKqpTSZ4EtWMeFLLtu0kbQDhsV8gv0n5AgE+6srQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='균형잡히지 않은 Tree' title='' src='/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/ca1dc/not-balanced-tree.png' srcset='/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/e7570/not-balanced-tree.png 170w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/f46e7/not-balanced-tree.png 340w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/ca1dc/not-balanced-tree.png 680w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/02d09/not-balanced-tree.png 1020w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/9d567/not-balanced-tree.png 1360w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/25af7/not-balanced-tree.png 1608w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>균형잡히지 않은 Tree</figcaption>\n  </figure></p>\n<h4>특성</h4>\n<p>가장 중요한 특성은 <u>노드들을 정렬된 상태로 저장한다는 것이다.</u><br>\n이러한 특성 때문에 조회를 빠른 속도로 처리할 수 있게 된다.<br>\n하지만 반대로 말해 인덱스에 값을 추가하거나 삭제하는 경우 정렬을 맞춰야하므로 오버헤드가 발생하게 된다.</p>\n<p>그리고 또 하나의 중요한 특성은 <u>인덱스의 리프 노드는 실제 데이터의 PK 값을 가진다.</u><br>\n인덱스를 통해 빠르게 원하는 값을 찾아도, 원하는 값이 없는 경우 실제 데이터를 조회해야 한다.<br>\n이를 위해 실제 데이터의 주소값을 가져야하는데 기본키를 주소값으로 대신하여 사용하게 된다.</p>\n<p>마지막으로 B-Tree의 중요한 특징은, <u>모든 세켄더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK 인덱스를 거쳐야 한다.</u><br>\n이에 대한 자세한 내용은 8.8절에서 자세히 알아보자.</p>\n<h3>2. B-Tree 인덱스 CRUD: 인덱스 쓰기 작업과 조회 작업</h3>\n<p>위에서 언급했듯이 B-Tree는 값 쓰기 성능을 희생해서 조회 성능을 높인다.<br>\n쓰기 성능이 어떤 이유에서 희생되는지 알아보자.</p>\n<p>참고로 InnoDB에서는 B-Tree 쓰기 작업을 모두 <code class=\"language-text\">체인지 버퍼</code>를 활용해 지연처리 될 수 있다.<br>\n이를 통해 다른 스토리지 엔진보다는 좋은 성능을 낳을 수 있다.</p>\n<h4>인덱스 추가</h4>\n<p>새로운 키 값이 B-Tree에 저장될 때 즉시 저장될 수도 있고 아닐 수도 있다.\n하지만 PK나 Unique Index의 경우 중복 체크가 필요하기 때문에 즉시 삽입하게 된다.<br></p>\n<p>저장될 때 값이 저장될 적절한 위치를 검색해야 한다. 위치가 결정되면 레코드의 PK 값과 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.</p>\n<p>만약 들어갈 위치가 없다면, <code class=\"language-text\">페이지</code>를 분리해서 들어갈 공간을 만들어야 한다.<br>\n이러한 과정들이 포함되다보니 쓰기 작업은 오버헤드가 발생하게 되는 것이다.</p>\n<h4>인덱스 삭제</h4>\n<p>삭제의 경우 추가보다 단순하다.<br>\nB-Tree의 리프 노드를 찾아 그냥 삭제 마킹만 하면 끝이다.<br>\n이렇게 마킹된 인덱스의 공간은 계속 방치되거나 재활용될 수 있다.<br>\n하지만 마킹 작업 또한 디스크 쓰기가 필요하므로 오버헤드가 발생한다.</p>\n<h4>인덱스 변경</h4>\n<p>단순히 값을 변경하지 않는다.<br>\n인덱스 삭제가 먼저 이루어지고 인덱스 키 추가 작업이 이루어진다.<br>\n때문에 가장 많은 오버헤드를 발생시키는 작업이 된다.</p>\n<h4>인덱스 조회</h4>\n<p>B-Tree 인덱스를 조회하는 조건에 대해 알아보자.</p>\n<p>우선 인덱스 조회는 <code class=\"language-text\">SELECT</code> 뿐만 아니라 <code class=\"language-text\">UPDATE</code>나 <code class=\"language-text\">DELETE</code>를 처리하기 위해 레코드를 검색하는 경우에도 사용된다.<br>\n중요한 점은 <u>검색은 100% 일치하거나 값의 앞부분만 일치하는 경우에만 사용될 수 있다.</u><br>\n다시 말해, <u>집계 함수나 연산을 수행한 결과로 검색하는 쿼리는 인덱스를 통해 조회가 이뤄지지 않는다.</u></p>\n<p>지금까지 B-Tree 인덱스의 CRUD에 대해 살펴봤다.<br>\n기본적으로 조회 성능을 끌어올리기 위해 인덱스의 중요성을 많이 언급하지만, InnoDB 엔진의 경우 <em>레코드 락</em>이나 <em>넥스트 키 락</em>이 조회를 수행한 인덱스를 잠근 후 테이블의 레코드도 잠그는 방식으로 구현되어 있기 때문에 <code class=\"language-text\">UPDATE</code>나 <code class=\"language-text\">DELETE</code> 쿼리를 처리할 때도 적절한 인덱스가 없다면 상당한 성능 이슈를 야기할 수 있다.</p>\n<h3>3. B-Tree 인덱스 사용에 영향을 미치는 요소</h3>\n<p>그렇다면 이 B-Tree 인덱스를 어떤 기준을 가지고 설정하면 좋을까?<br>\n여기에는 두 가지 기준이 있다.</p>\n<h4>3-1. 인덱스 키 값의 크기</h4>\n<p>MySQL은 디스크에 데이터를 저장하는 가장 작은 기본 단위를 <u>페이지</u>라고 한다.<br>\n이 페이지는 InnoDB 버퍼 풀에도 적용되며 <u>모든 작업의 최소 단위</u>가 된다.\n인덱스도 결국 이 페이지 단위로 관리된다.<br>\n참고로 default 값은 16KB이다.</p>\n<p>그렇다면 인덱스 키 값의 크기가 이와 무슨 관련이 있을까?<br>\n조금만 생각해보면 쉽게 알아차릴 수 있다.</p>\n<p>인덱스 키 값이 크기가 늘어나면, 하나의 페이지에서 저장할 수 있는 인덱스는 줄어든다.<br>\n하나의 페이지에서 저장할 수 있는 인덱스가 줄어들면, 그만큼 페이지를 더 많이 만들어야 한다.<br>\n페이지가 늘어날 수록 한 페이지에서 조회할 수 있는 레코드의 수가 적으므로 더 많은 페이지를 뒤져야 한다.</p>\n<p>결국, <u>인덱스 키 값의 크기가 작을 수록 인덱스를 이용한 조회 성능이 향상된다.</u></p>\n<h4>3-2. Cardinality</h4>\n<p>또 다른 기준으로 <em>Cardinality</em>가 있다.<br>\n<u>Cardinality는 하나의 칼럼을 기준으로 유니크한 값의 수</u>를 의미한다.</p>\n<p>결론부터 말하자면 Cardinality가 높은, 즉 중복도가 낮은 칼럼을 인덱스로 설정하는 것이 좋다.</p>\n<p>중복도가 높은 칼럼을 인덱스로 설정했다면 그만큼의 값을 다 찾아야 한다.<br>\n만약 1000개의 값이 중복되었고 그 중 한 개의 레코드를 조회하는 쿼리라면, 인덱스를 이용할 때 999개의 레코드에 Lock이 걸리고 결과적으론 1개의 레코드만 반환될 것이다.</p>\n<p>그렇지만 Cardinality가 낮다고 해도 <u>정렬이나 그룹핑과 같은 작업을 위해 인덱스를 만드는 경우가 훨씬 나은 경우도 많다.</u></p>\n<h3>4. B-Tree 인덱스를 통한 데이터 읽기</h3>\n<p>B-Tree 인덱스를 이용해 데이터를 조회하는 대표적인 세 가지 방식에 대해 알아보자.</p>\n<h4>4-1. 인덱스 레인지 스캔</h4>\n<p>인덱스 접근 방식 중 대표적인 방식이다.<br>\n뒤에 나올 두 가지 접근 방식 (인덱스 풀 스캔, 루스 인덱스 스캔) 보다 빠른 방식이다.<br>\n실행 계획을 봤는데 인덱스 레인지 스캔이 나온다면 잘 사용하고 있다고 이해하면 된다.</p>\n<p>인덱스 레인지 스캔은 <u>검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.</u><br>\n기본적으로 값이 크기 순으로 정렬되어 있는 B-Tree에서, 찾고자 하는 값의 범위를 지정해 순차대로 조회하는 단순한 방식이다.</p>\n<p>하지만 간과하기 쉬운 부분이 있다.<br>\n인덱스에서는 단순하고 빠르게 조회를 하더라도 각 인덱스 레코드를 통해 실제 디스크에 저장된 레코드에 접근하는 것은 랜덤 디스크 I/O 작업이라는 것이다.<br>\n그래서 옵티마이저가 적절히 판단해서 선택하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'Handler_%'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 쿼리를 통해 인덱스 레인지 스캔이 얼만큼 수행됐는지 확인할 수 있다.<br>\n자세한 내용은 <a href=\"https://www.manty.co.kr/bbs/detail/develop?id=100\">링크</a> 참고</p>\n<h4>4-2. 인덱스 풀 스캔</h4>\n<p>인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 <u>인덱스의 처음부터 끝까지 모두 읽는 방식이다.</u><br>\n대표적으로 <u>&#x3C;쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 사용</u>된다.<br>\n예를 들어 인덱스는 <code class=\"language-text\">(A, B, C)</code> 칼럼 순으로 만들어져있지만 <code class=\"language-text\">WHERE</code> 절에서 <code class=\"language-text\">B</code> 칼럼이나 <code class=\"language-text\">C</code> 칼럼으로 검색하는 경우다.</p>\n<p>\"이럴바엔 테이블 풀 스캔이 낫지 않나요?\" 할 수 있지만 일반적으로 인덱스의 크기는 테이블 크기보다 작으므로 상대적으로 효율적이다.<br>\n다만 <u>쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 사용된다.</u> (커버링 인덱스)</p>\n<p>그다지 효율적인 방식은 아니며, <u>일반적으로 인덱스를 잘 활용하지 못하는 경우다.</u></p>\n<h4>4-3. 루스 인덱스 스캔</h4>\n<p>루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 작동한다. 하지만 중간에 필요없는 인덱스는 무시하고 다음으로 넘어가는 형태를 취한다.<br>\n일반적으로 <u><code class=\"language-text\">GROUP BY</code> 또는 집계 함수 중, <code class=\"language-text\">MAX()</code> 또는 <code class=\"language-text\">MIN()</code> 함수에 대해 최적화하는 경우 사용된다.</u><br>\n해당 방식을 사용하려면 여러 조건을 만족해야 하는데, 이는 10장 실행 계획에서 자세히 알아보자.</p>\n<h4>4-5. 인덱스 스킵 스캔</h4>\n<p>해당 방식은 인덱스 풀 스캔 방식을 개선하기 위해 등장했다.<br>\n만약 인덱스가 <code class=\"language-text\">(A, B)</code> 순으로 생성되었지만 조건절에 <code class=\"language-text\">(B)</code>를 통해 조회하는 경우, 우선 A에서 <u>유니크한 값들을 모두 조회해서 주어진 조건에 조회한 칼럼을 추가해서 쿼리를 다시 실행하는 형태로 동작한다.</u><br></p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/dbb380e1c1b59a6404ad1cdeabe83a97/ec55d/index-skip-scan.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 88.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAADoElEQVR42nWU+1MaVxTH/X/7W39sm2k6JpoxTklSik+qUgsqjxBBUFGeRkEiAYOiKISoKCBPkYVddvn23LtAnM50Z76zDw6fe88533NHer0eFEWC0hNJEnpgkocCFMj0e/OxgQdSpVFGpV7GfbWE2mMdD8IDOt0Our0u14gK7JJE+iBxiRQwkCSLEEmZuxwyhSt8Tn9B9DSOcCJK374hd59HrVWH3JPRJc4IbQGVWgX+SACBwxACkSA+ncTw5eIEcdJlPsuDLR4HJpe0mFz8E2PTGmiWZjBlMcDgMKNUr7A8+MJD4EHiEOHjT6QoYqljRJNxBOMRnObSLAT+2AHWdp0wedZhdL/H4oc1mNx22H1bqDbrPN1OV1RTlmUZbUGAQGoJbfXeFlCuVRE7jsNit2FmSY+/TMt4Nz+Nt/ppuIM+SreEUPwI3r0AX5TvsNdTwKD/vQbfHlstpC7O4fRuw7G7BevWBn6dGIPZtY5rymxzfw8L/xh4bJtqTkAqpizxTrEti/QsUVfZah25w+vH0InsOSKpJPaSCUzOaGFxO5C8+gpnyI9ls4kDBUlQgcwWYh/CpahQVhd2pxywuuPEq0VqyvIsfvjpR7zQvcbcuhHjc29hMP2tAsUhUP2j9AQ6eB8AdyIfseKyY2XLiV/GRzFl0MMX3ceC2YjZhXkO7AxSHoKGqaqpswByKW4KeUxOvYNucQ6/z+rw8s1rBKNh3FHTIok4vNSgJ02RaULkvtP7d77jLoeyK5k6warDhoubK4RiEVKUjB1DrnCHNNWx0XogF3b5EHAfCp02itV7FColFKqqiqR86RaNZgNn6XMYrEb44mHYdjdgclpgI6P7jj4iENtHmcaRA5WOCrwu3lGAC+9Jdu8m9misDpMxHJ5+xlUxj0w2g1HNGMbnNfjtj3E804zi+ZtRvJqewOyangOVp0C+i+wlznMZnH1lukQqm0bk+AipyzP4gwFo57XYPvDDuG7GqssKV2AbURrRIE3QDS2qgNW/PTC2Qk5WmJ37ojNGodmU2pCkDm5u89DqdZgzLtCk6PDzy2dYodG7rhaxEw7B+sHa73Kr3xRqgEwNYMcY86T63OVwSRLhI/NaNqywshk2L+P5xAuYnTZkqcYOv4d8qE6KKPWB36Xg6Ts7C0UCerwe2N02bPnccHtd2AxsIp5O4tv9LTz7/v8DqjOt6vsz2yV7b4uPlJLAJXSa/HCtNWso10uoN6oUw7IT8S/jUAyBRDeFIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='인덱스 스킵 스캔 동작 방식' title='' src='/static/dbb380e1c1b59a6404ad1cdeabe83a97/ca1dc/index-skip-scan.png' srcset='/static/dbb380e1c1b59a6404ad1cdeabe83a97/e7570/index-skip-scan.png 170w,\n/static/dbb380e1c1b59a6404ad1cdeabe83a97/f46e7/index-skip-scan.png 340w,\n/static/dbb380e1c1b59a6404ad1cdeabe83a97/ca1dc/index-skip-scan.png 680w,\n/static/dbb380e1c1b59a6404ad1cdeabe83a97/02d09/index-skip-scan.png 1020w,\n/static/dbb380e1c1b59a6404ad1cdeabe83a97/ec55d/index-skip-scan.png 1124w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>인덱스 스킵 스캔 동작 방식</figcaption>\n  </figure></p>\n<p>하지만 조회 비용과 관련해 다음과 같은 전제 조건이 필요하다.</p>\n<ul>\n<li>WHERE 절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 한다.</li>\n<li>쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능하다. (커버링 인덱스)</li>\n</ul>\n<h3>5. B-Tree 인덱스의 정렬 및 스캔 방향</h3>\n<p>인덱스의 키 값을 정렬하고 스캔하는 방향에 대한 내용이다.<br>\n정렬은 내림차순, 오름차순 모두 가능하며 스캔 또한 정순과 역순 모두 가능하다.<br></p>\n<p>각 쿼리에 따라 내림차순이냐 오름차순이냐가 성능에 영향을 미칠 수 있다.<br></p>\n<p>중요한 점은 <u>인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다는 것이다.</u></p>\n<h3>6. B-Tree 인덱스의 가용성과 효율성</h3>\n<p>쿼리의 <code class=\"language-text\">WHERE</code> 절이나 <code class=\"language-text\">GROUP BY</code> 또는 <code class=\"language-text\">ORDER BY</code> 절이 어떤 경우에 인덱스를 사용하며 어떤 방식으로 조회하는지 식별할 수 있어야 한다.<br>\n이번에는 이에 대해 알아보자.</p>\n<h4>6-1. 비교 조건의 종류와 효율성</h4>\n<p>다중 칼럼 인덱스에서 각 <u>칼럼의 순서와 그 칼럼에 적용된 조건이 동등 비교인지 아니면 대소 비교 같은 범위 조건인지에 따라 인덱스 활용 형태가 달라진다.</u></p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/43bd2197855fc3a99dad906605e8361e/7ca0a/example-1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 52.94117647058824%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACRUlEQVR42m2T62/SUBjG+b9d/KRmRN0ConMXJZJtXmLYxWSwm3OAUBi7gJiM6AbMUhgtLS29QEv7+PYgbB9s8+Rtzjnv7zxPexoYDk3ohgzDVJhGrgnH8cckaLpEYzKsgUa1T9Jpzoau6xBFEZZlodfrQdNo3jDgX4GW2MA3bhdHuV2UqnkGNK0euPIxEsfbKPzIgBeuUSyeoF6vo9vtotlsotPpMPE8z2qr1RoDf1ZLWIiFsbj2EluHcQJa6JPj9e0YIrEQ3m1E0Zaa5EIhZxoB/kCgZt+VIAgMJssyVFUdA3mhhuIFh4vKGU7KBdgjk+yr4M6zKJTzyJc4qLpCSz26XUiSSM0ai+3HlCQJtm0zmOu6CGQLGSy8eYGPW+tIn6XJ4QDtWx7Lq0tYWV1EMrNHwJ6/nOYceJ7HGv3qawKajAV+16p4v7mOyHIImVIWQ8egjyEjmU5ifnEeO6kkVKNHsCFsx6JqM7kEH4Oc6TMDVmuXCL0N4+HsDOIHm9Rk0DtUsEqbPHgyg5VPUSh9hTkZuSPm0vUmkNE9/QMe59IIRp7h+es5JL/v07EYwKTjkUjtYW4phA87cYiyiNxpDlf1XwzsEcDzfN1FnyjAFTmsfV5D4msC6ZM07WRD6oqIRF/hcXgWj0JBxL9sIBh+ioPUPgPajj12es/ZFNjpdtDga6g1rklXdFhN3HbaODzaR/G8gMplBYal46Z5A6HdHEcf3cWcAKeRFUVGv69B1VR2lhRFYVXX++xPYBHvRRvD3P/KB/4F4dYknF7nRUEAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='example 1' title='' src='/static/43bd2197855fc3a99dad906605e8361e/ca1dc/example-1.png' srcset='/static/43bd2197855fc3a99dad906605e8361e/e7570/example-1.png 170w,\n/static/43bd2197855fc3a99dad906605e8361e/f46e7/example-1.png 340w,\n/static/43bd2197855fc3a99dad906605e8361e/ca1dc/example-1.png 680w,\n/static/43bd2197855fc3a99dad906605e8361e/02d09/example-1.png 1020w,\n/static/43bd2197855fc3a99dad906605e8361e/9d567/example-1.png 1360w,\n/static/43bd2197855fc3a99dad906605e8361e/7ca0a/example-1.png 1879w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>여기서 눈여겨 볼 것은 dept<em>no는 <code class=\"language-text\">=</code> 검색이고 emp</em>no는 <code class=\"language-text\">>=</code> 비교이다.<br>\n이때 인덱스 칼럼의 순서가 <code class=\"language-text\">(dept_no, emp_no)</code> 이냐 <code class=\"language-text\">(emp_no, dept_no)</code>에 따라 인덱스를 조회하는 방식이 달라진다.</p>\n<p>범위 조건 비교 (<code class=\"language-text\">>=</code>) 보다 동등 조건 비교 (<code class=\"language-text\">=</code>)가 값을 조회하기엔 더 최적화된 조건이므로, dept_no 칼럼이 선행된 인덱스의 경우 더 효율적으로 조회할 수 있는 것이다.</p>\n<h4>6-2. 인덱스의 가용성</h4>\n<p>만약 인덱스 칼럼의 순서가 <code class=\"language-text\">(dept_no, emp_no)</code>인 인덱스에 <code class=\"language-text\">WHERE</code> 절에 <code class=\"language-text\">emp_no</code>만 있는 쿼리를 날린다면, 인덱스 칼럼의 선행 조건인 <code class=\"language-text\">dept_no</code>를 이용하지 못하므로 인덱스를 효율적으로 사용할 수 없다.</p>\n<h4>6-3. 가용성과 효율성 판단</h4>\n<p>B-Tree 인덱스는 특성상 다음 조건에서는 사용할 수 없다. (필터링 작업을 통해 사용하는 경우는 있다.)</p>\n<ul>\n<li>Not Equal로 비교된 경우</li>\n<li><code class=\"language-text\">LIKE '%??'</code> 처럼 <u>앞부분이 잘린 형태로 검색하는 경우</u></li>\n<li>스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 경우</li>\n<li>NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우</li>\n<li>데이터 타입이 서로 다른 비교를 하는 경우 (인덱스 칼럼의 타입을 변환해야 하므로 X)</li>\n<li>문자열 데이터 타입의 콜레이션이 다른 경우</li>\n</ul>","frontmatter":{"title":"B-Tree 인덱스에 대해 알아보자","date":"February 01, 2024","update":null,"tags":["database"],"series":"Real MySQL 8.0"},"fields":{"slug":"/08-03-b-tree-index/","readingTime":{"minutes":18.285}}},"seriesList":{"edges":[{"node":{"id":"014bd317-3394-5c4d-9a72-e1319712838a","fields":{"slug":"/03-user-identification/"},"frontmatter":{"title":"MySQL에서의 사용자 식별에 대해"}}},{"node":{"id":"69b6441a-edde-5385-b6a3-0df3608f6657","fields":{"slug":"/04-mysql-engine-architecture/"},"frontmatter":{"title":"MySQL 엔진 아키텍처"}}},{"node":{"id":"cf713bbe-9c34-54b6-9d8b-9f1b1f12ebfe","fields":{"slug":"/04-innodb-engine/"},"frontmatter":{"title":"InnoDB 엔진 이해하기"}}},{"node":{"id":"f21b2f2c-8b87-52fe-965b-01011033f9f5","fields":{"slug":"/04-mysql-log/"},"frontmatter":{"title":"MySQL 로그 파일"}}},{"node":{"id":"076df81f-9afd-5dfe-bc33-fff6402d1ddc","fields":{"slug":"/05-transaction-and-lock/"},"frontmatter":{"title":"MySQL에서의 트랜잭션과 Lock"}}},{"node":{"id":"48bcea91-2f18-5443-9881-eb4e2cdd272f","fields":{"slug":"/05-lock-of-innodb-storage-engine/"},"frontmatter":{"title":"InnoDB 스토리지 엔진의 락"}}},{"node":{"id":"c1af5fc8-26e9-523f-ab94-cd74c7a9f8b5","fields":{"slug":"/05-isolation-level-of-MySQL/"},"frontmatter":{"title":"MySQL의 격리 수준"}}},{"node":{"id":"0a33b9d9-8548-50e3-a895-0d1011aec7b1","fields":{"slug":"/08-03-b-tree-index/"},"frontmatter":{"title":"B-Tree 인덱스에 대해 알아보자"}}},{"node":{"id":"94032e77-bdeb-5604-be4a-7b868b61f76d","fields":{"slug":"/10-execute-plain/"},"frontmatter":{"title":"MySQL의 실행 계획에 대해 알아보자"}}}]},"previous":{"fields":{"slug":"/04-http-status-code/"},"frontmatter":{"title":"4장. 결과를 전달하는 HTTP 상태 코드"}},"next":{"fields":{"slug":"/1-2-weeks/"},"frontmatter":{"title":"[ListyWave] 1, 2주차 회고"}}},"pageContext":{"id":"0a33b9d9-8548-50e3-a895-0d1011aec7b1","series":"Real MySQL 8.0","previousPostId":"bd0818e6-a370-5bc9-96d5-ad7d10929267","nextPostId":"3ca6b0c8-4f6e-535a-a4b2-ab89fe5b8004"}},"staticQueryHashes":[],"slicesMap":{}}