{"componentChunkName":"component---src-templates-post-jsx","path":"/os-interview-study-5week/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"fa7523ff-1ef3-530d-a49b-3cc2cd88ac17","excerpt":"이화여대 강의 정리 가상 주소와 물리 주소(실주소)에 대해 설명해주세요. 가상 주소를 물리 주소(실주소)로 어떻게 변환할까요? 절대 주소 지정과 상대 주소 지정의 차이점은 뭘까요? 메모리 분할에 대해 설명해주세요. 메모리 배치 기법(메모리 관리 전략)에 대해 설명해주세요. 외부 단편화와 내부 단편화의 차이가 뭔가요? 메모리 배치 기법중 하나인 colaes…","html":"<h2>이화여대 강의 정리</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">프로세스가 메모리에 적재될 때, 메모리의 어느 위치에 적재할 지에 대한 방법(주소 바인딩)이 3가지 있다.\n\n1. Compile Time Binding\n프로세스의 가상 주소를 실제 주소로 그대로 사용한다.\n이는 프로세스 2개 이상을 동시에 메모리에 적재하기에 위험성이 있다.\n컴파일러는 절대 코드(Absolute Code)를 생성한 경우 사용되는 방법이다.\n\n2. Load Time Binding\n프로세스가 메모리에 적재될 때(Load time) 무작위로 적재가 되고, 변경되지 않는다.\n컴파일러는 재배치가능코드(Relocatable Code)를 생성한 경우 가능한 방법이다.\n\n3. Run Time Binding\n프로세스가 메모리에 적재될 때 무작위로 적재되지만, 동적으로 변경이 가능하다.\n현 시대에 흔히 사용되는 방법이다.</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">프로그래밍 언어로 변수나 메서드를 선언한다.\n그리고 컴파일하면 실행 파일(프로그램)이 생성된다.\n이 프로그램은 자체적으로 0번지부터 시작하는 메모리 주소가 있다.\n컴파일러가 이 실행 파일을 만들 때 알아서 메모리를 할당한다.\n\n프로그램이 실행되어 프로세스가 되어도 자체적인 주소 공간을 사용한다.\n이를 가상 주소라고 한다.\n실제 주소는 실제 메모리의 주소 공간을 의미한다.\n\nCPU는 PCB에 있는 Program Counter가 가리키는 주소를 바라본다.\n이때 PC가 가리키는 주소는 가상 주소이다.\n(왜? 물리 주소는 항상 바뀔 수 있고, 잘못하면 다른 프로세스의 명령어를 실행한다. 논리주소는 바뀌지 않고 매번 동일한 곳을 가리키기 때문)\n\n따라서 이 가상 주소를 통해 실제 주소를 가리키려면 변환 과정이 필요하다.\n\n이는 MMU(Memory Management Unit)라는 하드웨어에 의해 실행된다.\n(왜 운영체제가 아닌 하드웨어? 빠른 속도로 메모리에 접근해야한다. 그런데 운영체제에 의해 관리되면 오버헤드가 발생한다.)\n\n(연속 할당에서의) MMU는 논리 주소를 relocation register와 limit register를 통해 물리 주소로 변환한다.\nrelocation register는 실행하려는 프로세스의 물리적 주소의 시작 위치를 가리킨다.\nlimit register는 실행하려는 프로세스가 가지는 주소의 전체 범위를 가진다.\n따라서 논리주소 + relocation register의 값 = 물리 주소가 된다.\n이떄, limit register는 해당 프로세스가 가지는 물리적 주소의 범위를 벗어나서 명령을 실행하는 경우를 막기 위해 존재한다. </code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Dynamic Loading]\n프로세스 전체의 메모리 공간을 실제 메모리 영역에 적재하지 않고, 해당 메모리 공간이 필요로 할 때 메모리에 적재하는 것을 의미한다.\n\n[Swapping]\n메모리에 적재되어 있는 프로세스의 일부 페이지를 디스크로 쫓아내는 것을 의미한다.</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Allocation of Physical Memory]\n1. 연속 할당\n하나의 프로세스가 메모리에 적재될 때, 통채로 올라가는 것을 의미한다.\n\n2. 불연속 할당\n하나의 프로세스에 대해서도 페이징 단위로 나누어 메모리에 적재하는 것을 의미한다.\n더군다나 같은 프로세스의 페이지라고 해도 메인메모리 상에서 연속적이지 않다.\n\n2-1. 페이징 기법\n프로세스의 논리 주소를 동일한 사이즈의 페이지로 나눈다.\n일부 페이지는 스왑 메모리에, 일부 페이지는 메인 메모리에 저장한다.\n주소 변환은 '페이지 테이블'을 통해 이뤄진다.</code></pre></div>\n<hr>\n<h2>가상 주소와 물리 주소(실주소)에 대해 설명해주세요.</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">가상 주소의 경우 프로세스마다 독립적으로 가지는 주소 공간입니다. 모두 0번지부터 시작합니다.\n물리 주소의 경우 프로세스가 실제 메모리에 올라가는 위치입니다.</code></pre></div>\n<h2>가상 주소를 물리 주소(실주소)로 어떻게 변환할까요?</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">MMU라는 하드웨어에 의해 변환됩니다.\nMMU에는 프로세스의 물리적 주소의 시작 위치를 가리키는 relocatation 레지스터가 있는데,\nCPU가 가리키는 논리 주소에 이 relocation 레지스터의 값을 더하면, 원하는 곳의 물리 주소를 구할 수 있습니다.</code></pre></div>\n<h2>절대 주소 지정과 상대 주소 지정의 차이점은 뭘까요?</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">절대 주소 지정은 컴파일러에 의해 만들어진 논리 주소가, 실제 메모리에 적재될 때 그대로 사용되어 적재되는 것을 의미합니다.\n상대 주소 지정은 이 논리 주소와는 상관없이 메모리에 적재될 때, 그리고 적재된 이후에 동적으로 물리 주소를 할당하는 것을 의미합니다.</code></pre></div>\n<h2>메모리 분할에 대해 설명해주세요.</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<h2>메모리 배치 기법(메모리 관리 전략)에 대해 설명해주세요.</h2>\n<h2>외부 단편화와 내부 단편화의 차이가 뭔가요?</h2>\n<h2>메모리 배치 기법중 하나인 colaescing(통합)에 대해 설명해주세요.</h2>\n<h2>메모리 배치 기법중 하나인 compaction(압축)에 대해 설명해주세요.</h2>\n<h2>메모리 배치 기법중 하나인 버디 시스템에 대해 설명해주세요.</h2>\n<h2>메모리 배치 기법중 하나인 페이징에 대해 설명해주세요.</h2>\n<h2>메모리 배치 기법중 하나인 세그멘테이션에 대해 설명해주세요.</h2>\n<h2>가상 메모리에 대해 설명해주세요.</h2>\n<h2>Swapping이란 무엇인가요?</h2>\n<h2>Swapping의 과정을 설명해 주세요.</h2>\n<h2>Swapping의 장단점을 설명해 주세요.</h2>\n<h2>페이지 교체에 대해서 설명해주세요.</h2>\n<h2>페이지 부재를 최소화하려면 어떻게 해야 하나요?</h2>\n<h2>페이지 교체 알고리즘 FIFO에 대해 설명 해주세요.</h2>\n<h2>페이지 교체 알고리즘 LRU에 대해 설명 해주세요.</h2>\n<h2>페이지 교체 알고리즘 LFU에 대해 설명 해주세요.</h2>\n<h2>페이지 교체 알고리즘 클럭 알고리즘에 대해 설명해주세요.</h2>\n<h2>쓰레싱에 대해 설명해주세요.</h2>\n<h2>워킹 알고리즘에 대해 설명해주세요.</h2>\n<h2>페이지 부재 빈도 알고리즘에 대해 설명해주세요.</h2>","frontmatter":{"title":"OS 면접 스터디 5주차","date":"December 06, 2023","update":"December 06, 2023","tags":["operating-system","interview"],"series":"운영체제 면접 스터디"},"fields":{"slug":"/os-interview-study-5week/","readingTime":{"minutes":8.665}}},"seriesList":{"edges":[{"node":{"id":"ea68135a-171b-5985-bd79-c083068e732c","fields":{"slug":"/os-interview-study-1week/"},"frontmatter":{"title":"OS 면접 스터디 1주차"}}},{"node":{"id":"54083103-5c8b-54a9-9f3f-4e2bb0eda6c0","fields":{"slug":"/os-interview-study-2week/"},"frontmatter":{"title":"OS 면접 스터디 2주차"}}},{"node":{"id":"2cac4d66-e30f-50ee-bdd2-18e03013bd6a","fields":{"slug":"/os-interview-study-3week/"},"frontmatter":{"title":"OS 면접 스터디 3주차"}}},{"node":{"id":"964be3af-4d8b-5d26-9b8f-9be8e7a34ad2","fields":{"slug":"/os-interview-study-4week/"},"frontmatter":{"title":"OS 면접 스터디 4주차"}}},{"node":{"id":"fa7523ff-1ef3-530d-a49b-3cc2cd88ac17","fields":{"slug":"/os-interview-study-5week/"},"frontmatter":{"title":"OS 면접 스터디 5주차"}}}]},"previous":{"fields":{"slug":"/static-with-memory-structure/"},"frontmatter":{"title":"static을 더 잘 사용하기"}},"next":null},"pageContext":{"id":"fa7523ff-1ef3-530d-a49b-3cc2cd88ac17","series":"운영체제 면접 스터디","previousPostId":"10e0dab4-d2e7-52df-8daa-31bfef1b08b6","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}