{"componentChunkName":"component---src-templates-blog-post-js","path":"/데이터베이스/real-mysql-book-study/08-03-b-tree-index/","result":{"data":{"site":{"siteMetadata":{"title":"내가 재밌는 일을 하자 !"}},"markdownRemark":{"id":"8db175c7-d70f-5cf6-b175-5006d7b20fbd","excerpt":"B-Tree 인덱스 B-Tree 인덱스는 데이터베이스의 인덱싱 알고리즘에서 가장 일반적으로 사용되는 알고리즘이다. 가장 큰 특징은 칼럼의 원래 값을 변형하지 않고 인덱스 자료구조 내에서는 항상 정렬된 상태로 값들을 저장한다. 흔히 B-Tree를 Binary-Tree…","html":"<h2 id=\"b-tree-인덱스\" style=\"position:relative;\"><a href=\"#b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"b tree 인덱스 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>B-Tree 인덱스</h2>\n<p>B-Tree 인덱스는 <u>데이터베이스의 인덱싱 알고리즘에서 가장 일반적으로 사용되는 알고리즘</u>이다.</p>\n<p>가장 큰 특징은 <u>칼럼의 원래 값을 변형하지 않고</u> 인덱스 자료구조 내에서는 <u>항상 정렬된 상태로 값들을 저장</u>한다.</p>\n<p>흔히 B-Tree를 Binary-Tree (이진 트리)로 생각한다. 하지만 Balanced-Tree의 약자로, Binary-Tree는 아니다.<br>\nBalanced-Tree는 균형잡힌 트리로, 노드가 한 쪽 방향으로 치우치지 않고 왼쪽 위부터 차곡차곡 쌓인다고 생각하면 된다.</p>\n<p>결국, <u>B-Tree 인덱스는 Balanced-Tree 자료구조를 이용한 인덱싱 알고리즘</u>이다.</p>\n<blockquote>\n<p><a href=\"https://www.baeldung.com/cs/balanced-trees\">Balacned Tree - Baeldung</a></p>\n</blockquote>\n<h3 id=\"1-b-tree의-구조-및-특성\" style=\"position:relative;\"><a href=\"#1-b-tree%EC%9D%98-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%ED%8A%B9%EC%84%B1\" aria-label=\"1 b tree의 구조 및 특성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. B-Tree의 구조 및 특성</h3>\n<h4 id=\"구조\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%A1%B0\" aria-label=\"구조 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구조</h4>\n<p>B-Tree를 이해하기 위해 B-Tree의 구조에 대해 알아보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6b159fc7faa72f2a8538267147279524/6d4f0/b-tree-architecure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABRklEQVR42q2Sy0oDUQyGv2mnV2yr9mJRrLjTUgR3Ln0at+K1Dl3MM7j0FfoSbhW8YQVF3Cj4GhOTw0wZbVUEAyEkh/z5T/7ATxaKj4incYbjaIu+1BjIisZNreX5zc7Bv4UlgQxnkuNE6q4xlIx62w04jQrs6JvVLO5J6VvAdyjfQe8NSjHDzLg5lBaBbCi7bY1rrhZIT2NnKpiyyj5A9wKqI1i/gpx7OJKKNhXZlwaHyvJAgcOoGg8sa6c3FdAAFLBtwE/QCO3b/2EyAeQYeF/yaZ0TdU/BPBPmM8AfzQCeoZBmqF/PJ0yHuoJHqEh6iAli6iYK2453ZdZdxiXUb6CZKKsqt17UbY+W38OCDmxabQzYV2XtFgPpunwgq055u1M7k1eYU2WXY3Yd9XkbYswtV8Fq17CYYlh0Sttd4g7fZyhZe/sA92aCFvoX8/wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"B-Tree의 구조\"\n        title=\"\"\n        src=\"/static/6b159fc7faa72f2a8538267147279524/f058b/b-tree-architecure.png\"\n        srcset=\"/static/6b159fc7faa72f2a8538267147279524/c26ae/b-tree-architecure.png 158w,\n/static/6b159fc7faa72f2a8538267147279524/6bdcf/b-tree-architecure.png 315w,\n/static/6b159fc7faa72f2a8538267147279524/f058b/b-tree-architecure.png 630w,\n/static/6b159fc7faa72f2a8538267147279524/40601/b-tree-architecure.png 945w,\n/static/6b159fc7faa72f2a8538267147279524/78612/b-tree-architecure.png 1260w,\n/static/6b159fc7faa72f2a8538267147279524/6d4f0/b-tree-architecure.png 1955w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Tree의 구조를 기본적으로 가진다.</p>\n<p>맨 위에는 1개의 <code class=\"language-text\">루트 노드</code>가 있다.<br>\n맨 아래에는 여러 개의 <code class=\"language-text\">리프 노드</code>가 있다.<br>\n루트 노드와 리프 노드 가운데는 <code class=\"language-text\">브랜치 노드</code>라고 한다.</p>\n<p>데이터베이스에서 실제 데이터와 인덱스는 따로 관리되는데, <u>리프 노드는 항상 실제 데이터를 찾아가기 위한 주소값을 가진다.</u></p>\n<p>여기서 <code class=\"language-text\">Balanced</code> 라는 이름에 걸맞게 노드가 한 쪽으로만 치우치지 않는다.<br>\n예를 들어 다음과 같은 형태이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/7575b/not-balanced-tree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.0253164556962%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWklEQVR42q1TS0oDQRB9k5/RGD9R/MTEjSAIbhwQQTELjyB4hexcRNEkGpgDiAfIFXIJN24FRVduBA8y5atKph1IbFAsKKqrP69fd70CfNaVXdzKIc4ky7jF/Ji+OlyUDD0YO/MBLDwAOUtaMo1IqojiOcvbsolevGOA91y7lJK5z16AhoLquNb6VMCcWxQy6Ese57zgRjbQkSUMCH5nwCvMt21P2t6ANYLWBkDWTUZSRFNmGAt84hGZNtCNTxlPjH1b5nlBSF+3C9ImQPAMHDwBVTd5JWWCVeyPNDbJUj3iv6kPTwYTn6zMyLLCfyzi1/YDaMJU3LN1Y7LZc8gHlkSteJL/C9sEdJQGf3ruJHsHph6B8tiCykgrHVEF3wWcNcGL55I+kH8F6mSccZMdWaTvoyd7BAptTqWjErpmA/hErwWiPkNKqpTSZ4EtWMeFLLtu0kbQDhsV8gv0n5AgE+6srQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"균형잡히지 않은 Tree\"\n        title=\"\"\n        src=\"/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/f058b/not-balanced-tree.png\"\n        srcset=\"/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/c26ae/not-balanced-tree.png 158w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/6bdcf/not-balanced-tree.png 315w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/f058b/not-balanced-tree.png 630w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/40601/not-balanced-tree.png 945w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/78612/not-balanced-tree.png 1260w,\n/static/f63eb8e2a10c7d5cd6ab0f81db38fa64/7575b/not-balanced-tree.png 1608w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4 id=\"특성\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%84%B1\" aria-label=\"특성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특성</h4>\n<p>가장 중요한 특성은 <u>노드들을 정렬된 상태로 저장한다는 것이다.</u><br>\n이러한 특성 때문에 조회를 빠른 속도로 처리할 수 있게 된다.<br>\n하지만 반대로 말해 인덱스에 값을 추가하거나 삭제하는 경우 정렬을 맞춰야하므로 오버헤드가 발생하게 된다.</p>\n<p>그리고 또 하나의 중요한 특성은 <u>인덱스의 리프 노드는 실제 데이터의 PK 값을 가진다.</u><br>\n인덱스를 통해 빠르게 원하는 값을 찾아도, 원하는 값이 없는 경우 실제 데이터를 조회해야 한다.<br>\n이를 위해 실제 데이터의 주소값을 가져야하는데 기본키를 주소값으로 대신하여 사용하게 된다.</p>\n<p>마지막으로 B-Tree의 중요한 특징은, <u>모든 세켄더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK 인덱스를 거쳐야 한다.</u><br>\n이에 대한 자세한 내용은 8.8절에서 자세히 알아보자.</p>\n<h3 id=\"2-b-tree-인덱스-crud-인덱스-쓰기-작업과-조회-작업\" style=\"position:relative;\"><a href=\"#2-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4-crud-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%93%B0%EA%B8%B0-%EC%9E%91%EC%97%85%EA%B3%BC-%EC%A1%B0%ED%9A%8C-%EC%9E%91%EC%97%85\" aria-label=\"2 b tree 인덱스 crud 인덱스 쓰기 작업과 조회 작업 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. B-Tree 인덱스 CRUD: 인덱스 쓰기 작업과 조회 작업</h3>\n<p>위에서 언급했듯이 B-Tree는 값 쓰기 성능을 희생해서 조회 성능을 높인다.<br>\n쓰기 성능이 어떤 이유에서 희생되는지 알아보자.</p>\n<p>참고로 InnoDB에서는 B-Tree 쓰기 작업을 모두 <code class=\"language-text\">체인지 버퍼</code>를 활용해 지연처리 될 수 있다.<br>\n이를 통해 다른 스토리지 엔진보다는 좋은 성능을 낳을 수 있다.</p>\n<h4 id=\"인덱스-추가\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%B6%94%EA%B0%80\" aria-label=\"인덱스 추가 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 추가</h4>\n<p>새로운 키 값이 B-Tree에 저장될 때 즉시 저장될 수도 있고 아닐 수도 있다.\n하지만 PK나 Unique Index의 경우 중복 체크가 필요하기 때문에 즉시 삽입하게 된다.<br></p>\n<p>저장될 때 값이 저장될 적절한 위치를 검색해야 한다. 위치가 결정되면 레코드의 PK 값과 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.</p>\n<p>만약 들어갈 위치가 없다면, <code class=\"language-text\">페이지</code>를 분리해서 들어갈 공간을 만들어야 한다.<br>\n이러한 과정들이 포함되다보니 쓰기 작업은 오버헤드가 발생하게 되는 것이다.</p>\n<h4 id=\"인덱스-삭제\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%82%AD%EC%A0%9C\" aria-label=\"인덱스 삭제 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 삭제</h4>\n<p>삭제의 경우 추가보다 단순하다.<br>\nB-Tree의 리프 노드를 찾아 그냥 삭제 마킹만 하면 끝이다.<br>\n이렇게 마킹된 인덱스의 공간은 계속 방치되거나 재활용될 수 있다.<br>\n하지만 마킹 작업 또한 디스크 쓰기가 필요하므로 오버헤드가 발생한다.</p>\n<h4 id=\"인덱스-변경\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%B3%80%EA%B2%BD\" aria-label=\"인덱스 변경 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 변경</h4>\n<p>단순히 값을 변경하지 않는다.<br>\n인덱스 삭제가 먼저 이루어지고 인덱스 키 추가 작업이 이루어진다.<br>\n때문에 가장 많은 오버헤드를 발생시키는 작업이 된다.</p>\n<h4 id=\"인덱스-조회\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%ED%9A%8C\" aria-label=\"인덱스 조회 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 조회</h4>\n<p>B-Tree 인덱스를 조회하는 조건에 대해 알아보자.</p>\n<p>우선 인덱스 조회는 <code class=\"language-text\">SELECT</code> 뿐만 아니라 <code class=\"language-text\">UPDATE</code>나 <code class=\"language-text\">DELETE</code>를 처리하기 위해 레코드를 검색하는 경우에도 사용된다.<br>\n중요한 점은 <u>검색은 100% 일치하거나 값의 앞부분만 일치하는 경우에만 사용될 수 있다.</u><br>\n다시 말해, <u>집계 함수나 연산을 수행한 결과로 검색하는 쿼리는 인덱스를 통해 조회가 이뤄지지 않는다.</u></p>\n<p>지금까지 B-Tree 인덱스의 CRUD에 대해 살펴봤다.<br>\n기본적으로 조회 성능을 끌어올리기 위해 인덱스의 중요성을 많이 언급하지만, InnoDB 엔진의 경우 <em>레코드 락</em>이나 <em>넥스트 키 락</em>이 조회를 수행한 인덱스를 잠근 후 테이블의 레코드도 잠그는 방식으로 구현되어 있기 때문에 <code class=\"language-text\">UPDATE</code>나 <code class=\"language-text\">DELETE</code> 쿼리를 처리할 때도 적절한 인덱스가 없다면 상당한 성능 이슈를 야기할 수 있다.</p>\n<h3 id=\"3-b-tree-인덱스-사용에-영향을-미치는-요소\" style=\"position:relative;\"><a href=\"#3-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%82%AC%EC%9A%A9%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%9A%94%EC%86%8C\" aria-label=\"3 b tree 인덱스 사용에 영향을 미치는 요소 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. B-Tree 인덱스 사용에 영향을 미치는 요소</h3>\n<p>그렇다면 이 B-Tree 인덱스를 어떤 기준을 가지고 설정하면 좋을까?<br>\n여기에는 두 가지 기준이 있다.</p>\n<h4 id=\"3-1-인덱스-키-값의-크기\" style=\"position:relative;\"><a href=\"#3-1-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%82%A4-%EA%B0%92%EC%9D%98-%ED%81%AC%EA%B8%B0\" aria-label=\"3 1 인덱스 키 값의 크기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. 인덱스 키 값의 크기</h4>\n<p>MySQL은 디스크에 데이터를 저장하는 가장 작은 기본 단위를 <u>페이지</u>라고 한다.<br>\n이 페이지는 InnoDB 버퍼 풀에도 적용되며 <u>모든 작업의 최소 단위</u>가 된다.\n인덱스도 결국 이 페이지 단위로 관리된다.<br>\n참고로 default 값은 16KB이다.</p>\n<p>그렇다면 인덱스 키 값의 크기가 이와 무슨 관련이 있을까?<br>\n조금만 생각해보면 쉽게 알아차릴 수 있다.</p>\n<p>인덱스 키 값이 크기가 늘어나면, 하나의 페이지에서 저장할 수 있는 인덱스는 줄어든다.<br>\n하나의 페이지에서 저장할 수 있는 인덱스가 줄어들면, 그만큼 페이지를 더 많이 만들어야 한다.<br>\n페이지가 늘어날 수록 한 페이지에서 조회할 수 있는 레코드의 수가 적으므로 더 많은 페이지를 뒤져야 한다.</p>\n<p>결국, <u>인덱스 키 값의 크기가 작을 수록 인덱스를 이용한 조회 성능이 향상된다.</u></p>\n<h4 id=\"3-2-cardinality\" style=\"position:relative;\"><a href=\"#3-2-cardinality\" aria-label=\"3 2 cardinality permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2. Cardinality</h4>\n<p>또 다른 기준으로 <em>Cardinality</em>가 있다.<br>\n<u>Cardinality는 하나의 칼럼을 기준으로 유니크한 값의 수</u>를 의미한다.</p>\n<p>결론부터 말하자면 Cardinality가 높은, 즉 중복도가 낮은 칼럼을 인덱스로 설정하는 것이 좋다.</p>\n<p>중복도가 높은 칼럼을 인덱스로 설정했다면 그만큼의 값을 다 찾아야 한다.<br>\n만약 1000개의 값이 중복되었고 그 중 한 개의 레코드를 조회하는 쿼리라면, 인덱스를 이용할 때 999개의 레코드에 Lock이 걸리고 결과적으론 1개의 레코드만 반환될 것이다.</p>\n<p>그렇지만 Cardinality가 낮다고 해도 <u>정렬이나 그룹핑과 같은 작업을 위해 인덱스를 만드는 경우가 훨씬 나은 경우도 많다.</u></p>\n<h3 id=\"4-b-tree-인덱스를-통한-데이터-읽기\" style=\"position:relative;\"><a href=\"#4-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9D%BD%EA%B8%B0\" aria-label=\"4 b tree 인덱스를 통한 데이터 읽기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. B-Tree 인덱스를 통한 데이터 읽기</h3>\n<p>B-Tree 인덱스를 이용해 데이터를 조회하는 대표적인 세 가지 방식에 대해 알아보자.</p>\n<h4 id=\"4-1-인덱스-레인지-스캔\" style=\"position:relative;\"><a href=\"#4-1-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%A0%88%EC%9D%B8%EC%A7%80-%EC%8A%A4%EC%BA%94\" aria-label=\"4 1 인덱스 레인지 스캔 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-1. 인덱스 레인지 스캔</h4>\n<p>인덱스 접근 방식 중 대표적인 방식이다.<br>\n뒤에 나올 두 가지 접근 방식 (인덱스 풀 스캔, 루스 인덱스 스캔) 보다 빠른 방식이다.<br>\n실행 계획을 봤는데 인덱스 레인지 스캔이 나온다면 잘 사용하고 있다고 이해하면 된다.</p>\n<p>인덱스 레인지 스캔은 <u>검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.</u><br>\n기본적으로 값이 크기 순으로 정렬되어 있는 B-Tree에서, 찾고자 하는 값의 범위를 지정해 순차대로 조회하는 단순한 방식이다.</p>\n<p>하지만 간과하기 쉬운 부분이 있다.<br>\n인덱스에서는 단순하고 빠르게 조회를 하더라도 각 인덱스 레코드를 통해 실제 디스크에 저장된 레코드에 접근하는 것은 랜덤 디스크 I/O 작업이라는 것이다.<br>\n그래서 옵티마이저가 적절히 판단해서 선택하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">'Handler_%'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 쿼리를 통해 인덱스 레인지 스캔이 얼만큼 수행됐는지 확인할 수 있다.<br>\n자세한 내용은 <a href=\"https://www.manty.co.kr/bbs/detail/develop?id=100\">링크</a> 참고</p>\n<h4 id=\"4-2-인덱스-풀-스캔\" style=\"position:relative;\"><a href=\"#4-2-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%92%80-%EC%8A%A4%EC%BA%94\" aria-label=\"4 2 인덱스 풀 스캔 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-2. 인덱스 풀 스캔</h4>\n<p>인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 <u>인덱스의 처음부터 끝까지 모두 읽는 방식이다.</u><br>\n대표적으로 <u>&#x3C;쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 사용</u>된다.<br>\n예를 들어 인덱스는 <code class=\"language-text\">(A, B, C)</code> 칼럼 순으로 만들어져있지만 <code class=\"language-text\">WHERE</code> 절에서 <code class=\"language-text\">B</code> 칼럼이나 <code class=\"language-text\">C</code> 칼럼으로 검색하는 경우다.</p>\n<p>\"이럴바엔 테이블 풀 스캔이 낫지 않나요?\" 할 수 있지만 일반적으로 인덱스의 크기는 테이블 크기보다 작으므로 상대적으로 효율적이다.<br>\n다만 <u>쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 사용된다.</u> (커버링 인덱스)</p>\n<p>그다지 효율적인 방식은 아니며, <u>일반적으로 인덱스를 잘 활용하지 못하는 경우다.</u></p>\n<h4 id=\"4-3-루스-인덱스-스캔\" style=\"position:relative;\"><a href=\"#4-3-%EB%A3%A8%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8A%A4%EC%BA%94\" aria-label=\"4 3 루스 인덱스 스캔 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-3. 루스 인덱스 스캔</h4>\n<p>루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 작동한다. 하지만 중간에 필요없는 인덱스는 무시하고 다음으로 넘어가는 형태를 취한다.<br>\n일반적으로 <u><code class=\"language-text\">GROUP BY</code> 또는 집계 함수 중, <code class=\"language-text\">MAX()</code> 또는 <code class=\"language-text\">MIN()</code> 함수에 대해 최적화하는 경우 사용된다.</u><br>\n해당 방식을 사용하려면 여러 조건을 만족해야 하는데, 이는 10장 실행 계획에서 자세히 알아보자.</p>\n<h4 id=\"4-5-인덱스-스킵-스캔\" style=\"position:relative;\"><a href=\"#4-5-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8A%A4%ED%82%B5-%EC%8A%A4%EC%BA%94\" aria-label=\"4 5 인덱스 스킵 스캔 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-5. 인덱스 스킵 스캔</h4>\n<p>해당 방식은 인덱스 풀 스캔 방식을 개선하기 위해 등장했다.<br>\n만약 인덱스가 <code class=\"language-text\">(A, B)</code> 순으로 생성되었지만 조건절에 <code class=\"language-text\">(B)</code>를 통해 조회하는 경우, 우선 A에서 <u>유니크한 값들을 모두 조회해서 주어진 조건에 조회한 칼럼을 추가해서 쿼리를 다시 실행하는 형태로 동작한다.</u><br></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dbb380e1c1b59a6404ad1cdeabe83a97/11b93/index-skip-scan.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.24050632911393%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAADoElEQVR42nWU+1MaVxTH/X/7W39sm2k6JpoxTklSik+qUgsqjxBBUFGeRkEiAYOiKISoKCBPkYVddvn23LtAnM50Z76zDw6fe88533NHer0eFEWC0hNJEnpgkocCFMj0e/OxgQdSpVFGpV7GfbWE2mMdD8IDOt0Our0u14gK7JJE+iBxiRQwkCSLEEmZuxwyhSt8Tn9B9DSOcCJK374hd59HrVWH3JPRJc4IbQGVWgX+SACBwxACkSA+ncTw5eIEcdJlPsuDLR4HJpe0mFz8E2PTGmiWZjBlMcDgMKNUr7A8+MJD4EHiEOHjT6QoYqljRJNxBOMRnObSLAT+2AHWdp0wedZhdL/H4oc1mNx22H1bqDbrPN1OV1RTlmUZbUGAQGoJbfXeFlCuVRE7jsNit2FmSY+/TMt4Nz+Nt/ppuIM+SreEUPwI3r0AX5TvsNdTwKD/vQbfHlstpC7O4fRuw7G7BevWBn6dGIPZtY5rymxzfw8L/xh4bJtqTkAqpizxTrEti/QsUVfZah25w+vH0InsOSKpJPaSCUzOaGFxO5C8+gpnyI9ls4kDBUlQgcwWYh/CpahQVhd2pxywuuPEq0VqyvIsfvjpR7zQvcbcuhHjc29hMP2tAsUhUP2j9AQ6eB8AdyIfseKyY2XLiV/GRzFl0MMX3ceC2YjZhXkO7AxSHoKGqaqpswByKW4KeUxOvYNucQ6/z+rw8s1rBKNh3FHTIok4vNSgJ02RaULkvtP7d77jLoeyK5k6warDhoubK4RiEVKUjB1DrnCHNNWx0XogF3b5EHAfCp02itV7FColFKqqiqR86RaNZgNn6XMYrEb44mHYdjdgclpgI6P7jj4iENtHmcaRA5WOCrwu3lGAC+9Jdu8m9misDpMxHJ5+xlUxj0w2g1HNGMbnNfjtj3E804zi+ZtRvJqewOyangOVp0C+i+wlznMZnH1lukQqm0bk+AipyzP4gwFo57XYPvDDuG7GqssKV2AbURrRIE3QDS2qgNW/PTC2Qk5WmJ37ojNGodmU2pCkDm5u89DqdZgzLtCk6PDzy2dYodG7rhaxEw7B+sHa73Kr3xRqgEwNYMcY86T63OVwSRLhI/NaNqywshk2L+P5xAuYnTZkqcYOv4d8qE6KKPWB36Xg6Ts7C0UCerwe2N02bPnccHtd2AxsIp5O4tv9LTz7/v8DqjOt6vsz2yV7b4uPlJLAJXSa/HCtNWso10uoN6oUw7IT8S/jUAyBRDeFIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"인덱스 스킵 스캔 동작 방식\"\n        title=\"\"\n        src=\"/static/dbb380e1c1b59a6404ad1cdeabe83a97/f058b/index-skip-scan.png\"\n        srcset=\"/static/dbb380e1c1b59a6404ad1cdeabe83a97/c26ae/index-skip-scan.png 158w,\n/static/dbb380e1c1b59a6404ad1cdeabe83a97/6bdcf/index-skip-scan.png 315w,\n/static/dbb380e1c1b59a6404ad1cdeabe83a97/f058b/index-skip-scan.png 630w,\n/static/dbb380e1c1b59a6404ad1cdeabe83a97/40601/index-skip-scan.png 945w,\n/static/dbb380e1c1b59a6404ad1cdeabe83a97/11b93/index-skip-scan.png 1124w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>하지만 조회 비용과 관련해 다음과 같은 전제 조건이 필요하다.</p>\n<ul>\n<li>WHERE 절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 한다.</li>\n<li>쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능하다. (커버링 인덱스)</li>\n</ul>\n<h3 id=\"5-b-tree-인덱스의-정렬-및-스캔-방향\" style=\"position:relative;\"><a href=\"#5-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%A0%95%EB%A0%AC-%EB%B0%8F-%EC%8A%A4%EC%BA%94-%EB%B0%A9%ED%96%A5\" aria-label=\"5 b tree 인덱스의 정렬 및 스캔 방향 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. B-Tree 인덱스의 정렬 및 스캔 방향</h3>\n<p>인덱스의 키 값을 정렬하고 스캔하는 방향에 대한 내용이다.<br>\n정렬은 내림차순, 오름차순 모두 가능하며 스캔 또한 정순과 역순 모두 가능하다.<br></p>\n<p>각 쿼리에 따라 내림차순이냐 오름차순이냐가 성능에 영향을 미칠 수 있다.<br></p>\n<p>중요한 점은 <u>인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다는 것이다.</u></p>\n<h3 id=\"6-b-tree-인덱스의-가용성과-효율성\" style=\"position:relative;\"><a href=\"#6-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EA%B0%80%EC%9A%A9%EC%84%B1%EA%B3%BC-%ED%9A%A8%EC%9C%A8%EC%84%B1\" aria-label=\"6 b tree 인덱스의 가용성과 효율성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. B-Tree 인덱스의 가용성과 효율성</h3>\n<p>쿼리의 <code class=\"language-text\">WHERE</code> 절이나 <code class=\"language-text\">GROUP BY</code> 또는 <code class=\"language-text\">ORDER BY</code> 절이 어떤 경우에 인덱스를 사용하며 어떤 방식으로 조회하는지 식별할 수 있어야 한다.<br>\n이번에는 이에 대해 알아보자.</p>\n<h4 id=\"6-1-비교-조건의-종류와-효율성\" style=\"position:relative;\"><a href=\"#6-1-%EB%B9%84%EA%B5%90-%EC%A1%B0%EA%B1%B4%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%9A%A8%EC%9C%A8%EC%84%B1\" aria-label=\"6 1 비교 조건의 종류와 효율성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6-1. 비교 조건의 종류와 효율성</h4>\n<p>다중 칼럼 인덱스에서 각 <u>칼럼의 순서와 그 칼럼에 적용된 조건이 동등 비교인지 아니면 대소 비교 같은 범위 조건인지에 따라 인덱스 활용 형태가 달라진다.</u></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/43bd2197855fc3a99dad906605e8361e/fb1ef/example-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.16455696202532%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACRUlEQVR42m2T62/SUBjG+b9d/KRmRN0ConMXJZJtXmLYxWSwm3OAUBi7gJiM6AbMUhgtLS29QEv7+PYgbB9s8+Rtzjnv7zxPexoYDk3ohgzDVJhGrgnH8cckaLpEYzKsgUa1T9Jpzoau6xBFEZZlodfrQdNo3jDgX4GW2MA3bhdHuV2UqnkGNK0euPIxEsfbKPzIgBeuUSyeoF6vo9vtotlsotPpMPE8z2qr1RoDf1ZLWIiFsbj2EluHcQJa6JPj9e0YIrEQ3m1E0Zaa5EIhZxoB/kCgZt+VIAgMJssyVFUdA3mhhuIFh4vKGU7KBdgjk+yr4M6zKJTzyJc4qLpCSz26XUiSSM0ai+3HlCQJtm0zmOu6CGQLGSy8eYGPW+tIn6XJ4QDtWx7Lq0tYWV1EMrNHwJ6/nOYceJ7HGv3qawKajAV+16p4v7mOyHIImVIWQ8egjyEjmU5ifnEeO6kkVKNHsCFsx6JqM7kEH4Oc6TMDVmuXCL0N4+HsDOIHm9Rk0DtUsEqbPHgyg5VPUSh9hTkZuSPm0vUmkNE9/QMe59IIRp7h+es5JL/v07EYwKTjkUjtYW4phA87cYiyiNxpDlf1XwzsEcDzfN1FnyjAFTmsfV5D4msC6ZM07WRD6oqIRF/hcXgWj0JBxL9sIBh+ioPUPgPajj12es/ZFNjpdtDga6g1rklXdFhN3HbaODzaR/G8gMplBYal46Z5A6HdHEcf3cWcAKeRFUVGv69B1VR2lhRFYVXX++xPYBHvRRvD3P/KB/4F4dYknF7nRUEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"example 1\"\n        title=\"\"\n        src=\"/static/43bd2197855fc3a99dad906605e8361e/f058b/example-1.png\"\n        srcset=\"/static/43bd2197855fc3a99dad906605e8361e/c26ae/example-1.png 158w,\n/static/43bd2197855fc3a99dad906605e8361e/6bdcf/example-1.png 315w,\n/static/43bd2197855fc3a99dad906605e8361e/f058b/example-1.png 630w,\n/static/43bd2197855fc3a99dad906605e8361e/40601/example-1.png 945w,\n/static/43bd2197855fc3a99dad906605e8361e/78612/example-1.png 1260w,\n/static/43bd2197855fc3a99dad906605e8361e/fb1ef/example-1.png 1879w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>여기서 눈여겨 볼 것은 dept_no는 <code class=\"language-text\">=</code> 검색이고 emp_no는 <code class=\"language-text\">>=</code> 비교이다.<br>\n이때 인덱스 칼럼의 순서가 <code class=\"language-text\">(dept_no, emp_no)</code> 이냐 <code class=\"language-text\">(emp_no, dept_no)</code>에 따라 인덱스를 조회하는 방식이 달라진다.</p>\n<p>범위 조건 비교 (<code class=\"language-text\">>=</code>) 보다 동등 조건 비교 (<code class=\"language-text\">=</code>)가 값을 조회하기엔 더 최적화된 조건이므로, dept_no 칼럼이 선행된 인덱스의 경우 더 효율적으로 조회할 수 있는 것이다.</p>\n<h4 id=\"6-2-인덱스의-가용성\" style=\"position:relative;\"><a href=\"#6-2-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EA%B0%80%EC%9A%A9%EC%84%B1\" aria-label=\"6 2 인덱스의 가용성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6-2. 인덱스의 가용성</h4>\n<p>만약 인덱스 칼럼의 순서가 <code class=\"language-text\">(dept_no, emp_no)</code>인 인덱스에 <code class=\"language-text\">WHERE</code> 절에 <code class=\"language-text\">emp_no</code>만 있는 쿼리를 날린다면, 인덱스 칼럼의 선행 조건인 <code class=\"language-text\">dept_no</code>를 이용하지 못하므로 인덱스를 효율적으로 사용할 수 없다.</p>\n<h4 id=\"6-3-가용성과-효율성-판단\" style=\"position:relative;\"><a href=\"#6-3-%EA%B0%80%EC%9A%A9%EC%84%B1%EA%B3%BC-%ED%9A%A8%EC%9C%A8%EC%84%B1-%ED%8C%90%EB%8B%A8\" aria-label=\"6 3 가용성과 효율성 판단 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6-3. 가용성과 효율성 판단</h4>\n<p>B-Tree 인덱스는 특성상 다음 조건에서는 사용할 수 없다. (필터링 작업을 통해 사용하는 경우는 있다.)</p>\n<ul>\n<li>Not Equal로 비교된 경우</li>\n<li><code class=\"language-text\">LIKE '%??'</code> 처럼 <u>앞부분이 잘린 형태로 검색하는 경우</u></li>\n<li>스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 경우</li>\n<li>NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우</li>\n<li>데이터 타입이 서로 다른 비교를 하는 경우 (인덱스 칼럼의 타입을 변환해야 하므로 X)</li>\n<li>문자열 데이터 타입의 콜레이션이 다른 경우</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4\">B-Tree 인덱스</a></p>\n<ul>\n<li>\n<p><a href=\"#1-b-tree%EC%9D%98-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%ED%8A%B9%EC%84%B1\">1. B-Tree의 구조 및 특성</a></p>\n<ul>\n<li><a href=\"#%EA%B5%AC%EC%A1%B0\">구조</a></li>\n<li><a href=\"#%ED%8A%B9%EC%84%B1\">특성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4-crud-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%93%B0%EA%B8%B0-%EC%9E%91%EC%97%85%EA%B3%BC-%EC%A1%B0%ED%9A%8C-%EC%9E%91%EC%97%85\">2. B-Tree 인덱스 CRUD: 인덱스 쓰기 작업과 조회 작업</a></p>\n<ul>\n<li><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%B6%94%EA%B0%80\">인덱스 추가</a></li>\n<li><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%82%AD%EC%A0%9C\">인덱스 삭제</a></li>\n<li><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%B3%80%EA%B2%BD\">인덱스 변경</a></li>\n<li><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%ED%9A%8C\">인덱스 조회</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%82%AC%EC%9A%A9%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%9A%94%EC%86%8C\">3. B-Tree 인덱스 사용에 영향을 미치는 요소</a></p>\n<ul>\n<li><a href=\"#3-1-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%82%A4-%EA%B0%92%EC%9D%98-%ED%81%AC%EA%B8%B0\">3-1. 인덱스 키 값의 크기</a></li>\n<li><a href=\"#3-2-cardinality\">3-2. Cardinality</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9D%BD%EA%B8%B0\">4. B-Tree 인덱스를 통한 데이터 읽기</a></p>\n<ul>\n<li><a href=\"#4-1-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%A0%88%EC%9D%B8%EC%A7%80-%EC%8A%A4%EC%BA%94\">4-1. 인덱스 레인지 스캔</a></li>\n<li><a href=\"#4-2-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%92%80-%EC%8A%A4%EC%BA%94\">4-2. 인덱스 풀 스캔</a></li>\n<li><a href=\"#4-3-%EB%A3%A8%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8A%A4%EC%BA%94\">4-3. 루스 인덱스 스캔</a></li>\n<li><a href=\"#4-5-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8A%A4%ED%82%B5-%EC%8A%A4%EC%BA%94\">4-5. 인덱스 스킵 스캔</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%A0%95%EB%A0%AC-%EB%B0%8F-%EC%8A%A4%EC%BA%94-%EB%B0%A9%ED%96%A5\">5. B-Tree 인덱스의 정렬 및 스캔 방향</a></p>\n</li>\n<li>\n<p><a href=\"#6-b-tree-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EA%B0%80%EC%9A%A9%EC%84%B1%EA%B3%BC-%ED%9A%A8%EC%9C%A8%EC%84%B1\">6. B-Tree 인덱스의 가용성과 효율성</a></p>\n<ul>\n<li><a href=\"#6-1-%EB%B9%84%EA%B5%90-%EC%A1%B0%EA%B1%B4%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%9A%A8%EC%9C%A8%EC%84%B1\">6-1. 비교 조건의 종류와 효율성</a></li>\n<li><a href=\"#6-2-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EA%B0%80%EC%9A%A9%EC%84%B1\">6-2. 인덱스의 가용성</a></li>\n<li><a href=\"#6-3-%EA%B0%80%EC%9A%A9%EC%84%B1%EA%B3%BC-%ED%9A%A8%EC%9C%A8%EC%84%B1-%ED%8C%90%EB%8B%A8\">6-3. 가용성과 효율성 판단</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"B-Tree 인덱스에 대해 알아보자","date":"2024년 2월 1일","description":"8.3 B-Tree 인덱스","tags":["database"],"series":"Real MySQL 8.0"}},"previous":{"fields":{"slug":"/네트워크/네트워크-책-스터디/04-http-status-code/"},"frontmatter":{"title":"4장. 결과를 전달하는 HTTP 상태 코드"}},"next":{"fields":{"slug":"/회고/리스티웨이브-프로젝트-회고록/1-2-주차/"},"frontmatter":{"title":"ListyWave 프로젝트 1, 2주차 회고록"}}},"pageContext":{"id":"8db175c7-d70f-5cf6-b175-5006d7b20fbd","previousPostId":"a3aba94a-cef8-556c-b9bf-a4f8a1fb3ab1","nextPostId":"7222eabd-7f1f-5af6-a31e-ab429d896ae9"}},"staticQueryHashes":["1475414628","2841359383"],"slicesMap":{}}