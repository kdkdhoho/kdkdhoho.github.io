{"componentChunkName":"component---src-templates-blog-post-js","path":"/java/covariant-invariant-and-pecs/","result":{"data":{"site":{"siteMetadata":{"title":"내가 재밌는 일을 하자 !"}},"markdownRemark":{"id":"fe3b3569-8de0-593a-8cdf-fe581780235a","excerpt":"…","html":"<h2 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h2>\n<p>제네릭을 공부하다보면 배열과 잘 어울리기 어렵다는 내용과 함께 자주 등장하는 용어인, <strong>공변</strong>과 <strong>불공변</strong>, 그리고 <strong>실체화</strong>가 있다.</p>\n<p>잘 사용하지 않는 단어인, 공변과 불공변, 그리고 실체화가 <strong>각각 어떤 의미</strong>를 가지는지 알아보고<br>\n<strong>왜 제네릭과 배열은 잘 어울리지 못하는지</strong>에 대해 알아보자.</p>\n<p>또한, 제네릭을 이용해 범용성 있는 API(public 메서드)를 작성하기 위해 알아야 하는 <strong>PECS</strong>에 대해서도 알아보자.</p>\n<br>\n<br>\n<hr>\n<h2 id=\"1-공변과-불공변-그리고-실체화\" style=\"position:relative;\"><a href=\"#1-%EA%B3%B5%EB%B3%80%EA%B3%BC-%EB%B6%88%EA%B3%B5%EB%B3%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%8B%A4%EC%B2%B4%ED%99%94\" aria-label=\"1 공변과 불공변 그리고 실체화 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 공변과 불공변, 그리고 실체화</h2>\n<h3 id=\"1-1-공변과-불공변\" style=\"position:relative;\"><a href=\"#1-1-%EA%B3%B5%EB%B3%80%EA%B3%BC-%EB%B6%88%EA%B3%B5%EB%B3%80\" aria-label=\"1 1 공변과 불공변 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-1. 공변과 불공변</h3>\n<p><strong>배열은 공변</strong>이다.<br>\n공변이라는 뜻은, <code class=\"language-text\">Sub</code> 클래스가 <code class=\"language-text\">Super</code> 클래스의 하위 타입이라면 <code class=\"language-text\">Sub[]</code>는 <code class=\"language-text\">Super[]</code>의 하위 타입이 된다는 의미다.<br>\n즉, <strong>함께 변한다</strong>는 의미로 해석된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Fruit</span> fruit <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Apple</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Fruit</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> fruits <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Apple</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span></code></pre></div>\n<br>\n<p>반면, <strong>제네릭은 불공변</strong>이다.<br>\n마찬가지로 <code class=\"language-text\">Sub</code>가 <code class=\"language-text\">Super</code>의 하위타입이라 해도, <code class=\"language-text\">&lt;Sub></code>는 <code class=\"language-text\">&lt;Super></code>의 하위 타입이 아니다.<br>\n전혀 다른 타입이 된다.<br>\n즉, <strong>함께 변하지 않는다</strong>는 의미로 해석된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Long</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 컴파일 에러. 제네릭 타입이 서로 다르다.</span></code></pre></div>\n<h3 id=\"1-2-실체화\" style=\"position:relative;\"><a href=\"#1-2-%EC%8B%A4%EC%B2%B4%ED%99%94\" aria-label=\"1 2 실체화 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-2. 실체화</h3>\n<p>배열과 제네릭의 또 다른 차이로는 <strong>런타임 시에 실체화</strong>가 된다는 것이다.</p>\n<p>배열의 경우, 런타임에 타입 정보가 존재해야 한다. 즉, 배열은 어떤 타입인지 이미 알고 있다.<br>\n제네릭의 경우, 런타임에 타입 정보가 없다. 컴파일 시에 타입을 검사하고 <strong>소거</strong>하여 런타임에는 타입에 대한 정보가 없다.</p>\n<h2 id=\"2-패러다임-차이\" style=\"position:relative;\"><a href=\"#2-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-%EC%B0%A8%EC%9D%B4\" aria-label=\"2 패러다임 차이 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 패러다임 차이</h2>\n<p>이렇게 <strong>배열과 제네릭은 패러다임의 차이가 존재</strong>한다.<br>\n이로 인해 둘을 어울리기 쉽지 않다.</p>\n<p>한 사례로, <strong>제네릭 배열은 생성하지 못한다</strong>.</p>\n<h3 id=\"2-1-만약-제네릭-배열의-생성이-가능하다면\" style=\"position:relative;\"><a href=\"#2-1-%EB%A7%8C%EC%95%BD-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4%EB%A9%B4\" aria-label=\"2 1 만약 제네릭 배열의 생성이 가능하다면 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. 만약 제네릭 배열의 생성이 가능하다면</h3>\n<p>만약 제네릭 배열이 생성 가능한 상황을 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> stringList<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 매개변수화 타입이 List&lt;String>인 제네릭 배열 선언</span>\nstringList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 제네릭 배열 생성</span>\n\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> intList <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 매개변수화 타입이 List&lt;Integer>인 리스트 초기화</span>\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> stringList<span class=\"token punctuation\">;</span> <span class=\"token comment\">// stringList 배열을 Object[]로 업캐스팅. 배열의 공변성 때문에 가능.</span>\nobject<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> intList<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Object[]에 List&lt;Integer> 타입의 변수 할당. 제네릭의 소거 때문에 가능.</span>\n\n<span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> stringList<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 제네릭 정보로 인해 컴파일러는 자동으로 String으로 캐스팅한다. 이때, ClassCastException 발생</span></code></pre></div>\n<p>위에서 언급한 제네릭과 배열의 특징을 다시 상기해보자.<br>\n제네릭은 컴파일 타임에 타임 체크와 캐스팅을 강제한다.<br>\n반면, 배열은 그렇지 않으며 공변한다.<br></p>\n<p><strong>제네릭이 배열에 포함된다면, 제네릭은 결국 기능을 상실하게 되고 런타임에 <code class=\"language-text\">ClassCastException</code>이 발생할 수 있게 되는 것</strong>이다.<br></p>\n<h3 id=\"2-2-제네릭-배열의-선언은-가능하다\" style=\"position:relative;\"><a href=\"#2-2-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%84%A0%EC%96%B8%EC%9D%80-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\" aria-label=\"2 2 제네릭 배열의 선언은 가능하다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. 제네릭 배열의 선언은 가능하다?</h3>\n<p>제네릭 배열이 <strong>생성은 불가</strong>하지만, <strong>선언은 가능</strong>하다.<br>\n예를 들어, 가변인자 타입으로 제네릭을 받을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">firstValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> ints<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// 가변인자의 타입이 List&lt;Integer>로, 제네릭 타입이다.</span></code></pre></div>\n<p>하지만 제네릭 배열을 사용하는 것은 <strong>Heap Pollution</strong>을 일으킬 수 있다고 친절하게 경고를 한다.<br>\n약간 모순처럼 느껴지지만 이를 허용하는 이유는 <strong>편리성</strong> 때문이라고 한다.<br>\n대신 반드시 안정성도 함께 챙겨야 한다!</p>\n<p>제네릭 타입 배열(가변인자)를 선언하고 사용할 때, 안정성은 어떻게 챙길 수 있을까?</p>\n<p>우선 <em>Heap Pollution</em>에 대해 이해해보자.</p>\n<p>Heap Pollution은 <strong>매개변수화된 타입의 변수(ints)가 타입이 다른 객체(ex. List<String>)를 참조하면 발생</strong>하는 것이다.<br>\n말이 조금 어려운데 코드로 이해해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">firstValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> intLists<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> intLists<span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> strList <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> strList<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 힙 오염 발생!</span>\n\n    <span class=\"token keyword\">return</span> intLists<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위에서 봤던 제네릭 배열을 생성했을 때 생기는 문제와 동일하다.<br>\n결국 배열의 공변성 때문에 제네릭의 타입 강제성이 사라지게 되어 런타임 시에 제네릭 타입이 다른 매개변수화된 타입이 배열에 할당되는 것이다.</p>\n<p>따라서 위 문제만 사전에 완벽히 차단한다면, 안정성을 챙기게 되는 것이다.<br>\n메서드 내부에서는 가변인자 배열에 새로운 값을 저장하지 말고, 배열의 참조가 메서드 외부로 유출되지 않는다면 안정성을 보장할 수 있다.<br>\n안전하다고 판단되면 <code class=\"language-text\">@SafeVarargs</code> 어노테이션을 붙여주어 메서드를 사용하는 코드 쪽에서도 불필요한 경고를 제거해주자.</p>\n<h2 id=\"3-pecs\" style=\"position:relative;\"><a href=\"#3-pecs\" aria-label=\"3 pecs permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. PECS</h2>\n<p>PECS는 <em>Producer-Extends, Consumer-Super</em> 의 약자로, 와일드카드로 제네릭 타입을 제한할 때 사용하는 공식이다.</p>\n<p>생산자는 <code class=\"language-text\">extends</code>를, 소비자는 <code class=\"language-text\">super</code>를 사용하라는 뜻인데, 생산자와 소비자는 각각 무엇을 의미하는 것이며 이 공식이 왜 탄생했을까?</p>\n<h3 id=\"3-1-제네릭은-불공변하기-때문이다\" style=\"position:relative;\"><a href=\"#3-1-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9D%80-%EB%B6%88%EA%B3%B5%EB%B3%80%ED%95%98%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%9D%B4%EB%8B%A4\" aria-label=\"3 1 제네릭은 불공변하기 때문이다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. 제네릭은 불공변하기 때문이다</h3>\n<p>위에서 언급했듯이, 제네릭은 불공변하다.<br>\n때문에 유연성이 다소 부족할 수 있는데, 이를 개선하기 위해 PECS가 탄생했다.<br>\n유연성이 부족한 상황을 코드로 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Stack</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Stack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">E</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">pushAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Iterable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> src<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e <span class=\"token operator\">:</span> src<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">push</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같은 코드가 있다.<br>\n얼핏 보면, 문제는 없어보인다.</p>\n<p>하지만 <code class=\"language-text\">Stack&lt;Number> stack</code>에 <code class=\"language-text\">Iterable&lt;Integer> ints</code>를 인자로 넘기면 컴파일 오류가 발생한다.<br>\n가능할 것 같은데 왜 실패할까?</p>\n<p><code class=\"language-text\">Stack&lt;Number> stack</code>의 메서드 시그니처는 <code class=\"language-text\">pushAll(Iterable&lt;Number> src)</code>와 같을 것이다.<br>\n이때, 제네릭의 불공변 때문에 <code class=\"language-text\">Iterable&lt;Integer></code>과 <code class=\"language-text\">Iterable&lt;Number></code>는 다르다.<br>\n이러한 상황들 때문에 제네릭은 유연성이 다소 부족한 것이다.</p>\n<p>자바는 이런 상황을 보다 유연하게 만들기 위해 와일드카드를 지원하는 것이다.</p>\n<p>그럼 이제 <code class=\"language-text\">pushAll(Iterable&lt;E>)</code> 메서드를 와일드카드를 이용해 유연하게 만들면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">pushAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Iterable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> src<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e <span class=\"token operator\">:</span> src<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">push</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>드디어 <code class=\"language-text\">Iterable&lt;Integer></code> 타입도 안전하게 파라미터로 전달할 수 있게 되었다.<br>\n참고로 매개변수가 클래스에 값을 <strong>생산</strong>하고 있다.</p>\n<br>\n<p>그럼 반대로 값을 모두 뽑아 옮기는 <code class=\"language-text\">popAll()</code> 메서드도 만들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">popAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 메서드도 얼핏 보면 문제 없어보인다.<br>\n하지만 <code class=\"language-text\">Stack&lt;Integer> stack</code>의 모든 원소를 <code class=\"language-text\">Collection&lt;Number></code> 로 옮기려고 하면 컴파일 에러가 발생한다.<br>\n왜냐하면, <code class=\"language-text\">Integer</code> 타입을, <code class=\"language-text\">Collection&lt;Number></code>에 추가하려고 했기 때문이다.<br>\n제네릭의 불공변 때문에 <code class=\"language-text\">Integer</code>와 <code class=\"language-text\">Number</code>는 다르다.</p>\n<p>이제 이를 와일드카드로 해결해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">popAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        c<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>드디어 <code class=\"language-text\">Collection&lt;Number></code> 타입도 파라미터로 전달할 수 있게 됐다.<br>\n참고로 매개변수가 제네릭 클래스의 값을 <strong>소비</strong>하고 있다.</p>\n<br>\n<p>이처럼 제네릭 메서드의 유연함을 강화하기 위해 PECS는 탄생했다.<br>\n생산자는 <code class=\"language-text\">extends</code>, 소비자는 <code class=\"language-text\">super</code>를 사용한다.<br>\n메서드 <strong>매개변수가 제네릭 클래스에 값을 생산하면 생산자</strong>.<br>\n메서드 <strong>매개변수가 제네릭 클래스의 값을 소비하면 소비자</strong>라는 의미로 이름을 붙인다.</p>\n<p>처음 생산자, 소비자 단어를 접하면 한번에 이해가 잘 되지 않을 수 있다.<br>\n이럴 땐 파라미터 관점에서 제네릭 클래스의 값을 생산하거나 소비하는 관점으로 보면 조금은 와닿을 수 있다.</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">들어가며</a></p>\n</li>\n<li>\n<p><a href=\"#1-%EA%B3%B5%EB%B3%80%EA%B3%BC-%EB%B6%88%EA%B3%B5%EB%B3%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%8B%A4%EC%B2%B4%ED%99%94\">1. 공변과 불공변, 그리고 실체화</a></p>\n<ul>\n<li><a href=\"#1-1-%EA%B3%B5%EB%B3%80%EA%B3%BC-%EB%B6%88%EA%B3%B5%EB%B3%80\">1-1. 공변과 불공변</a></li>\n<li><a href=\"#1-2-%EC%8B%A4%EC%B2%B4%ED%99%94\">1-2. 실체화</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-%EC%B0%A8%EC%9D%B4\">2. 패러다임 차이</a></p>\n<ul>\n<li><a href=\"#2-1-%EB%A7%8C%EC%95%BD-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4%EB%A9%B4\">2-1. 만약 제네릭 배열의 생성이 가능하다면</a></li>\n<li><a href=\"#2-2-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%84%A0%EC%96%B8%EC%9D%80-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\">2-2. 제네릭 배열의 선언은 가능하다?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-pecs\">3. PECS</a></p>\n<ul>\n<li><a href=\"#3-1-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9D%80-%EB%B6%88%EA%B3%B5%EB%B3%80%ED%95%98%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%9D%B4%EB%8B%A4\">3-1. 제네릭은 불공변하기 때문이다</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[Java] 배열의 공변, 제네릭의 불공변. 그리고 PECS","date":"2024년 4월 23일","description":"공변, 불공변. 그리고 PECS에 대해 알아보자","tags":["java","공변, 불공변","PECS"]}},"previous":{"fields":{"slug":"/java/understanding-generic/"},"frontmatter":{"title":"[Java] 제네릭 이해하기"}},"next":{"fields":{"slug":"/docker/commands-of-docker/"},"frontmatter":{"title":"[Docker] 도커의 기본적인 명령어들"}}},"pageContext":{"id":"fe3b3569-8de0-593a-8cdf-fe581780235a","previousPostId":"d51f2628-0302-510c-a9ca-bee74d49f0ba","nextPostId":"c8b7ae13-f5b7-5aa6-ac41-797fe0aa582e"}},"staticQueryHashes":["1475414628","2841359383"],"slicesMap":{}}