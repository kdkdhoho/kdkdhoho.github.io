{"componentChunkName":"component---src-templates-post-jsx","path":"/about-tdd/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"91a7a622-00f8-5cca-b6c1-e4f7db7ee31e","excerpt":"TDD란? Test Driven Development. 테스트 주도 개발이다. 보통 '~~ 주도 개발' 이라고 이름이 붙으면, 개발할 때 '~~' 를 1순위로 여기며 개발하는 방법론을 의미한다. 즉, 테스트 주도 개발은 테스트를 1순위로 여기며 개발하는 개발 방법론이다. 개발 방법론! 어떻게 하나? 결론: 테스트 코드 작성 -> 프로덕션 코드 작성 -> …","html":"<h2>TDD란?</h2>\n<p>Test Driven Development. 테스트 주도 개발이다.</p>\n<p>보통 '<em>~~ 주도 개발</em>' 이라고 이름이 붙으면, 개발할 때 '<em>~~</em>' 를 1순위로 여기며 개발하는 <strong>방법론</strong>을 의미한다.</p>\n<p>즉, 테스트 주도 개발은 테스트를 1순위로 여기며 개발하는 <strong>개발 방법론</strong>이다.</p>\n<p><strong>개발 방법론!</strong></p>\n<h2>어떻게 하나?</h2>\n<p>결론: <em>테스트 코드 작성 -> 프로덕션 코드 작성 -> 리팩터링</em> 순으로 진행한다.</p>\n<h3>1. 테스트 코드 작성</h3>\n<p>우선 구현하려는 기능에 대해 단위 테스트를 작성한다.</p>\n<p>작성하고 돌리면 당연히 실패한다. 왜? 아직 프로덕션 코드가 없으니까.<br>\n어쩌면 컴파일 조차 안될 것이다.</p>\n<h3>2. 프로덕션 코드 작성</h3>\n<p>이제 기능을 구현한다.</p>\n<p>테스트 코드와 프로덕션 코드를 이상없이 작성했다면 테스트가 통과할 것이다.</p>\n<p>이때 중요한 점은, 코드 품질은 신경쓰지 않아도 된다.</p>\n<h3>3. 리팩터링</h3>\n<p>코드 품질은 이제 신경쓴다.</p>\n<p>돌아가는 쓰레기를 만들었다면, 이제 이쁜 쓰레기로 만들 차례이다.</p>\n<p>테스트 코드, 프로덕션 코드 모두 리팩터링을 진행한다.</p>\n<h2>왜 하나?</h2>\n<p>TDD를 해본 경험으로 이야기하자면, 버그가 생길 확률이 현저하게 떨어진다. <br>\n(높은 테스트 커버리지는 덤)</p>\n<p>확실히 테스트 코드로 내가 구현하려는 기능에 대해 확실한 <strong>안전 장치</strong>를 걸고 기능을 추가하니까, 아무래도 안전하다.</p>\n<p>구현하려는 기능에 대한 도메인 이해도가 어느 정도 있고, 주어진 시간이 충분하다면 나는 TDD를 가급적 할 것이다.</p>\n<p>주변 지인들에게도 추천할 것이다.</p>\n<h2>단점은?</h2>\n<p>기능을 작성하는 데까지 시간이 오래 걸린다.</p>\n<p>아무래도 돌다리르 건널 때 두들겨보고 건너는 개념인데, 이 두들기는 시간이 상당하다.</p>\n<p>체감 상 바로 프로덕션 코드를 작성할 때에 비해 2~3배는 걸리는 것 같다.</p>\n<p>또, 내가 구현하려는 기능에 대해 설계 방법이나 감이 잘 오지 않거나 개발 초기 단계라서 변화가 매우 빠른 상황이라면 나는 비추한다.</p>\n<p>TDD는 테스트 코드를 필연적으로 낳게 되는데, 이 테스트 코드는 위 상황에서는 걸림돌이기 때문이다.</p>\n<p>TDD는 개발 <strong>방법론</strong>일 뿐이니 너무 맹신하지말자.</p>\n<p>무엇이든 <strong>상황에 맞게 판단</strong>하자.</p>\n<h2>착각하기 쉬운 것</h2>\n<p>프로젝트에 TDD를 적용한다고 했을 때, 항상 모든 기능에 대해 테스트 코드를 먼저 작성할 수 없다.</p>\n<p>물론 구현하려는 기능에 대해 분명하고 확실한 상황이라면 TDD를 적용할 수 있지만, 개발이라는 게 처음 생각한대로 구현하다보면 생각지도 못한 기능을 함께 구현해야 하는 경우가 종종 있다.</p>\n<p>따라서 TDD를 처음 시도해보려는 사람들이 혹여나 \"테스트 코드를 먼저 작성하기 전까지는 기능 구현 안할거야 !!\" 라는 생각을 가질 수 있다고 생각한다.</p>\n<p>본인이 구현하려는 기능이 무엇인지 분명히 아는 선에서, TDD를 적용하는 것이 바람직해보인다.  </p>","frontmatter":{"title":"TDD 이해하기","date":"November 29, 2023","update":null,"tags":["tdd","test"],"series":null},"fields":{"slug":"/about-tdd/","readingTime":{"minutes":4.55}}},"seriesList":{"edges":[{"node":{"id":"a30ff988-ea74-5562-b241-90fbff73a3da","fields":{"slug":"/kissoft-retrospection/"},"frontmatter":{"title":"키스소프트 현장실습 회고"}}},{"node":{"id":"aedd8f5b-dd45-5a14-9b57-3a48cdc0b641","fields":{"slug":"/what-is-varargs/"},"frontmatter":{"title":"[Java] Varargs는 어떻게 사용하고, 사용했을 때 장점이 무엇일까?"}}},{"node":{"id":"2a63e82d-51b3-5863-abf9-e4e143e48688","fields":{"slug":"/https/"},"frontmatter":{"title":"[셀럽잇] HTTPS 적용기"}}},{"node":{"id":"3b94cbd6-f64a-5d82-96a2-0761602c250b","fields":{"slug":"/dbcp/"},"frontmatter":{"title":"DBCP와 HikariCP 이해하기"}}},{"node":{"id":"c418073e-50be-5fe1-807d-478c9c47f640","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"무중단 배포 이해하기"}}},{"node":{"id":"c5760ea9-e137-5edf-8244-3a93e25b067b","fields":{"slug":"/unit-test/"},"frontmatter":{"title":"단위 테스트 이해하기"}}},{"node":{"id":"8ae82b3f-5b72-555c-89fe-9939dcf8377c","fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"title":"JUnit과 AssertJ 활용법"}}},{"node":{"id":"91a7a622-00f8-5cca-b6c1-e4f7db7ee31e","fields":{"slug":"/about-tdd/"},"frontmatter":{"title":"TDD 이해하기"}}},{"node":{"id":"10e0dab4-d2e7-52df-8daa-31bfef1b08b6","fields":{"slug":"/static-with-memory-structure/"},"frontmatter":{"title":"static을 더 잘 사용하기"}}},{"node":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","fields":{"slug":"/about-garbage-collection/"},"frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리"}}},{"node":{"id":"0bf99b61-98a4-5c40-b8ce-05a918d212f7","fields":{"slug":"/garbage-collection-tuning/"},"frontmatter":{"title":"Garbage Collection 튜닝에 대해"}}},{"node":{"id":"61bd95c2-424a-54c8-96d9-bec4c8a4f58c","fields":{"slug":"/garbage-collection-algorithms/"},"frontmatter":{"title":"Garbage Collection 알고리즘"}}},{"node":{"id":"c87443bb-4e35-55e7-94d5-a5cb70d2dbc8","fields":{"slug":"/cautions-for-using-collections-in-Java/"},"frontmatter":{"title":"Java에서 컬렉션을 사용할 때 주의할 점"}}},{"node":{"id":"c2d7615d-6232-5fce-8794-f4c790106bb5","fields":{"slug":"/2023-retrospection/"},"frontmatter":{"title":"2023년 회고록"}}},{"node":{"id":"def28d41-907f-5432-8060-ed5429114882","fields":{"slug":"/compare-of-datetime-and-timestamp/"},"frontmatter":{"title":"[MySQL] DATETIME vs TIMESTAMP"}}},{"node":{"id":"9bf8ca89-e021-526b-a7b5-2cce0b1e366f","fields":{"slug":"/add-feat-and-issue-number-automatically/"},"frontmatter":{"title":"[git&github] IntelliJ에서 커밋 메시지 작성 시, 자동으로 커밋 타입과 이슈 번호 추가하기"}}},{"node":{"id":"01318426-7520-5a57-92ff-c917e1483247","fields":{"slug":"/difference-of-controller-and-restcontroller/"},"frontmatter":{"title":"[Spring] @Controller와 @RestController 비교하기"}}},{"node":{"id":"bc68fa05-ec4a-5e12-a9b8-4e58769887df","fields":{"slug":"/deploy-spring-boot-in-aws-ec2-manually/"},"frontmatter":{"title":"[Infra] AWS EC2에 Spring Boot 수작업으로 배포하기"}}},{"node":{"id":"122a1e9c-6fe5-5e7f-b797-a31f54d086b0","fields":{"slug":"/what-is-ami-architecture-of-ec2/"},"frontmatter":{"title":"CPU 아키텍처란?"}}},{"node":{"id":"c23a12ff-7b48-57ef-91ed-81f5386d680a","fields":{"slug":"/apply-issue-and-pr-template/"},"frontmatter":{"title":"[github] Github Repository에 Issue, PR Template 적용하기"}}},{"node":{"id":"b1dc584d-3c69-5ae8-82a8-09b015fa3d02","fields":{"slug":"/oauth-test/"},"frontmatter":{"title":"Spring Boot에서 Rest Assured로 인수 테스트할 때 OAuth 로그인 처리하기"}}},{"node":{"id":"9f43b8a7-b5ce-5766-b984-3ed0775d698f","fields":{"slug":"/ioc-container-and-di/"},"frontmatter":{"title":"[Spring] 스프링 컨테이너, 그리고 IoC/DI"}}},{"node":{"id":"e1b2a9fb-d6e3-5f65-9f50-d3a30c2518d1","fields":{"slug":"/what-is-jdbc/"},"frontmatter":{"title":"[Java] JDBC 마스터하기"}}},{"node":{"id":"81b7fb10-f532-5f48-a797-379c3bb99bee","fields":{"slug":"/understanding-transaction-and-concurrency-problem/"},"frontmatter":{"title":"[MySQL] 트랜잭션과 트랜잭션 격리 수준"}}},{"node":{"id":"5ecb4a12-dc98-589f-94e0-695fb2d84fab","fields":{"slug":"/restore-using-binarylog/"},"frontmatter":{"title":"[MySQL] 바이너리 로그로 데이터 복구하기"}}},{"node":{"id":"c375e6a2-7e6c-5607-a579-04d3ab5f3188","fields":{"slug":"/understanding-generic/"},"frontmatter":{"title":"[Java] 제네릭 이해하기"}}},{"node":{"id":"83ad74c1-0d46-5f86-92fc-998642e4367d","fields":{"slug":"/covariant-invariant-and-pecs/"},"frontmatter":{"title":"[Java] 배열의 공변, 제네릭의 불공변. 그리고 PECS"}}},{"node":{"id":"7b9b6854-62e7-5f25-afbf-d5459fa5d021","fields":{"slug":"/commands-of-docker/"},"frontmatter":{"title":"[Docker] 도커의 기본적인 명령어들"}}},{"node":{"id":"d77e8b24-f01d-5673-8c55-d93e2d110c4f","fields":{"slug":"/enhance-speed-ci-workflow/"},"frontmatter":{"title":"[Infra] Github Actions를 이용한 CI 작업 속도를 캐싱으로 개선하기"}}},{"node":{"id":"b4550a40-b215-5e9a-a6a7-8c27bfb63e25","fields":{"slug":"/continuous-deploy-using-github-actions-and-docker/"},"frontmatter":{"title":"[Infra] Github Actions와 Docker를 이용해 배포 자동화하기"}}}]},"previous":{"fields":{"slug":"/db-interview-study-2week/"},"frontmatter":{"title":"DB 면접 스터디 2주차"}},"next":{"fields":{"slug":"/os-interview-study-4week/"},"frontmatter":{"title":"[JSCODE] - OS 면접 스터디 4주차"}}},"pageContext":{"id":"91a7a622-00f8-5cca-b6c1-e4f7db7ee31e","series":null,"previousPostId":"d25aa4fc-f56a-5bf0-956a-040f1dc94491","nextPostId":"964be3af-4d8b-5d26-9b8f-9be8e7a34ad2"}},"staticQueryHashes":[],"slicesMap":{}}