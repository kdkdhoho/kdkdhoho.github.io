{"componentChunkName":"component---src-templates-post-jsx","path":"/about-tdd/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"6a5cce31-fad7-5c11-bd05-2e75410c5cd0","excerpt":"TDD란? Test Driven Development. 테스트 주도 개발이다. 보통 '~~ 주도 개발' 이라고 이름이 붙으면, 개발할 때 '~~' 를 1순위로 여기며 개발하는 방법론을 의미한다. 즉, 테스트 주도 개발은 테스트를 1순위로 여기며 개발하는 개발 방법론이다. 개발 방법론! 어떻게 하나? 결론: 테스트 코드 작성 -> 프로덕션 코드 작성 -> …","html":"<h2>TDD란?</h2>\n<p>Test Driven Development. 테스트 주도 개발이다.</p>\n<p>보통 '<em>~~ 주도 개발</em>' 이라고 이름이 붙으면, 개발할 때 '<em>~~</em>' 를 1순위로 여기며 개발하는 <strong>방법론</strong>을 의미한다.</p>\n<p>즉, 테스트 주도 개발은 테스트를 1순위로 여기며 개발하는 <strong>개발 방법론</strong>이다.</p>\n<p><strong>개발 방법론!</strong></p>\n<h2>어떻게 하나?</h2>\n<p>결론: <em>테스트 코드 작성 -> 프로덕션 코드 작성 -> 리팩터링</em> 순으로 진행한다.</p>\n<h3>1. 테스트 코드 작성</h3>\n<p>우선 구현하려는 기능에 대해 단위 테스트를 작성한다.</p>\n<p>작성하고 돌리면 당연히 실패한다. 왜? 아직 프로덕션 코드가 없으니까.<br>\n어쩌면 컴파일 조차 안될 것이다.</p>\n<h3>2. 프로덕션 코드 작성</h3>\n<p>이제 기능을 구현한다.</p>\n<p>테스트 코드와 프로덕션 코드를 이상없이 작성했다면 테스트가 통과할 것이다.</p>\n<p>이때 중요한 점은, 코드 품질은 신경쓰지 않아도 된다.</p>\n<h3>3. 리팩터링</h3>\n<p>코드 품질은 이제 신경쓴다.</p>\n<p>돌아가는 쓰레기를 만들었다면, 이제 이쁜 쓰레기로 만들 차례이다.</p>\n<p>테스트 코드, 프로덕션 코드 모두 리팩터링을 진행한다.</p>\n<h2>왜 하나?</h2>\n<p>TDD를 해본 경험으로 이야기하자면, 버그가 생길 확률이 현저하게 떨어진다. <br>\n(높은 테스트 커버리지는 덤)</p>\n<p>확실히 테스트 코드로 내가 구현하려는 기능에 대해 확실한 <strong>안전 장치</strong>를 걸고 기능을 추가하니까, 아무래도 안전하다.</p>\n<p>구현하려는 기능에 대한 도메인 이해도가 어느 정도 있고, 주어진 시간이 충분하다면 나는 TDD를 가급적 할 것이다.</p>\n<p>주변 지인들에게도 추천할 것이다.</p>\n<h2>단점은?</h2>\n<p>기능을 작성하는 데까지 시간이 오래 걸린다.</p>\n<p>아무래도 돌다리르 건널 때 두들겨보고 건너는 개념인데, 이 두들기는 시간이 상당하다.</p>\n<p>체감 상 바로 프로덕션 코드를 작성할 때에 비해 2~3배는 걸리는 것 같다.</p>\n<p>또, 내가 구현하려는 기능에 대해 설계 방법이나 감이 잘 오지 않거나 개발 초기 단계라서 변화가 매우 빠른 상황이라면 나는 비추한다.</p>\n<p>TDD는 테스트 코드를 필연적으로 낳게 되는데, 이 테스트 코드는 위 상황에서는 걸림돌이기 때문이다.</p>\n<p>TDD는 개발 <strong>방법론</strong>일 뿐이니 너무 맹신하지말자.</p>\n<p>무엇이든 <strong>상황에 맞게 판단</strong>하자.</p>","frontmatter":{"title":"TDD에 대해","date":"November 29, 2023","update":"November 29, 2023","tags":["tdd"],"series":null},"fields":{"slug":"/about-tdd/","readingTime":{"minutes":3.46}}},"seriesList":{"edges":[{"node":{"id":"15ca77a9-4e26-59d5-8c4a-94f6fbae3a07","fields":{"slug":"/unit-test/"},"frontmatter":{"title":"단위 테스트"}}},{"node":{"id":"89b57813-f839-5a4e-b503-545830aec1fb","fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"title":"JUnit과 AssertJ 활용법"}}},{"node":{"id":"6a5cce31-fad7-5c11-bd05-2e75410c5cd0","fields":{"slug":"/about-tdd/"},"frontmatter":{"title":"TDD에 대해"}}}]},"previous":{"fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"title":"JUnit과 AssertJ 활용법"}},"next":{"fields":{"slug":"/basic-kernel-IO/"},"frontmatter":{"title":"운영체제와 커널, 그리고 동기/비동기식 I/O"}}},"pageContext":{"id":"6a5cce31-fad7-5c11-bd05-2e75410c5cd0","series":null,"previousPostId":"89b57813-f839-5a4e-b503-545830aec1fb","nextPostId":"ff7e94b2-bfa0-580d-8cd2-0110411eecac"}},"staticQueryHashes":[],"slicesMap":{}}