{"componentChunkName":"component---src-templates-blog-post-js","path":"/JAVA/garbage-collection/about-garbage-collection/","result":{"data":{"site":{"siteMetadata":{"title":"김동호의 기록"}},"markdownRemark":{"id":"ce8ebc36-3264-502a-9939-dfcbb6e24d31","excerpt":"Garbage Collection를 알아야 하는 이유 Garbage Collection(이하 GC)을 공부하다보니, GC를 너무 믿어서는 안되겠다고 생각됐다.\n우형에서 발생한 일도 그렇고 토스에서 발생한 일을 보니 모두 애플리케이션의 메모리 관련 치명적 에러는 모두 이 GC…","html":"<h2 id=\"garbage-collection를-알아야-하는-이유\" style=\"position:relative;\"><a href=\"#garbage-collection%EB%A5%BC-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"garbage collection를 알아야 하는 이유 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collection를 알아야 하는 이유</h2>\n<p>Garbage Collection(이하 GC)을 공부하다보니, GC를 너무 믿어서는 안되겠다고 생각됐다.<br>\n<a href=\"https://techblog.woowahan.com/2628/\">우형에서 발생한 일</a>도 그렇고 <a href=\"https://www.youtube.com/watch?v=w4fWgLgop5U\">토스에서 발생한 일</a>을 보니 모두 애플리케이션의 메모리 관련 치명적 에러는 모두 이 <em>GC</em>와 관련이 있었기 때문이다.<br>\n더군다나 <a href=\"https://d2.naver.com/helloworld/1329\">네이버 D2 글</a>에서도 <strong>GC에 대해 잘 알고 있을수록 실력이 좋은 Java 개발자</strong>라고 했다.</p>\n<p>실력이 좋은 Java 개발자가 되기 위해 이 GC에 대해 알아보자.</p>\n<h2 id=\"gc란\" style=\"position:relative;\"><a href=\"#gc%EB%9E%80\" aria-label=\"gc란 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC란?</h2>\n<p>Garbage Collection(이하 GC)은 <strong>JVM 기반 애플리케이션에서 동적으로 할당되는 메모리 공간을 알아서 관리해주는 기술</strong>이다.</p>\n<blockquote>\n<p>JVM의 메모리 구조는 <a href=\"https://kdkdhoho.github.io/static-with-memory-structure/\">static을 더 잘 사용하기</a> 글을 참고</p>\n</blockquote>\n<p>프로세스는 필연적으로 새로운 데이터를 Heap 영역에 malloc(할당) 및 free(해제) 하게 된다.<br>\nC나 C++의 경우 데이터가 저장된 메모리 공간을 직접 관리해야 한다.<br>\n하지만 Java는 탄생 배경부터 개발자가 운영체제에 직접 의존하지 않아도 되도록 중간 계층인 <strong>JVM을 통해 시스템 자원에 접근</strong>하게 된다.<br>\n따라서 JVM이 메모리 공간이 할당되었지만 더이상 사용되지 않아 필요없어진 메모리를 대신 처리해주는 역할을 수행하는 것이다.<br>\n그 작업을 우리는 GC 라고 부르는 것이다.</p>\n<h2 id=\"gc의-특징\" style=\"position:relative;\"><a href=\"#gc%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"gc의 특징 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC의 특징</h2>\n<p>GC로 인해 <strong>개발자는 직접 메모리 공간을 관리할 필요가 없어진다</strong>.<br>\n즉, 개발자는 개발에만 집중할 수 있게 된다.<br>\n또한 완벽하진 않지만 GC 덕분에 (완벽하진 않지만) Memory Leak 을 예방할 수 있다.</p>\n<p>하지만, 그만큼 희생도 따르는 법.<br>\nGC가 메모리 공간을 청소할 때 ❗️ <strong>STOP THE WORLD</strong> ❗현상이 발생한다.<br>\nStop the world는 <strong>GC 쓰레드가 동작하는 순간에, 다른 쓰레드들은 동작하지 않는 현상</strong>이다.<br></p>\n<blockquote>\n<p>참고) GC를 튜닝한다는 말은 주로 이 Stop the world 시간이 짧아지도록 한다는 말이다.<br>\n<a href=\"https://d2.naver.com/helloworld/37111\">Naver D2 - Garbage Collection 튜닝</a></p>\n</blockquote>\n<h2 id=\"gc의-기본-동작-원리\" style=\"position:relative;\"><a href=\"#gc%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\" aria-label=\"gc의 기본 동작 원리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC의 기본 동작 원리</h2>\n<p>GC는 다양한 알고리즘이 존재한다.<br>\n하지만 뒤에 나올 ZGC를 제외한 모든 알고리즘은 <strong>Generational Collection</strong>이라는 기술을 사용한다.<br>\nGenerational Collection은 대부분의 애플리케이션에서 경험적으로 관찰된 몇 가지 속성을 활용하여 탄생한 알고리즘이다.<br>   , 하는 기술이다.</p>\n<p>관찰된 몇 가지 속성 중 가장 핵심이 되는 개념은 <strong>Weak Generational Hypothesis</strong>이다.<br>\nWeak Generational Hypothesis이란 <strong>대부분의 객체는 잠깐 동안만 필요하다는 가설</strong>이다.<br>\n아래 그림은 객체의 평균 생명주기 분포도를 나타낸 그래프다. X축은 객체가 할당된 시간, Y축은 객체가 할당된 정도이다.<br>\n그래프를 해석해보면 <strong>애플리케이션에서 수명이 짧은 객체들이 훨씬 많이 분포한다</strong>는 의미이다.<br>\n오라클 문서에서도 \"<em>왼쪽의 날카로운 피크는 할당된 직후 회수할 수 있는(즉, \"소멸된\") 객체를 나타냅니다.</em>\" 라고 표현한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 543px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0571b10c68e420d95dcf22e0b9c6bb36/29579/distribution_for_lifetimes_of_objects.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.82278481012659%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXUlEQVR42q2TWW+CQBSF+f8/pbW+9KkvTZMuBlCpqW1tY4oLgwzbALI0CpzOYFCCfZOTnFy4w3ycm8xI+/0eRVFCiBACwzCg6zoopahVlof1MAyxXC6xWCyqKvY2Jb6TttsYQZwhz/PKRVFUrt/bqtfaEjDxA4l6AUZznqYseOMEFbWdoAb+1z8C15aHl29HtLDvIqFpM8hzt0rYycjE9jEQCcXIeQcjC+Dzl9NtwqcGML8UqBsWHmf2KeGlIw9UDfcfNnJ+ZFj8C+IlSLJdBdzxnjjTR9fARsKyDRy9vqGnmrjVNrhWTFypFu6mDmIOLfnm8yTnI5dNoDwcoz800VMI+irBjbJGT17j4d2E9mNjuvIxM1jllROB+hFWdgDKYtjcOg3wafiI+G3LsgxSkqSQhxrU8QTKaAKTunBZBMsNQBwGk3vDn4XFrXK8kFcGxw+5A9jeoc/CCGma4g/qwu+fhJcGiQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"객체 생명주기 평균 분포도 출처: https://docs.oracle.com/en/java/javase/16/gctuning/garbage-collector-implementation.html\"\n        title=\"\"\n        src=\"/static/0571b10c68e420d95dcf22e0b9c6bb36/29579/distribution_for_lifetimes_of_objects.png\"\n        srcset=\"/static/0571b10c68e420d95dcf22e0b9c6bb36/c26ae/distribution_for_lifetimes_of_objects.png 158w,\n/static/0571b10c68e420d95dcf22e0b9c6bb36/6bdcf/distribution_for_lifetimes_of_objects.png 315w,\n/static/0571b10c68e420d95dcf22e0b9c6bb36/29579/distribution_for_lifetimes_of_objects.png 543w\"\n        sizes=\"(max-width: 543px) 100vw, 543px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>즉, 이러한 경험적 관찰 결과를 바탕으로 Heap 영역에 있는 모든 객체에 대해 검사하지 않고 객체의 수명에 기반한 Collecting을 수행한다.<br>\n결과적으로 사용하지 않는 객체를 회수하는 데에 필요한 작업을 최소화하였고, ZGC를 제외한 모든 GC 알고리즘이 Generational Collection 기술을 채택한 것이다.</p>\n<p>그렇다면 이 객체가 할당된 세대, 혹은 나이는 어떻게 측정할까?<br>\n객체의 나이를 측정하기 위한 메모리 공간은 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/773b890738e3964e0bc8cd9c2db8b217/7f664/default_arrangement_of_generations_int_the_serial_collector.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.21518987341772%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABRUlEQVR42mXQSU/CYBSF4f5hf4JLFyYuCEvjFDUOSMKQgoADCqEgEgKKBQSJQkQrIl8LZbAtrw1uTFw8ubk5OZsjzaxvZraF7dg4cwfLvb8s97fRPvv0vgT9gb6gD0267xrNVgvDnCAME31kMnQNhI50mo2TrxZof3Qot+5INxRStQzlbgVhDdiJKqzsnbMp5zhJlojf1rlRX1CfNQK5BvKdRq4laH6Y9IczJM+ul8BVmMJjETkT5VDxs53Y5UK95tPpsXacYMkTZPXgkvVwFl+yTCJfR3lo4/El2c+2uah/cf86pCumSFuhHQ4SR4TTMpF8jGBJJlSMkGoqqJqK1x9jeT2yKG+EMxydFQily0SVCr6USrDQ4bzyRv6pR70rkAZCMDJHjMdj3rR31FoVY2QwmU7QDd3NTHdfd1vb/sdx5ovsrx8iIWChFe4hGAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Serial GC의 기본적인 메모리 공간\"\n        title=\"\"\n        src=\"/static/773b890738e3964e0bc8cd9c2db8b217/7f664/default_arrangement_of_generations_int_the_serial_collector.png\"\n        srcset=\"/static/773b890738e3964e0bc8cd9c2db8b217/c26ae/default_arrangement_of_generations_int_the_serial_collector.png 158w,\n/static/773b890738e3964e0bc8cd9c2db8b217/6bdcf/default_arrangement_of_generations_int_the_serial_collector.png 315w,\n/static/773b890738e3964e0bc8cd9c2db8b217/7f664/default_arrangement_of_generations_int_the_serial_collector.png 456w\"\n        sizes=\"(max-width: 456px) 100vw, 456px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>자세히 살펴보면 Young, Old로 크게 한번 나뉜다.<br>\n이름에서 유추할 수 있듯이 상대적으로 젊은 객체는 Young, 늙은 객체는 Old에 저장된다.</p>\n<p>Old는 뭐가 없어 보인다. Young 영역을 자세히 살펴보자.<br>\n1개의 Eden과 2개의 Survivor, 그리고 1개의 Virtual 공간이 보인다.<br></p>\n<p>각 영역 별 특징으로는 다음과 같다.</p>\n<ol>\n<li><strong>Eden 영역에는 처음 생성되는 대부분의 객체가 저장된다.</strong></li>\n<li><strong>Survivor 영역 중 적어도 하나는 항상 비어있다.</strong></li>\n</ol>\n<br>\n<br>\n<p>이 구조를 기반으로 나이를 증가하는 과정은 다음과 같다.</p>\n<ol>\n<li>처음 생성된 객체는 Eden 영역에 차곡차곡 쌓인다.</li>\n<li>쌓이다가 결국 공간이 꽉 차면 이때 Eden에 존재하는 객체 중, 필요있을만한 객체를 모두 Survivor 영역으로 이동한다.</li>\n<li>이때, <strong>이동하는 객체에 나이를 증가시킨다.</strong></li>\n<li>마찬가지로 Survivor 영역도 모두 차게 되면, 필요있을만한 객체만이 반대편의 Survivor 영역으로 이동한다. 이때에도 마찬가지로 나이를 증가시킨다.</li>\n</ol>\n<h3 id=\"요약\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<p>이제, 위 정보를 토대로 GC의 전체적인 동작 방식을 정리해보자.</p>\n<ol>\n<li>Eden 혹은 Survivor 영역이 모두 차면 Young Generation 영역만 수집하는 <strong>Minor Collection</strong>이 발생한다.<br>\n(적은 양의 객체만 참조하기에 Minor Collection은 비교적 빠르게 수행된다.)</li>\n<li>Minor Collection이 진행되면서 특정 나이가 된 객체는 Old 영역으로 이동한다.</li>\n<li>진행되다 보면 Old Generation이 모두 차게 된다. 이때는 전체 영역을 Collecting하는 <strong>Major Collection</strong>이 발생한다.<br>\n(전체 객체를 확인해야 하기에 Minor에 비해 상당한 시간이 걸린다.)</li>\n</ol>\n<h2 id=\"이어서\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%96%B4%EC%84%9C\" aria-label=\"이어서 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이어서</h2>\n<p>다음으로는 GC 알고리즘의 종류와 각 특징에 대해 알아보자.</p>\n<blockquote>\n<h3 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.65 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h3>\n<ul>\n<li><a href=\"https://youtu.be/FMUpVA0Vvjw?feature=shared\">https://youtu.be/FMUpVA0Vvjw?feature=shared</a> <br></li>\n<li><a href=\"https://youtu.be/vZRmCbl871I?feature=shared\">https://youtu.be/vZRmCbl871I?feature=shared</a> <br></li>\n<li><a href=\"https://mangkyu.tistory.com/118\">https://mangkyu.tistory.com/118</a> <br></li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-45794DA6-AB96-4856-A96D-FDE5F7DEE498\">https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-45794DA6-AB96-4856-A96D-FDE5F7DEE498</a> <br></li>\n<li><a href=\"https://stackoverflow.com/questions/70664562/criteria-for-default-garbage-collector-hotspot-jvm-11-17\">https://stackoverflow.com/questions/70664562/criteria-for-default-garbage-collector-hotspot-jvm-11-17</a> <br></li>\n<li><a href=\"https://medium.com/javarevisited/java-17-vs-java-11-exploring-the-latest-features-and-improvements-6d13290e4e1a\">https://medium.com/javarevisited/java-17-vs-java-11-exploring-the-latest-features-and-improvements-6d13290e4e1a</a> <br></li>\n<li><a href=\"https://www.optaplanner.org/blog/2021/09/15/HowMuchFasterIsJava17.html\">https://www.optaplanner.org/blog/2021/09/15/HowMuchFasterIsJava17.html</a> <br></li>\n<li><a href=\"https://www.baeldung.com/jvm-garbage-collectors\">https://www.baeldung.com/jvm-garbage-collectors</a> <br></li>\n</ul>\n</blockquote>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#garbage-collection%EB%A5%BC-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">Garbage Collection를 알아야 하는 이유</a></p>\n</li>\n<li>\n<p><a href=\"#gc%EB%9E%80\">GC란?</a></p>\n</li>\n<li>\n<p><a href=\"#gc%EC%9D%98-%ED%8A%B9%EC%A7%95\">GC의 특징</a></p>\n</li>\n<li>\n<p><a href=\"#gc%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\">GC의 기본 동작 원리</a></p>\n<ul>\n<li><a href=\"#%EC%9A%94%EC%95%BD\">요약</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%96%B4%EC%84%9C\">이어서</a></p>\n</li>\n</ul>","frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리","date":"2023년 12월 8일","description":"드디어 정리한다. Garbage Collection","tags":["JAVA","garbage-collection"],"series":null}},"previous":{"fields":{"slug":"/회고/운영체제-인터뷰-스터디-회고/"},"frontmatter":{"title":"[JSCODE] - OS 면접 스터디 회고록"}},"next":{"fields":{"slug":"/JAVA/garbage-collection/garbage-collection-tuning/"},"frontmatter":{"title":"Garbage Collection 튜닝에 대해"}}},"pageContext":{"id":"ce8ebc36-3264-502a-9939-dfcbb6e24d31","previousPostId":"1815f5bd-6490-577c-b7d6-8168df724268","nextPostId":"97132547-e3a4-5f9c-a3ab-1f79786a5b69"}},"staticQueryHashes":["1475414628","2841359383"],"slicesMap":{}}