{"componentChunkName":"component---src-templates-post-jsx","path":"/10-web-attacks/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"b78b4291-fdd7-58a7-af5a-12a262962280","excerpt":"이번 장에서는 웹 애플리케이션을 공격하는 기술들에 대해 알아본다. 1. 공격 패턴의 종류 공격의 종류는 크게 두 가지로 나눌 수 있다. 1-1. 능동적 공격 능동적 공격은 공격자가 직접 웹 애플리케이션에 공격을 시도하여 서버의 리소스를 탈취하려는 방식이다. 대표적인 예로 SQL 인젝션, OS 커맨드 인젝션, 디도스 등이 있다. 1-2. 수동적 공격 수동적…","html":"<p>이번 장에서는 <strong>웹 애플리케이션을 공격하는 기술</strong>들에 대해 알아본다.</p>\n<h2>1. 공격 패턴의 종류</h2>\n<p>공격의 종류는 크게 두 가지로 나눌 수 있다.</p>\n<h3>1-1. 능동적 공격</h3>\n<p><strong>능동적 공격</strong>은 <strong>공격자가 직접 웹 애플리케이션에 공격을 시도하여 서버의 리소스를 탈취하려는 방식</strong>이다.</p>\n<p>대표적인 예로 <em>SQL 인젝션</em>, <em>OS 커맨드 인젝션</em>, <em>디도스</em> 등이 있다.</p>\n<h3>1-2. 수동적 공격</h3>\n<p><strong>수동적 공격</strong>은 <strong>일반 사용자에게 공격 코드를 실행하도록 유도</strong>하는 공격 방식이다.</p>\n<p>대표적인 예로 <em>XSS(Cross-Site Scripting)</em>, <em>CSRF(Cross Site Request Forgery)</em> 등이 있다.</p>\n<h2>2. 여러 공격 패턴 이해하기</h2>\n<h3>2-1. SQL 인젝션</h3>\n<p><strong>SQL 인젝션</strong>이란 <strong>비정상적인 요청을 보냄으로써 웹 애플리케이션이 의도하지 않은 SQL을 요청하도록 의도하는 능동적 공격</strong>이다.</p>\n<p>데이터베이스에 직접 접근하기 떄문에 개인 정보 유출이나 테이블 삭제 등 서비스 운영에 크리티컬한 문제가 발생할 수 있는 공격 중 하나다.</p>\n<p>예를 들어, 사용자의 아이디와 비밀번호를 요청으로부터 입력받아 DB에 존재하는지 판별하는 SQL문을 작성했다고 가정해보자.<br></p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span>${id} <span class=\"token operator\">AND</span> password<span class=\"token operator\">=</span>${password}<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이때, password에 대한 입력값으로 <code class=\"language-text\">' OR '1'='1;</code> 이 들어오면 쿼리는 아래와 같이 완성될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token string\">'kdkdhoho'</span> <span class=\"token operator\">AND</span> password<span class=\"token operator\">=</span><span class=\"token string\">''</span> <span class=\"token operator\">OR</span> <span class=\"token string\">'1'</span><span class=\"token operator\">=</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">OR '1'='1'</code> 이라는 조건문 때문에 해당 쿼리는 비밀번호를 입력하지 않아도 <strong>kdkdhoho 계정에 대한 로그인이 성공</strong>하게 된다.</p>\n<p>SQL 인젝션을 방지하기 위해 <strong>입력값이 의도한 데이터 형식인지 체크</strong>하거나 <strong>입력값을 DB에 해싱하여 암호화한 다음 저장</strong>하는 노력 등을 수행할 수 있다.</p>\n<h3>2-2. HTTP 헤더 인젝션</h3>\n<p>HTTP 헤더 인젝션은 <strong>공격자가 HTTP 응답 헤더 필드에 개행 문자 등을 삽입함으로써 임의의 응답 헤더나 바디를 추가하는 수동적 공격</strong>이다.</p>\n<p>만약 아래와 같은 HTTP Response가 있다고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">Location: http://www.example.com/a.cgi?q=12345\nSet-Cookie: JSESSIONID=12345</code></pre></div>\n<p>위 응답을 이용해 공격자는 다음 요청에 아래와 같이 <code class=\"language-text\">Location</code> 헤더를 고쳐 요청을 보내면</p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">Location: http://www.example.com/a.cgi?q=12345%0D%0ASet-Cookie:+SID=123456789</code></pre></div>\n<p>요청에 대한 응답으로 아래와 같은 HTTP 메시지가 응답된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">Location: http://www.example.com/a.cgi?q=12345%0D%0ASet-Cookie:+SID=123456789\nSet-Cookie: SID=123456789</code></pre></div>\n<p>왜냐하면 <code class=\"language-text\">%0D%0A</code>는 HTTP 메시지의 개행 문자를 의미한다.<br>\n따라서 <code class=\"language-text\">%0D%0A</code> 뒤에 있는 <code class=\"language-text\">Set-Cookie:+SID=123456789</code> 가 서버가 만들어 낸 <code class=\"language-text\">Set-Cookie</code> 헤더를 덮어 씌워 응답으 보내게 된다.<br>\n이런 방식을 <em>세션 픽세이션</em> 이라고 한다.</p>\n<p>위 방식처럼 HTTP 헤더 또는 바디에 공격자가 부적절한 값을 추가하여 웹 애플리케이션으로의 요청과 응답을 의도하는 대로 동작할 수 있다.</p>\n<h3>2-3. DoS 공격</h3>\n<p>DoS (Denial of Service attack)은 대량의 액세스를 특정 호스트에 집중하여 보내어 서비스 제공을 정지 상태로 만드는 공격이다.<br>\nDoS 공격은 웹 서버 뿐만 아니라, 네트워크 기기나 서버 등을 대상으로 공격하는 경우도 있다.</p>\n<p>특히, DDoS 공격은 여러 대의 컴퓨터에서 요청을 보내는 방식을 의미한다.</p>\n<h3>2-4. XSS(Cross-Site Scripting)</h3>\n<p>XSS는 동적으로 HTML을 생성하는 부분에서 발생하는 취약점을 이용하는 공격 방식이다.<br>\n종류로는 <em>Stored XSS</em> 와 <em>Reflection XSS</em> 가 있다.<br>\n두 XSS 모두 공격자가 심어놓은 스크립트를 사용자가 의도하지 않아도 실행되도록 유도하는 방식이다.</p>\n<h4>2-4-1. Stored XSS</h4>\n<p>댓글이나 게시글에 글을 작성할 떄, HTML 태그를 본문에 넣어 요청을 보내면 서버는 본문 자체를 저장한다.<br>\n이때, 해당 게시글을 조회하는 모든 사용자는 공격자가 심어놓은 스크립트를 읽거나 수행하게 된다. </p>\n<p>실제로 2011년 네이버 웹툰 댓글에 <code class=\"language-text\">&lt;img></code> 태그를 삽입함으로써 이미지 테러가 발생한 사례가 있다. [<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>]\n<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>: <a href=\"https://www.dogdrip.net/554409611\">네이버 웹툰 댓글에서 이미지 첨부가 안되는 이유</a></p>\n<h4>2-4-2. Reflection XSS</h4>\n<p>공격자가 악의적인 스크립트를 URL에 담아 공유한다.<br>\n해당 URL을 누르게 되면, 브라우저는 스크립트를 수행하게 된다.<br>\nURL은 정상적인 사이트처럼 보이는 피싱 사이트이거나 사용자의 정보를 공격자에게 전송하는 URL 일 수 있다.</p>\n<p>XSS가 어떤 식으로 수행되는지 직접 보고 싶다면 <a href=\"https://youtu.be/bSGqBoZd8WM?feature=shared\">10분 테코톡 - 알트의 XSS</a> 영상을 참고해보자.<br></p>\n<h4>2-4-3. XSS 방어하기</h4>\n<ol>\n<li>innerHTML을 사용하지 못하도록 한다.</li>\n<li>입력값으로 특수문자를 입력하지 못하도록 한다. (또는 정해진 형식으로만 입력하도록 강제한다.)</li>\n<li>입력값의 특수문자를 문자열로 치환한다.</li>\n<li>Cookie의 <em>httpOnly</em>, <em>Secure</em> 속성을 사용하여 JS로 Cookie에 접근하지 못하도록 막는다.</li>\n</ol>\n<h3>2-5. CSRF(Cross Site Request Forgery)</h3>\n<p>CSRF는 <strong>특정 웹사이트에 인증된 상태의 유저가 의도하지 않은 요청을 보내도록 하는 수동적 공격</strong>이다.</p>\n<p>실제 사례로, 2008년 옥션에서 CSRF 공격으로 1,800만 명의 개인정보가 유출된 사례가 있다.<br>\n공격 시나리오는 다음과 같다.</p>\n<ol>\n<li>해커는 <code class=\"language-text\">&lt;img src=\"http://action.com/changeUserAccount?id=admin%password=admin width=\"0\" height=\"0\"></code> 태그가 들어간 이메일을 보낸다.</li>\n<li>옥션 내부 관리자는 관리자 권한으로 로그인을 한 상태에서 해당 이메일을 클릭한다.</li>\n<li>이때, 이미지를 받아오기 위해 URL이 열리게 되는데 <code class=\"language-text\">src</code>에 담긴 요청으로 관리자 계정의 아이디와 비밀번호가 모두 해커가 의도한 값으로 변경된다.</li>\n</ol>\n<h4>2-5-1. CSRF 방어하기</h4>\n<p>사용자는 이상한 URL을 함부로 클릭하지 않는다.</p>\n<p>서버는 HTTP Request에 담긴 <code class=\"language-text\">Host</code>와 <code class=\"language-text\">Referer</code> 헤더 값을 비교한다.<br>\n만약 정상적인 요청이라면 두 헤더의 값은 일치할 것이다.<br>\n하지만 CSRF에 의한 요청이라면 두 값은 달라지므로 이를 비교하여 검증하는 것만으로도 대부분의 CSRF 공격을 방어할 수 있다고 한다.</p>\n<h3>2-6. 부적절한 에러 메시지 처리로 인한 공격</h3>\n<p>웹 애플리케이션이 처리한 에러 메시지로 인해 현재 접근이 어떤 문제를 가지고 있는지 힌트를 주는 경우가 있다.</p>\n<p>가령, 로그인을 했는데 존재하지 않는 이메일이라거나<br>\n이럴 일은 없겠지만 입력한 비밀번호가 몇 글자 틀렸는지 알려주는 식의 에러 메시지는 공격자에게 너무 많은 힌트를 주게 되는 셈이다.</p>\n<p>또한 데이터베이스 등의 시스템에 의한 에러 메시지가 그대로 노출되는 경우에도 공격자에게 취약성을 알려주는 셈과 같다.</p>","frontmatter":{"title":"11장. 웹 공격 기술","date":"May 12, 2024","update":null,"tags":["Network"],"series":"그림으로 배우는 Http & Network Basic"},"fields":{"slug":"/10-web-attacks/","readingTime":{"minutes":9.485}}},"seriesList":{"edges":[{"node":{"id":"a4d71417-67f6-5df5-a92a-fe77cee2c152","fields":{"slug":"/01-comprehension-about-web-and-network-basic/"},"frontmatter":{"title":"1장. 웹과 네트워크의 기본에 대해 알아보자"}}},{"node":{"id":"b30f24d3-925d-5fec-8b29-6f6226b97cd6","fields":{"slug":"/02-http-protocol/"},"frontmatter":{"title":"2장. 간단한 프로토콜 HTTP"}}},{"node":{"id":"807f22e3-dcd4-554f-908e-19ffa9b29d8c","fields":{"slug":"/03-http-detail/"},"frontmatter":{"title":"3장. HTTP 정보는 HTTP 메시지에 있다"}}},{"node":{"id":"bd0818e6-a370-5bc9-96d5-ad7d10929267","fields":{"slug":"/04-http-status-code/"},"frontmatter":{"title":"4장. 결과를 전달하는 HTTP 상태 코드"}}},{"node":{"id":"e210085d-c6e8-5cce-81f0-c7773af272fa","fields":{"slug":"/05-web-server/"},"frontmatter":{"title":"5장. HTTP와 연계하는 웹서버"}}},{"node":{"id":"5b14ad06-606e-5537-be91-65ab1aa467e5","fields":{"slug":"/06-http-header/"},"frontmatter":{"title":"6장. HTTP 헤더"}}},{"node":{"id":"84076d04-c12f-5e3f-889d-67a2bc4a604f","fields":{"slug":"/07-https/"},"frontmatter":{"title":"7장. 웹을 안전하게 지켜주는 HTTPS"}}},{"node":{"id":"bcfa9a22-0d4a-5d68-a21f-2dc441452620","fields":{"slug":"/09-advanced-http-protocol/"},"frontmatter":{"title":"9장. HTTP에 기능을 추가한 프로토콜"}}},{"node":{"id":"91bb0215-8f87-5c05-b5e3-8c8b4e05a365","fields":{"slug":"/08-authentication-of-http/"},"frontmatter":{"title":"8장. 누가 액세스하고 있는지를 확인하는 인증"}}},{"node":{"id":"b78b4291-fdd7-58a7-af5a-12a262962280","fields":{"slug":"/10-web-attacks/"},"frontmatter":{"title":"11장. 웹 공격 기술"}}}]},"previous":{"fields":{"slug":"/commands-of-docker/"},"frontmatter":{"title":"[Docker] 도커의 기본적인 명령어들"}},"next":{"fields":{"slug":"/enhance-speed-ci-workflow/"},"frontmatter":{"title":"[Infra] Github Actions를 이용한 CI 작업 속도를 캐싱으로 개선하기"}}},"pageContext":{"id":"b78b4291-fdd7-58a7-af5a-12a262962280","series":"그림으로 배우는 Http & Network Basic","previousPostId":"7b9b6854-62e7-5f25-afbf-d5459fa5d021","nextPostId":"d77e8b24-f01d-5673-8c55-d93e2d110c4f"}},"staticQueryHashes":[],"slicesMap":{}}