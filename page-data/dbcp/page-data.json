{"componentChunkName":"component---src-templates-post-jsx","path":"/dbcp/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"3b94cbd6-f64a-5d82-96a2-0761602c250b","excerpt":"DBCP (DataBase Connection Pool) 탄생 배경 서버 애플리케이션에서 DB 서버로 요청을 보내면 TCP 통신을 한다. TCP 통신은 Connection이 유지되는 상태에서 통신한다. 이 Connection은 생성하고 사용하고 삭제되기까지 꽤 많은 작업이 포함된다. 즉, 통신 비용이 비싸다. 이러한 상황에서 서버는 많은 요청을 처리하는데…","html":"<h2>DBCP (DataBase Connection Pool) 탄생 배경</h2>\n<p>서버 애플리케이션에서 DB 서버로 요청을 보내면 TCP 통신을 한다.</p>\n<p>TCP 통신은 <strong>Connection</strong>이 유지되는 상태에서 통신한다.</p>\n<p>이 Connection은 생성하고 사용하고 삭제되기까지 꽤 많은 작업이 포함된다. 즉, 통신 비용이 <strong>비싸다</strong>.</p>\n<p>이러한 상황에서 서버는 많은 요청을 처리하는데, 이 요청들이 DB 서버로의 요청으로 이루어진다면 비싸고 오래걸리는 작업이 많아질 것이다.</p>\n<p>결국, 서버 성능에 악영향을 줄 수 있다.</p>\n<p>이를 해결하기 위해 DBCP는 탄생했다.</p>\n<h2>DBCP 기본 개념</h2>\n<p>서버가 실행되면 DB와 Connection을 <strong>미리 만들어 놓고 Pool에 저장해놓는다.</strong></p>\n<p>미리 만들어 놓은 DB Connection을 서버에 미리 가지고 있다가, DB로 요청을 보내야 하는 상황이 발생한다면 기존에 가지고 있는 Connection을 이용해 쿼리를 요청한다.</p>\n<p>요청을 모두 수행하면 요청에 사용된 Connection을 다시 Pool에 <strong>반환</strong>을 한다. </p>\n<p>결국, Connection을 생성하고 삭제하는 과정이 모두 생략되기 때문에 더 빠른 속도로 요청을 처리할 수 있게 된다.</p>\n<h2>종류</h2>\n<p>이 DBCP를 구현한 제품으로는 <a href=\"https://github.com/brettwooldridge/HikariCP\">HikariCP</a>, <a href=\"https://commons.apache.org/proper/commons-dbcp/\">Apache Commons DBCP</a>, <a href=\"https://github.com/swaldman/c3p0\">c3p0</a> 등이 있다.</p>\n<h2>HikariCP</h2>\n<p>Spring Boot 2.0부터 내장되어 사용되는 DBCP 이다.</p>\n<p>오픈소스로서, 타 제품에 비해 성능이 매우매우 뛰어나다.</p>\n<p>실제로 README를 읽어보면 타 제품에 비해 성능이 너무 뛰어나다고 엄청나게 자랑한다.</p>\n<p>아래 사진은 HikariCP 에서 자체적으로 진행한 벤치마크 결과이다. </p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/e2685dce9ca65982ad81dbf7a63df2c6/e6e97/result_of_benchmark.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 41.76470588235294%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpklEQVR42mWR3UsUURjG55/xOhivIoouTAmJKAjUiy66iv6A7q1UUrpQ7KIkkNyEPjC8bcFAw10UMipw11xJlpxp052dmc11Zs7Mr/OhU+TLPLxnznnOc573fa1YJDgNB9dxCcOQdrtNEAQ668jkl4If+Pi+rznqXK2jKOIkRJZpWIkUDH+HdDod0jQlk5sKKuJEUCi/YrHy2mhnf89zqH0h8EbH8R5NYv0rotYKQhJUNLwDzgyfZ6J8T/8nIs45GpKXKndHEU5PP+71IaxTLx4Lq/jle3SPXWZqfdyUlYpT3Piow2GzyW7/DeqDt4zD/5E7bDWxR/uYXHtoHErB9KQSlWW9jdI7aguzVM/1UbsygKUu50hNVn01DlvYI0rQOIySWAuZfprsvl+k+uIxG/YFvl66hpWPSU/TkIQcxt6BS6W+hT18kYnS/WNKRnDYYudnjbZXJ3SruEsLVArTFLtsVs72Yu06dfb2Hda3Nqj82OTTzhdWt0vcffOAmfITBp7eYe7zM/2gH8S8/Picq3O9LM8P8W26m+/FeTbfFijKHn64eZs/nEU+GX/vqQcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='자체 벤치마크 결과' title='' src='/static/e2685dce9ca65982ad81dbf7a63df2c6/ca1dc/result_of_benchmark.png' srcset='/static/e2685dce9ca65982ad81dbf7a63df2c6/e7570/result_of_benchmark.png 170w,\n/static/e2685dce9ca65982ad81dbf7a63df2c6/f46e7/result_of_benchmark.png 340w,\n/static/e2685dce9ca65982ad81dbf7a63df2c6/ca1dc/result_of_benchmark.png 680w,\n/static/e2685dce9ca65982ad81dbf7a63df2c6/e6e97/result_of_benchmark.png 864w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>자체 벤치마크 결과</figcaption>\n  </figure></p>\n<blockquote>\n<p>One <em>Connection Cycle</em>은 한 쌍의 <code class=\"language-text\">DataSource.getConnection()</code>, <code class=\"language-text\">Connection.close()</code><br>\nOne <em>Statement Cycle</em>은 한 쌍의 <code class=\"language-text\">Connection.prepareStatement()</code>, <code class=\"language-text\">Statement.execute()</code>, <code class=\"language-text\">Statement.close()</code> 이다.</p>\n</blockquote>\n<h2>중요한 설정 포인트</h2>\n<p>이 유용한 DBCP를 정말 유용하게 사용하려면, DB와 서버에서 각각 DB Connection 관련 설정을 잘 알아야 한다.</p>\n<blockquote>\n<p>DB는 MySQL, 서버는 Spring, DBCP는 hikariCP를 기준으로 설명한다.</p>\n</blockquote>\n<h3>데이터베이스 서버 설정 (MySQL 기준)</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">max_connections</code></p>\n<ul>\n<li>DB 서버가 클라이언트와 맺을 수 있는 최대 Connection 수이다.</li>\n<li>컴퓨팅 자원을 적절히 사용하면서 동시에 가장 높은 처리량만큼을 설정하는 것이 중요하다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">wait_timeout</code></p>\n<ul>\n<li>생성된 Connection이 아무 처리도 하지 않을 때, 새로운 요청이 오기까지 얼마만큼의 시간을 기다릴 지 설정한다.\n만약 <code class=\"language-text\">wait_timeout</code> 시간이 지나게 될 경우, Connection은 Close 된다.</li>\n<li>클라이언트에서 문제가 생겨 Connection을 정상적으로 종료하지 못하는 상황(비정상적 Connection 종료, Connection 반환 X, 네트워크 단절)에, 생성된 Connection을 알아서 종료해주기 위한 적절한 시간을 결정하는 것이 중요하다.</li>\n<li><code class=\"language-text\">wait_timeout</code>으로 인해 Connection이 종료되기 전에 새로운 요청이 들어올 경우, 0초부터 다시 시간을 측정한다.</li>\n</ul>\n</li>\n</ul>\n<h3>DBCP 설정 (HikariCP 기준)</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">minimumIdle</code></p>\n<ul>\n<li>Pool에서 유지하는 최소한의 Idle Connection의 수이다.</li>\n<li>만약 Idle 상태의 Connection 수가 <code class=\"language-text\">mimimumIdle</code> 값보다 작고, 전체 Connection 수가 <code class=\"language-text\">maximumPoolSize</code>보다 작은 상황이라면, 신속하게 새로운 Connection을 생성하고 Pool에 추가한다.</li>\n<li>Default는 <code class=\"language-text\">maximumPoolSize</code>와 동일한 값이다. 값을 동일하게 설정해야 요청이 들어올 때 새로운 Connection을 만들지 않고 DBCP를 사용하는 장점을 누릴 수 있기 때문이다.   </li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">maximumPoolSize</code></p>\n<ul>\n<li>Pool이 가질 수 있는 최대 Connection의 수이다.</li>\n<li>Idle 상태와 Active 상태의 Connection을 모두 포함한다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">maxLifetime</code></p>\n<ul>\n<li>Pool에서 Connection의 최대 수명 시간이다.</li>\n<li>Active인 상태는 절대 종료되지 않으며 Connection이 Pool에 반환된 이후의 시간을 토대로 종료한다.<br>\n이 특징 떄문에, Active 상태의 Connection이 Pool에 모종의 이유로 Pool에 반환되지 않은 시간이 DB 서버의 <code class=\"language-text\">wait_timeout</code>보다 길어진 이후에 DB로 요청을 보내게 되면, DB는 해당 Connection을 이미 Close 했기 떄문에, 해당 과정에서 예외가 발생할 수 있다. 이는 Connection Leak의 문제가 될 수 있다. </li>\n<li>풀에서 갑작스레 대량 소멸을 방지하기 위해 Connection 별로 일종의 조치를 취해놓았다.</li>\n<li>HikariCP 가 권장하길, DB의 <code class=\"language-text\">wait_timeout</code>보다 몇 초 더 짧게 설정하는 것이 좋다고 한다.<br>\n이유로는, 만약 <code class=\"language-text\">wait_timeout</code>과 <code class=\"language-text\">maxLifetime</code> 값을 동일하게 설정했다고 가정했을 때, <code class=\"language-text\">maxLifetime</code>에 얼마 남지 않은 시점에 요청을 처리해야 한다면, 해당 Connection이 DB 서버로 요청을 보내는 시간이 포함되는데, 요청이 DB 서버에 도달하기 전에 <code class=\"language-text\">wait_timeout</code> 시간이 지나게 되어 DB 서버 쪽에서 Connection을 끊게 된다면 예외가 발생할 수 있기 때문이다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">connectionTimeout</code></p>\n<ul>\n<li>서버 사용자가 Pool에서 Connection을 획득하기까지 얼마만큼의 시간을 기다릴 것인지 최대 시간을 정하는 설정이다.</li>\n<li>설정 시간만큼 Connection을 Pool에서 획득하지 못하면 <code class=\"language-text\">SQLException</code>이 발생한다.</li>\n<li>위 설정도 마찬가지로 <code class=\"language-text\">wait_timeout</code> 보다 더 짧은 시간으로 설정해야 한다.<br>\n만약 <code class=\"language-text\">connectionTimeout</code>과 <code class=\"language-text\">wait_timeout</code> 시간이 같다면, 사용자가 Pool에서 <code class=\"language-text\">connectionTimeout</code> 직전에 Connection을 획득했다 하더라도, 실제 DB 서버에 도달하기까지 추가적인 시간이 반드시 존재하고, 만약 도달한 시점에 이미 <code class=\"language-text\">wait_timeout</code> 시간을 넘은 상태라면 예외를 발생하기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h2>적절한 파라미터 값 설정하는 방법</h2>\n<p>우선 서버 애플리케이션을 모니터링을 하며 리소스 사용률, 서버 스레드 수, DBCP 정보들을 확인할 수 있어야 한다.</p>\n<p>그리고 <a href=\"https://naver.github.io/ngrinder/\">nGrinder</a>와 같은 부하 테스트 툴을 사용하여 실제로 서버에 부하를 줌으로써 병목 지점을 확인한다.</p>\n<p>만약 병목 지점이 생긴다면, 해당 시점 이후의 지표들을 토대로 병목 지점을 유추한다.</p>\n<p>유추되는 지점이 존재한다면 해당 값을 적절히 조절해가며 적절한 설정 값을 찾는 과정을 거친다.</p>\n<blockquote>\n<h3>Reference</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=zowzVqx3MQ4\">https://www.youtube.com/watch?v=zowzVqx3MQ4</a></li>\n</ul>\n</blockquote>","frontmatter":{"title":"DBCP와 HikariCP 이해하기","date":"October 16, 2023","update":null,"tags":["database","DBCP","hikariCP"],"series":null},"fields":{"slug":"/dbcp/","readingTime":{"minutes":8.18}}},"seriesList":{"edges":[{"node":{"id":"a30ff988-ea74-5562-b241-90fbff73a3da","fields":{"slug":"/kissoft-retrospection/"},"frontmatter":{"title":"키스소프트 현장실습 회고"}}},{"node":{"id":"aedd8f5b-dd45-5a14-9b57-3a48cdc0b641","fields":{"slug":"/what-is-varargs/"},"frontmatter":{"title":"[Java] Varargs는 어떻게 사용하고, 사용했을 때 장점이 무엇일까?"}}},{"node":{"id":"d41198ca-d162-523b-84f8-128b247a19b4","fields":{"slug":"/apply-https/"},"frontmatter":{"title":"[셀럽잇] HTTPS 적용기"}}},{"node":{"id":"3b94cbd6-f64a-5d82-96a2-0761602c250b","fields":{"slug":"/dbcp/"},"frontmatter":{"title":"DBCP와 HikariCP 이해하기"}}},{"node":{"id":"c418073e-50be-5fe1-807d-478c9c47f640","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"무중단 배포 이해하기"}}},{"node":{"id":"c5760ea9-e137-5edf-8244-3a93e25b067b","fields":{"slug":"/unit-test/"},"frontmatter":{"title":"단위 테스트 이해하기"}}},{"node":{"id":"8ae82b3f-5b72-555c-89fe-9939dcf8377c","fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"title":"JUnit과 AssertJ 활용법"}}},{"node":{"id":"91a7a622-00f8-5cca-b6c1-e4f7db7ee31e","fields":{"slug":"/about-tdd/"},"frontmatter":{"title":"TDD 이해하기"}}},{"node":{"id":"10e0dab4-d2e7-52df-8daa-31bfef1b08b6","fields":{"slug":"/static-with-memory-structure/"},"frontmatter":{"title":"static을 더 잘 사용하기"}}},{"node":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","fields":{"slug":"/about-garbage-collection/"},"frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리"}}},{"node":{"id":"0bf99b61-98a4-5c40-b8ce-05a918d212f7","fields":{"slug":"/garbage-collection-tuning/"},"frontmatter":{"title":"Garbage Collection 튜닝에 대해"}}},{"node":{"id":"61bd95c2-424a-54c8-96d9-bec4c8a4f58c","fields":{"slug":"/garbage-collection-algorithms/"},"frontmatter":{"title":"Garbage Collection 알고리즘"}}},{"node":{"id":"c87443bb-4e35-55e7-94d5-a5cb70d2dbc8","fields":{"slug":"/cautions-for-using-collections-in-Java/"},"frontmatter":{"title":"Java에서 컬렉션을 사용할 때 주의할 점"}}},{"node":{"id":"c2d7615d-6232-5fce-8794-f4c790106bb5","fields":{"slug":"/2023-retrospection/"},"frontmatter":{"title":"2023년 회고록"}}},{"node":{"id":"def28d41-907f-5432-8060-ed5429114882","fields":{"slug":"/compare-of-datetime-and-timestamp/"},"frontmatter":{"title":"[MySQL] DATETIME vs TIMESTAMP"}}},{"node":{"id":"9bf8ca89-e021-526b-a7b5-2cce0b1e366f","fields":{"slug":"/add-feat-and-issue-number-automatically/"},"frontmatter":{"title":"[git&github] IntelliJ에서 커밋 메시지 작성 시, 자동으로 커밋 타입과 이슈 번호 추가하기"}}},{"node":{"id":"01318426-7520-5a57-92ff-c917e1483247","fields":{"slug":"/difference-of-controller-and-restcontroller/"},"frontmatter":{"title":"[Spring] @Controller와 @RestController 비교하기"}}},{"node":{"id":"bc68fa05-ec4a-5e12-a9b8-4e58769887df","fields":{"slug":"/deploy-spring-boot-in-aws-ec2-manually/"},"frontmatter":{"title":"[Infra] AWS EC2에 Spring Boot 수작업으로 배포하기"}}},{"node":{"id":"122a1e9c-6fe5-5e7f-b797-a31f54d086b0","fields":{"slug":"/what-is-ami-architecture-of-ec2/"},"frontmatter":{"title":"CPU 아키텍처란?"}}},{"node":{"id":"c23a12ff-7b48-57ef-91ed-81f5386d680a","fields":{"slug":"/apply-issue-and-pr-template/"},"frontmatter":{"title":"[github] Github Repository에 Issue, PR Template 적용하기"}}},{"node":{"id":"b1dc584d-3c69-5ae8-82a8-09b015fa3d02","fields":{"slug":"/oauth-test/"},"frontmatter":{"title":"Spring Boot에서 Rest Assured로 인수 테스트할 때 OAuth 로그인 처리하기"}}},{"node":{"id":"9f43b8a7-b5ce-5766-b984-3ed0775d698f","fields":{"slug":"/ioc-container-and-di/"},"frontmatter":{"title":"[Spring] 스프링 컨테이너, 그리고 IoC/DI"}}},{"node":{"id":"e1b2a9fb-d6e3-5f65-9f50-d3a30c2518d1","fields":{"slug":"/what-is-jdbc/"},"frontmatter":{"title":"[Java] JDBC 파헤쳐보기"}}},{"node":{"id":"81b7fb10-f532-5f48-a797-379c3bb99bee","fields":{"slug":"/understanding-transaction-and-concurrency-problem/"},"frontmatter":{"title":"[MySQL] 트랜잭션과 트랜잭션 격리 수준"}}},{"node":{"id":"5ecb4a12-dc98-589f-94e0-695fb2d84fab","fields":{"slug":"/restore-using-binarylog/"},"frontmatter":{"title":"[MySQL] 바이너리 로그로 데이터 복구하기"}}},{"node":{"id":"c375e6a2-7e6c-5607-a579-04d3ab5f3188","fields":{"slug":"/understanding-generic/"},"frontmatter":{"title":"[Java] 제네릭 이해하기"}}},{"node":{"id":"83ad74c1-0d46-5f86-92fc-998642e4367d","fields":{"slug":"/covariant-invariant-and-pecs/"},"frontmatter":{"title":"[Java] 배열의 공변, 제네릭의 불공변. 그리고 PECS"}}},{"node":{"id":"7b9b6854-62e7-5f25-afbf-d5459fa5d021","fields":{"slug":"/commands-of-docker/"},"frontmatter":{"title":"[Docker] 도커의 기본적인 명령어들"}}},{"node":{"id":"d77e8b24-f01d-5673-8c55-d93e2d110c4f","fields":{"slug":"/enhance-speed-ci-workflow/"},"frontmatter":{"title":"[Infra] Github Actions를 이용한 CI 작업 속도를 캐싱으로 개선하기"}}},{"node":{"id":"b4550a40-b215-5e9a-a6a7-8c27bfb63e25","fields":{"slug":"/continuous-deploy-using-github-actions-and-docker/"},"frontmatter":{"title":"[Infra] Github Actions와 Docker를 이용해 배포 자동화 구축하기"}}},{"node":{"id":"e38bb1ed-1a51-5947-a1d2-52aaae42ac97","fields":{"slug":"/build-monitoring-system/"},"frontmatter":{"title":"[Infra] Prometheus와 Grafana, 그리고 Docker를 이용해 모니터링 대시보드 구축하기"}}},{"node":{"id":"32c6a1e4-f349-5a2a-991c-1ea625582325","fields":{"slug":"/june-3rd/"},"frontmatter":{"title":"[회고] 06.10 ~ 06.16"}}},{"node":{"id":"312b3fe7-7d78-543d-ae7c-4e861503d3e4","fields":{"slug":"/june-4th-and-5th/"},"frontmatter":{"title":"[회고] 06.17 ~ 06.30"}}},{"node":{"id":"7b64a367-9192-557d-b45d-0e3bc68d44d3","fields":{"slug":"/thread-in-jvm/"},"frontmatter":{"title":"Java Thread 1 - Java의 Thread에 대해 알아보자"}}},{"node":{"id":"9e5a98c2-ba89-5b36-8e72-0028211a2c5b","fields":{"slug":"/status-and-control-thread-in-java/"},"frontmatter":{"title":"Java Thread 2 - Java Thread의 상태와 행동을 제어하는 방법"}}},{"node":{"id":"45a781cf-0e04-559c-a853-d1609dab1bd4","fields":{"slug":"/synchronize-threads/"},"frontmatter":{"title":"Java Thread 3 - Thread 동기화하기"}}},{"node":{"id":"5b94aaf7-2bae-58b4-9376-927208822c83","fields":{"slug":"/july-1st/"},"frontmatter":{"title":"[회고] 07.01 ~ 07.07"}}},{"node":{"id":"abad5436-5cba-50a3-8fda-72440c646a78","fields":{"slug":"/solid/"},"frontmatter":{"title":"객체지향 설계 원칙: SOLID"}}}]},"previous":{"fields":{"slug":"/tomcat-tuning/"},"frontmatter":{"title":"[셀럽잇] Tomcat 성능 최적화를 위해 Max-Threads, Max-Connections, Accept-Count 설정하기"}},"next":{"fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"무중단 배포 이해하기"}}},"pageContext":{"id":"3b94cbd6-f64a-5d82-96a2-0761602c250b","series":null,"previousPostId":"becc6595-f346-5ffe-a26c-b2d31fa68261","nextPostId":"c418073e-50be-5fe1-807d-478c9c47f640"}},"staticQueryHashes":[],"slicesMap":{}}