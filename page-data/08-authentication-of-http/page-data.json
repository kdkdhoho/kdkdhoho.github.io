{"componentChunkName":"component---src-templates-post-jsx","path":"/08-authentication-of-http/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"91bb0215-8f87-5c05-b5e3-8c8b4e05a365","excerpt":"들어가며 이번엔 HTTP 표준이 설명하는 여러 가지 인증 방식에 대해 알아보겠다. Basic 인증 이름 그대로 가장 기본적인 인증 방식이다. 클라이언트가 Http Request를 보낼 때  헤더에 ID와 패스워드를 Base64 형식으로 인코딩 한 값을 담아 보내는 방식이다.\n이때 값 앞에 을 Prefix로 담아 함께 보내어 Basic 인증임을 나타낸다. …","html":"<h2>들어가며</h2>\n<p>이번엔 HTTP 표준이 설명하는 여러 가지 인증 방식에 대해 알아보겠다.</p>\n<h2>Basic 인증</h2>\n<p>이름 그대로 가장 기본적인 인증 방식이다.</p>\n<p>클라이언트가 Http Request를 보낼 때 <code class=\"language-text\">Authorization</code> 헤더에 ID와 패스워드를 Base64 형식으로 인코딩 한 값을 담아 보내는 방식이다.<br>\n이때 값 앞에 <code class=\"language-text\">\"Basic \"</code>을 Prefix로 담아 함께 보내어 Basic 인증임을 나타낸다.</p>\n<p>Basic 인증은 아래와 같은 요청이 서버로 전달된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">GET /my HTTP/1.1\nAuthoization: Basic Z3Vlc3Q35wervc32= </code></pre></div>\n<p>가장 단순하며 간편한 인증 방식이다.<br>\n하지만 Base64 형식은 <a href=\"https://www.base64decode.org/\">온라인 디코더 사이트</a>도 있는만큼 매우 위험한 인증 방식이다.<br>\n따라서 잘 사용하진 않는다.</p>\n<h2>DIGEST 인증</h2>\n<p>편리하지만 안전하지 않은 Basic 인증을 보완하기 위해 탄생한 기술이다.<br>\nDIGEST 인증에는 <em>챌린지 리스폰스</em> 방식이 사용되고 있어 패스워드를 그대로 보낼 일은 없다.</p>\n<p>챌린지 리스폰스 방식은 최초에 상대방에게 인증 요구를 보내고 그 결과로 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산한다.<br>\n이 값을 상대에게 송신하여 인증하는 방법이다.<br>\n리스폰스 코드는 패스워드와 챌린지 코드를 이용해 계산한 결과이다. 이 결과값을 보내기에 패스워드가 통신되는 일은 없다.</p>\n<p>좀 더 자세히 살펴보면 인증 순서에 따른 요청 및 응답 내용은 아래와 같다.</p>\n<ol>\n<li>\n<p>클라이언트가 리소스에 접근</p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">GET /my HTTP/1.1\nHost: listywave.com</code></pre></div>\n</li>\n<li>\n<p>서버는 인증이 필요하다는 상태 코드와 함께 패스워드와 챌린지 코드(nonce)를 송신</p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Digest realm=&quot;my&quot;, nonce=&quot;MoSq25=sddfAMi217wsnDS&quot;, algorithm=MD5, qop=&quot;auth</code></pre></div>\n</li>\n<li>\n<p>클라이언트는 패스워드와 챌린지 코드를 통해 리스폰스 코드를 계산해서 송신</p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">GET /my HTTP/1.1\nHost: listywave.com\nAuthorization: Digest username=&quot;kdkdhoho&quot;, realm=&quot;my&quot;, nonce=&quot;MoSq25=sddfAMi217wsnDS&quot;, uri=&quot;/my&quot;, algorithm=MD5, response=&quot;df563836bnfasf7acfasdfc78&quot;, qop=&quot;auth&quot;, nc=000000001, cnonce=&quot;0827c27c29c271&quot;</code></pre></div>\n</li>\n<li>\n<p>서버는 인증 성공 시 <code class=\"language-text\">200 OK</code>를 응답하고, 실패했을 경우 다시 <code class=\"language-text\">401 Unauthorized</code>를 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"httprequest\"><pre class=\"language-httprequest\"><code class=\"language-httprequest\">HTTP/1.1 200 OK\nAuthentication-Info: rspauth=&quot;fvacacwararact3c5ttcctyct7tcc4t7y&quot;, cnonce=&quot;0827c27c29c271&quot;, nc=000000001, qop=&quot;auth&quot;</code></pre></div>\n</li>\n</ol>\n<p>하지만 Digest 방식도 사용상의 문제와 부족한 보안성 때문에 잘 사용하지는 않는다.</p>\n<h2>SSL 클라이언트 인증</h2>\n<p>위 두 방식은 사용자 ID와 패스워드를 통해 인증을 진행한다.<br>\nSSL 클라이언트 인증의 경우에는 클라이언트가 <strong>클라이언트 인증서</strong>를 서버로 전송해 인증한다.</p>\n<p>클라이언트가 클라이언트 인증서를 서버로 전송하기 위해서는 사전에 미리 가지고 있어야 한다.<br>\n이를 위해선 서버가 미리 증명서를 구매하여 사용자에게 배포를 해야 한다.<br>\n다른 말로 인증을 위한 비용이 상당하다는 것이다.<br>\n따라서 웹 애플리케이션 인증만을 위한 용도로는 사용하지 않고 후술할 Form 방식과 함께 사용되어 2-Factor 인증으로 사용한다.</p>\n<h2>Form 방식</h2>\n<p>Form 방식은 HTTP 프로토콜로 스펙이 정의되어 있지는 않다.<br>\n하지만 많은 웹사이트에서 채택 중이며 대부분의 경우 로그인 페이지를 통해 사용자의 인증 정보를 폼에 입력 후 서버로 전송하면, 서버는 해당 값을 토대로 사용자를 식별하고 그에 따른 인증 처리를 하는 방식으로 채택 중이다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/9c59e807258884b8c8889affd6decef8/adc5a/form-auth-example.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 96.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAABoElEQVR42q2Uy0vEMBDG9+8VD75Q96D4Qj2I4EXUg6y4PmDrPkA8WUU9C4J42IMIorB0VdqmSdM26WfSfeiKbnfVwFeGmeaXyUySDP55ZHr5SUqZKI7jvwM1SI9eYF2BLUC1WoVpmjAMA4yxVHhPGVqWhXq93n+GeuUoihIFQdCWECLRZ1/Lnwp0HAe2bbfBP4lzDt/304GuS+C4Hniosuwi3+fgSl2BUsZg1IXkbxCBq5fQ3m8lRJhk+SOw0TiJ2wcP0wWC+aKH+RLFXJFi5ZhgueIl9kKZYtqg2DI9sOaWPzf9CzDGzT3BWJ4ge0AwqTSxT7BUtjFjuBhXdvaQYFTF105cUNYF+NHlQFmdksJXMd7pkzxpzq+uHldbEyLq7xzKZtp3TxEGcxTDeYaRPYrZI6LqRrBYcTFV8DCUpxhQ8dUTpubEaTUEHl8E1k99bJwybJ4x7FxS5C4odq8ots895eMqzlG6Dtpz4rQt6zo6r8/wHAvEbkjbzmsNpGaB207vd1mvKtRRi9SnpTBqSNtBIBCGsl2iXzXl3x/YfoDvEiq/mkSMcbMAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Form 방식의 로그인 페이지 (출처: https://gundogmuseray.medium.com/easy-way-to-stop-worry-about-client-side-auth-with-firebase-and-sveltekit-d17cdcccb663)' title='' src='/static/9c59e807258884b8c8889affd6decef8/ca1dc/form-auth-example.png' srcset='/static/9c59e807258884b8c8889affd6decef8/e7570/form-auth-example.png 170w,\n/static/9c59e807258884b8c8889affd6decef8/f46e7/form-auth-example.png 340w,\n/static/9c59e807258884b8c8889affd6decef8/ca1dc/form-auth-example.png 680w,\n/static/9c59e807258884b8c8889affd6decef8/02d09/form-auth-example.png 1020w,\n/static/9c59e807258884b8c8889affd6decef8/adc5a/form-auth-example.png 1068w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Form 방식의 로그인 페이지 (출처: https://gundogmuseray.medium.com/easy-way-to-stop-worry-about-client-side-auth-with-firebase-and-sveltekit-d17cdcccb663)</figcaption>\n  </figure></p>\n<h2>세션 및 토큰</h2>\n<p>HTTP 프로토콜은 Stateless 하다.<br>\n방금 전에 로그인에 성공했지만 다음 요청마다 로그인을 새로 해야 한다.<br>\n이를 개선하기 위해 쿠키[<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>] 가 도입되었고 여기에 세션[<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>]이나 토큰[<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>] 을 이용해 사용자 인증 정보를 유지한다.</p>\n<p>세션과 토큰은 현재 대부분의 경우 사용 중인 방식이다.<br>\n이 둘을 잘 이해하고 사용할 줄 아는 것은 매우 중요하다는 의미이며 다른 포스팅에서 집중적으로 알아볼 예정이다.</p>\n<br>\n<br>\n<br>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://m.yes24.com/Goods/Detail/15894097\">그림으로 배우는 Http &#x26; Network Basic</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies\">MDN - 쿠키</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Session\">MDN - 세션</a></p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p><a href=\"https://opentutorials.org/course/3405/22008\">오픈튜토리얼스 - AccessToken</a></p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"8장. 누가 액세스하고 있는지를 확인하는 인증","date":"April 10, 2024","update":null,"tags":["Network"],"series":"그림으로 배우는 Http & Network Basic"},"fields":{"slug":"/08-authentication-of-http/","readingTime":{"minutes":5.8}}},"seriesList":{"edges":[{"node":{"id":"a4d71417-67f6-5df5-a92a-fe77cee2c152","fields":{"slug":"/01-comprehension-about-web-and-network-basic/"},"frontmatter":{"title":"1장. 웹과 네트워크의 기본에 대해 알아보자"}}},{"node":{"id":"b30f24d3-925d-5fec-8b29-6f6226b97cd6","fields":{"slug":"/02-http-protocol/"},"frontmatter":{"title":"2장. 간단한 프로토콜 HTTP"}}},{"node":{"id":"807f22e3-dcd4-554f-908e-19ffa9b29d8c","fields":{"slug":"/03-http-detail/"},"frontmatter":{"title":"3장. HTTP 정보는 HTTP 메시지에 있다"}}},{"node":{"id":"bd0818e6-a370-5bc9-96d5-ad7d10929267","fields":{"slug":"/04-http-status-code/"},"frontmatter":{"title":"4장. 결과를 전달하는 HTTP 상태 코드"}}},{"node":{"id":"e210085d-c6e8-5cce-81f0-c7773af272fa","fields":{"slug":"/05-web-server/"},"frontmatter":{"title":"5장. HTTP와 연계하는 웹서버"}}},{"node":{"id":"5b14ad06-606e-5537-be91-65ab1aa467e5","fields":{"slug":"/06-http-header/"},"frontmatter":{"title":"6장. HTTP 헤더"}}},{"node":{"id":"84076d04-c12f-5e3f-889d-67a2bc4a604f","fields":{"slug":"/07-https/"},"frontmatter":{"title":"7장. 웹을 안전하게 지켜주는 HTTPS"}}},{"node":{"id":"91bb0215-8f87-5c05-b5e3-8c8b4e05a365","fields":{"slug":"/08-authentication-of-http/"},"frontmatter":{"title":"8장. 누가 액세스하고 있는지를 확인하는 인증"}}},{"node":{"id":"bcfa9a22-0d4a-5d68-a21f-2dc441452620","fields":{"slug":"/09-advanced-http-protocol/"},"frontmatter":{"title":"9장. HTTP에 기능을 추가한 프로토콜"}}}]},"previous":{"fields":{"slug":"/restore-using-binarylog/"},"frontmatter":{"title":"[MySQL] 바이너리 로그로 데이터 복구하기"}},"next":{"fields":{"slug":"/09-advanced-http-protocol/"},"frontmatter":{"title":"9장. HTTP에 기능을 추가한 프로토콜"}}},"pageContext":{"id":"91bb0215-8f87-5c05-b5e3-8c8b4e05a365","series":"그림으로 배우는 Http & Network Basic","previousPostId":"5ecb4a12-dc98-589f-94e0-695fb2d84fab","nextPostId":"bcfa9a22-0d4a-5d68-a21f-2dc441452620"}},"staticQueryHashes":[],"slicesMap":{}}