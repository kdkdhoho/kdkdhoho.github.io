{"componentChunkName":"component---src-templates-post-jsx","path":"/05-transaction-and-lock/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"076df81f-9afd-5dfe-bc33-fff6402d1ddc","excerpt":"트랜잭션 트랜잭션은 최소한의 논리적인 작업 단위이다. 하나의 작업 단위에 포함되는 모든 작업들이 100% 성공해야 트랜잭션이 commit 되며, 중간에 작업 하나라도 문제가 생겼을 땐 작업 전체를 무효화한다. (All or Nothing) 이를 통해 데이터의 정합성을 보장한다. ACID 모델 데이터베이스 설계 원칙으로 ACID 모델이 있다.  InnoDB…","html":"<h2>트랜잭션</h2>\n<p>트랜잭션은 <strong>최소한의 논리적인 작업 단위이다.</strong></p>\n<p>하나의 작업 단위에 포함되는 모든 작업들이 100% 성공해야 트랜잭션이 commit 되며, 중간에 작업 하나라도 문제가 생겼을 땐 작업 전체를 무효화한다. (<em>All or Nothing</em>)</p>\n<p>이를 통해 데이터의 정합성을 보장한다.</p>\n<h3>ACID 모델</h3>\n<p>데이터베이스 설계 원칙으로 ACID 모델이 있다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/e0d7750aa8f3c0b309818a3a634d8975/a585f/img.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 50.588235294117645%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVR42nVSa2/UQAzs//9HfEFIVBQhEG2vubts3pvHbZ6bxyWCJJfB67aCnmgkS7ZnNZ6xc3P3KPDN8vDx+x4f7h4hpMK9iPDpxwG39za+7lyUbU+4hdsHgS8Un38e8d53s64XnMcRbddjOJ85b3QH3XbohoHrrh8ImyifsND7eVneJ9ywIU4S2EJAOA78IITjuDgcBcIwgucHlNuIZMzYNE0cywvptm0cfwmpaLsOSuVI0hRFWaFuGlR1g7KqUVKt8hwN9SSR5kXB2DzP/1d43QhI1e5pD8f12a61P7KyVw3ZSeFh90RhwaO+wY+2w/i6rs+Er5KXZSWVGau9XDYMw8hWzZ4H2qfKC2TZCVprtmwITPxr/43C3/OCJMuRnsgiXbZqWrh+iLLWZF8jlAlkQgOLimxrPl6tW8aLqqEjjm8JZ1LoBRJ7OoghNQ93ZMn1I+S0y4PtQtAqzBDrIOCHErbjI04VMlUQeXdFSAqNgiCKSe2M/jzytUuaXpNaGae8kpT2GEQSaaY4N7+bWdF6uba8GMsKrhfytLYfuV7WjS0FkbF84ghliijOXgQkhGv8mlf8Abtv84qtW+V7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img' title='' src='/static/e0d7750aa8f3c0b309818a3a634d8975/ca1dc/img.png' srcset='/static/e0d7750aa8f3c0b309818a3a634d8975/e7570/img.png 170w,\n/static/e0d7750aa8f3c0b309818a3a634d8975/f46e7/img.png 340w,\n/static/e0d7750aa8f3c0b309818a3a634d8975/ca1dc/img.png 680w,\n/static/e0d7750aa8f3c0b309818a3a634d8975/a585f/img.png 689w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>InnoDB의 트랜잭션은 이 ACID 모델을 준수한다.</p>\n<ul>\n<li><strong>Atomic</strong>: 원자성, 트랜잭션의 작업은 전부 적용되거나 전부 적용되지 않아야 한다.</li>\n<li><strong>Consistency</strong>: 일관성, 데이터베이스는 트랜잭션이 진행되거나 커밋되거나 롤백된 모든 경우에 항상 일관된 상태로 유지된다. </li>\n<li><strong>Isolation</strong>: 고립성, 트랜잭션끼리는 서로 간섭할 수 없다. 뒷장에 나올 고립 수준으로 고립성의 정도를 조절할 수 있다.</li>\n<li><strong>Durability</strong>: 지속성, 트랜잭션이 commit 된 후에는 반드시 디스크에 반영해야 한다.</li>\n</ul>\n<p>자세한 내용은 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html\">MySQL 공식문서</a> 참고</p>\n<h3>주의할 점</h3>\n<p>트랜잭션 또한 DB Connection과 마찬가지로 <strong>최소한의 범위로 적용하는 것이 좋다.</strong></p>\n<p>트랜잭션의 범위가 많다는 것은 처리해야 할 작업이 많다는 것이고 이는 Connection이 존재하는 시간이 길어진다는 의미이다.<br>\nDB Connection의 수는 한정적이므로 하나의 Connection이 존재하는 시간이 길어지면 그만큼 다른 요청을 처리하는 데에 장애가 생길 확률이 높아진다.</p>\n<p>그리고 트랜잭션에 <strong>네트워크를 통해 원격 서버와 통신하는 등의 작업은 어떻게 해서든 트랜잭션 내에서 제거하는 것이 좋다.</strong><br>\n트랜잭션이 실행되는 동안 외부 서버와 통신할 수 없는 상태라면, 해당 트랜잭션은 영영 처리되지 못하게 되며 다른 트랜잭션에도 악영향을 끼칠 수 있다.</p>\n<h2>MySQL 엔진의 Lock</h2>\n<p>Lock은 동시성을 제어하기 위한 기능이다.</p>\n<p>여러 Connection이 동시에 동일한 자원에 대해 변경을 요청한 경우, 경쟁 조건이 발생하는 것을 방지하기 위한 역할을 한다.</p>\n<p>크게 MySQL 엔진 레벨과 스토리지 엔진 레벨의 Lock으로 나눌 수 있다.</p>\n<p>MySQL 엔진 레벨의 Lock은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 Lock은 스토리지 엔진 간 상호 영향을 미치지 않는다.</p>\n<h3>글로벌 락</h3>\n<ul>\n<li><code class=\"language-text\">FLUSH TABLES WITH READ LOCK;</code> 명령으로 글로벌 락을 획득할 수 있다.</li>\n<li>MySQL에서 제공하는 Lock 가운데 범위가 가장 크다.</li>\n<li>하나의 Connection에서 글로벌 락을 획득하면 다른 Connection에서 SELECT를 제외한 대부분의 DDL이나 DML을 실행한 경우 글로벌 락이 해제될 때까지 대기한다.</li>\n<li>영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.</li>\n</ul>\n<h3>테이블 락</h3>\n<ul>\n<li>개별 테이블 단위에 설정하는 락이다.</li>\n<li>묵시적으로도 테이블 락을 획득할 수 있으나, 명시적으로는 <code class=\"language-text\">LOCK TABLES table_name [ READ | WRITE ];</code> 명렁으로 특정 테이블에 대한 락을 획득할 수 있다.<br>\n이렇게 명시적으로 획득한 락은 <code class=\"language-text\">UNLOCK TABLES</code> 명령으로 락을 반환할 수 있다.<br>\n사실 명시적인 잠금은 글로벌 락과 마찬가지로 특별한 상황이 아니라면 애플리케이션에서 거의 사용할 필요가 없다.</li>\n<li>\n<p>묵시적 테이블 락은 MyISAM이나 MEMORY 테이블에 쓰기 작업의 쿼리를 실행하면 발생한다.<br>\n쿼리가 실행되는 동안 자동으로 획득했다가 쿼리가 완료된 후 자동 해제되는 식으로 동작한다.</p>\n<ul>\n<li>InnoDB 테이블의 경우, 스토리지 엔진 차원에서 레코드 기반 Lock을 지원하므로 DML 쿼리에서는 묵시적 테이블 락이 적용되지는 않는다.<br>\nDDL의 경우에만 묵시적 테이블 락을 획득한다.</li>\n</ul>\n</li>\n</ul>\n<h3>네임드 락</h3>\n<ul>\n<li><code class=\"language-text\">GET_LOCK()</code> 함수를 이용해 <strong>임의의 문자열에 대해 Lock을 설정할 수 있다.</strong></li>\n<li>Lock의 대상이 데이터베이스 객체가 아니라는 특징이 있다.<br>\n단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 Lock이다.</li>\n<li>자주 사용되지는 않는다.<br>\n여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.<br>\n또, 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용할 수 있다.</li>\n</ul>\n<p>자세한 내용은 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html\">MySQL 공식문서</a> 참고</p>\n<blockquote>\n<p>한번 보면 좋을만한 글<br>\n<a href=\"https://techblog.woowahan.com/2631/\">우아한기술블로그 - MySQL의 네임드 락을 이용한 분산 락으로 여러 서버에 걸친 동시성 관리</a></p>\n</blockquote>\n<h3>메타데이터 락</h3>\n<ul>\n<li>데이터베이스 객체(테이블 or 뷰)의 이름이나 구조를 변경하는 경우에 획득하는 Lock이다.</li>\n<li>\n<p>명시적으로 획득할 수는 없고, 테이블의 이름을 변경과 같은 경우에 자동으로 획득하는 Lock이다.</p>\n<ul>\n<li>테이블을 변경하는 작업의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 Lock을 획득한다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"MySQL에서의 트랜잭션과 Lock","date":"January 03, 2024","update":null,"tags":["database"],"series":"Real MySQL 8.0"},"fields":{"slug":"/05-transaction-and-lock/","readingTime":{"minutes":7.305}}},"seriesList":{"edges":[{"node":{"id":"014bd317-3394-5c4d-9a72-e1319712838a","fields":{"slug":"/03-user-identification/"},"frontmatter":{"title":"MySQL에서의 사용자 식별에 대해"}}},{"node":{"id":"69b6441a-edde-5385-b6a3-0df3608f6657","fields":{"slug":"/04-mysql-engine-architecture/"},"frontmatter":{"title":"MySQL 엔진 아키텍처"}}},{"node":{"id":"cf713bbe-9c34-54b6-9d8b-9f1b1f12ebfe","fields":{"slug":"/04-innodb-engine/"},"frontmatter":{"title":"InnoDB 엔진 이해하기"}}},{"node":{"id":"f21b2f2c-8b87-52fe-965b-01011033f9f5","fields":{"slug":"/04-mysql-log/"},"frontmatter":{"title":"MySQL 로그 파일"}}},{"node":{"id":"076df81f-9afd-5dfe-bc33-fff6402d1ddc","fields":{"slug":"/05-transaction-and-lock/"},"frontmatter":{"title":"MySQL에서의 트랜잭션과 Lock"}}},{"node":{"id":"c1af5fc8-26e9-523f-ab94-cd74c7a9f8b5","fields":{"slug":"/05-isolation-level-of-MySQL/"},"frontmatter":{"title":"MySQL의 격리 수준"}}},{"node":{"id":"48bcea91-2f18-5443-9881-eb4e2cdd272f","fields":{"slug":"/05-lock-of-innodb-storage-engine/"},"frontmatter":{"title":"InnoDB 스토리지 엔진의 락"}}},{"node":{"id":"0a33b9d9-8548-50e3-a895-0d1011aec7b1","fields":{"slug":"/08-03-b-tree-index/"},"frontmatter":{"title":"B-Tree 인덱스에 대해 알아보자"}}},{"node":{"id":"94032e77-bdeb-5604-be4a-7b868b61f76d","fields":{"slug":"/10-execute-plain/"},"frontmatter":{"title":"MySQL의 실행 계획에 대해 알아보자"}}}]},"previous":{"fields":{"slug":"/04-mysql-log/"},"frontmatter":{"title":"MySQL 로그 파일"}},"next":{"fields":{"slug":"/compare-of-datetime-and-timestamp/"},"frontmatter":{"title":"[MySQL] DATETIME vs TIMESTAMP"}}},"pageContext":{"id":"076df81f-9afd-5dfe-bc33-fff6402d1ddc","series":"Real MySQL 8.0","previousPostId":"f21b2f2c-8b87-52fe-965b-01011033f9f5","nextPostId":"def28d41-907f-5432-8060-ed5429114882"}},"staticQueryHashes":[],"slicesMap":{}}