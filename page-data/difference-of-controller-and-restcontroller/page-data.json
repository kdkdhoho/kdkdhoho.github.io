{"componentChunkName":"component---src-templates-post-jsx","path":"/difference-of-controller-and-restcontroller/","result":{"data":{"site":{"siteMetadata":{"title":"log4dh"}},"markdownRemark":{"id":"01318426-7520-5a57-92ff-c917e1483247","excerpt":"@Controller와 @RestController의 역할과 차이점에 대해 알아보기 전에, 둘의 근본이 되는 Controller의 역할에 대해 이야기하겠습니다. (여기서 Controller는 Spring MVC에서의 Controller를 의미합니다.) Controller의 역할은? 제가 생각하는 Controller의 역할은 다음과 같습니다. 사용자의 요청…","html":"<p>@Controller와 @RestController의 역할과 차이점에 대해 알아보기 전에, 둘의 근본이 되는 Controller의 역할에 대해 이야기하겠습니다. (여기서 Controller는 Spring MVC에서의 Controller를 의미합니다.)</p>\n<h2>Controller의 역할은?</h2>\n<p>제가 생각하는 Controller의 역할은 다음과 같습니다.</p>\n<ol>\n<li><strong>사용자의 요청을 처리한다.</strong></li>\n<li>입력되는 데이터를 처리한다.</li>\n<li>사용자의 요청에 따라 수행할 비즈니스 로직을 결정한다.</li>\n<li><strong>요청의 결과를 반환한다.</strong></li>\n</ol>\n<p>이때, 사용자의 요청을 URI와 매핑하여 각기 다르게 처리합니다.\n이를 위해 @RequestMapping 을 이용하여 어떤 URI 요청을 처리할지 결정합니다.</p>\n<h2>@Controller, @RestController 살펴보기</h2>\n<p>우선 <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html\">@Controller docs</a>를 먼저 살펴보겠습니다.</p>\n<blockquote>\n<p>Indicates that an annotated class is a \"Controller\" (e.g. a web controller).\nThis annotation serves as a specialization of @Component, allowing for implementation classes to be autodetected through classpath scanning. It is typically used in combination with annotated handler methods based on the RequestMapping annotation.</p>\n<p>이 애노테이션이 클래스가 \"컨트롤러\" 임을 나타냅니다. (예: 웹 컨트롤러)\n이 애노테이션은 클래스 경로 탐색을 통해 자동으로 탐지되도록 허용함으로써  <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html\">@Component</a>의 특별성을 제공합니다.\n보통 <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html\">@RequestMapping</a> 이 달린 메서드와 함께 사용됩니다.</p>\n</blockquote>\n<p>또한 내부에 Optional Element로서 <code class=\"language-text\">String value</code> 만을 가집니다.\n이 value는 <strong>logical component name</strong>을 가리킨다고 합니다. 즉, Controller 클래스가 Bean으로 등록될 때의 <strong>이름</strong>을 변경하고 싶을 때 사용하는 요소입니다.</p>\n<hr>\n<p>다음으로 <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html\">@RestController docs</a>를 살펴보겠습니다.</p>\n<blockquote>\n<p>A convenience annotation that is itself annotated with @Controller and @ResponseBody.\nTypes that carry this annotation are treated as controllers where @RequestMapping methods assume @ResponseBody semantics by default.</p>\n<p>@RestController는 그 자체로 @Controller와 @ResponseBody가 함께 있는 편리한 애노테이션입니다. 이 애노테이션이 포함된 타입은 @RequestMapping가 달린 메서드에 기본적으로 @ResponseBody도 함께 의미합니다.</p>\n<p>NOTE: @RestController is processed if an appropriate HandlerMapping-HandlerAdapter pair is configured such as the RequestMappingHandlerMapping-RequestMappingHandlerAdapter pair which are the default in the MVC Java config and the MVC namespace.</p>\n<p>주의: @RestController는 <code class=\"language-text\">RequestMappingHandlerMapping-RequestMappingHanlderAdapter</code>와 같은 기본적인 MVC Java Config와 MVC namespace를 가진 <code class=\"language-text\">HandlerMapping-HandlerAdapter</code> 쌍이 설정되었을 때 처리됩니다.</p>\n</blockquote>\n<p>@Controller와 마찬가지로 내부에 <code class=\"language-text\">String value</code> Element 만을 가집니다. 의미하는 바도 같습니다.\n하지만 큰 차이가 하나 있습니다. 바로 <code class=\"language-text\">@ResponseBody</code>를 포함한다는 것인데요.\n그렇다면 @ResponseBody가 무엇인지 알아보기 위해 <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseBody.html\">공식문서</a>를 살펴보겠습니다.</p>\n<blockquote>\n<p>Annotation that indicates a method return value should be bound to the web response body.</p>\n<p>As of version 4.0 this annotation can also be added on the type level in which case it is inherited and does not need to be added on the method level.</p>\n<p>이 애노테이션이 가리키는 메서드는 웹 응답 body에 값을 반환하는 의무를 가집니다.</p>\n<p>버전 4.0부터는 type(class, interface, or enum)에 추가할 수도 있습니다. 이 경우 상속이 되며, 메서드에 추가할 필요가 없습니다.</p>\n</blockquote>\n<p>핵심은 <strong>이 애노테이션이 가리키는 메서드는 웹 응답시 body부에 값을 반환한다</strong> 입니다.\n추가로 'class, interface, enum'에 작성할 수 있고, 이 경우 메서드에 따로 명시를 안해줘도 된다는 것입니다.</p>\n<h2>결론</h2>\n<p>그렇다면 이렇게 결론지을 수 있을 것 같습니다.</p>\n<p>@Controller는 기본적으로 웹 MVC에서 Controller의 역할을 한다.\n@RestController는 @Controller에 @ResponseBody의 의미를 함께 가진다. 따라서 해당 컨트롤러 내 모든 메서드들은 반환 시, 웹 응답 body부에 값을 넣어 반환한다.</p>\n<p>즉, 사용자의 요청에 따라 <strong>데이터의 형식</strong>을 다르게 반환하고 싶을 때, 이 둘을 구분해서 사용해야 합니다.</p>\n<h2>코드로 비교하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>This is tmpPage.html<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\nThis is tmpPage.html\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Controller</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JustController</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/Controller\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">justController</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"tmpPage\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/RestController\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@ResponseBody</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">restController</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"tmpPage\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>두 메서드는 URI를 각각 \"/Controller\", \"/RestController\"에 매핑하여 요청을 처리합니다.</p>\n<p>이때 \"localhost:8080/Controller\"에 Get 방식으로 요청했을 때 아래와 같은 결과가 나옵니다.</p>\n<p><img src=\"https://velog.velcdn.com/images/donghokim1998/post/e7e0d11d-cc8f-4189-9a61-8b2221543629/image.png\"></p>\n<p>다음은 \"/RestController\" 에 Get 방식으로 요청했을 때의 결과입니다.</p>\n<p><img src=\"https://velog.velcdn.com/images/donghokim1998/post/27ab1cd6-6895-4364-ad84-62bb6d187fb0/image.png\"></p>\n<p>코드 상으로는 같은 \"tmpPage\" 를 반환합니다.\n하지만 @ResponseBody 가 붙지 않은 메서드인, <code class=\"language-text\">justController()</code>의 경우 Spring 내의 <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/ViewResolver.html\">ViewResolver</a>에 의해 view로 변환이 됩니다.</p>\n<p>반면 <code class=\"language-text\">restController()</code>의 경우 문자열 \"tmpPage\"이 그대로 Body에 반환되는 것을 확인할 수 있습니다.</p>","frontmatter":{"title":"[Spring] @Controller와 @RestController 비교하기","date":"January 12, 2024","update":null,"tags":["Spring","Spring MVC"],"series":null},"fields":{"slug":"/difference-of-controller-and-restcontroller/","readingTime":{"minutes":5.94}}},"seriesList":{"edges":[{"node":{"id":"a30ff988-ea74-5562-b241-90fbff73a3da","fields":{"slug":"/kissoft-retrospection/"},"frontmatter":{"title":"키스소프트 현장실습 회고"}}},{"node":{"id":"3b94cbd6-f64a-5d82-96a2-0761602c250b","fields":{"slug":"/dbcp/"},"frontmatter":{"title":"DBCP와 HikariCP 이해하기"}}},{"node":{"id":"c418073e-50be-5fe1-807d-478c9c47f640","fields":{"slug":"/zero-downtime-deployment/"},"frontmatter":{"title":"무중단 배포 이해하기"}}},{"node":{"id":"c5760ea9-e137-5edf-8244-3a93e25b067b","fields":{"slug":"/unit-test/"},"frontmatter":{"title":"단위 테스트 이해하기"}}},{"node":{"id":"8ae82b3f-5b72-555c-89fe-9939dcf8377c","fields":{"slug":"/using-junit-and-assertJ/"},"frontmatter":{"title":"JUnit과 AssertJ 활용법"}}},{"node":{"id":"91a7a622-00f8-5cca-b6c1-e4f7db7ee31e","fields":{"slug":"/about-tdd/"},"frontmatter":{"title":"TDD 이해하기"}}},{"node":{"id":"10e0dab4-d2e7-52df-8daa-31bfef1b08b6","fields":{"slug":"/static-with-memory-structure/"},"frontmatter":{"title":"static을 더 잘 사용하기"}}},{"node":{"id":"c773b0a0-9610-5605-bdb9-9089df57f52b","fields":{"slug":"/about-garbage-collection/"},"frontmatter":{"title":"JVM의 Garbage Collection과 동작 원리"}}},{"node":{"id":"0bf99b61-98a4-5c40-b8ce-05a918d212f7","fields":{"slug":"/garbage-collection-tuning/"},"frontmatter":{"title":"Garbage Collection 튜닝에 대해"}}},{"node":{"id":"61bd95c2-424a-54c8-96d9-bec4c8a4f58c","fields":{"slug":"/garbage-collection-algorithms/"},"frontmatter":{"title":"Garbage Collection 알고리즘"}}},{"node":{"id":"c87443bb-4e35-55e7-94d5-a5cb70d2dbc8","fields":{"slug":"/cautions-for-using-collections-in-Java/"},"frontmatter":{"title":"Java에서 컬렉션을 사용할 때 주의할 점"}}},{"node":{"id":"c2d7615d-6232-5fce-8794-f4c790106bb5","fields":{"slug":"/2023-retrospection/"},"frontmatter":{"title":"2023년 회고록"}}},{"node":{"id":"def28d41-907f-5432-8060-ed5429114882","fields":{"slug":"/compare-of-datetime-and-timestamp/"},"frontmatter":{"title":"[MySQL] DATETIME vs TIMESTAMP"}}},{"node":{"id":"9bf8ca89-e021-526b-a7b5-2cce0b1e366f","fields":{"slug":"/add-feat-and-issue-number-automatically/"},"frontmatter":{"title":"[git&github] IntelliJ에서 커밋 메시지 작성 시, 자동으로 커밋 타입과 이슈 번호 추가하기"}}},{"node":{"id":"01318426-7520-5a57-92ff-c917e1483247","fields":{"slug":"/difference-of-controller-and-restcontroller/"},"frontmatter":{"title":"[Spring] @Controller와 @RestController 비교하기"}}},{"node":{"id":"bc68fa05-ec4a-5e12-a9b8-4e58769887df","fields":{"slug":"/deploy-spring-boot-in-aws-ec2-manually/"},"frontmatter":{"title":"[Infra] AWS EC2에 Spring Boot 수작업으로 배포하기"}}},{"node":{"id":"122a1e9c-6fe5-5e7f-b797-a31f54d086b0","fields":{"slug":"/what-is-ami-architecture-of-ec2/"},"frontmatter":{"title":"CPU 아키텍처란?"}}}]},"previous":{"fields":{"slug":"/comprehension-about-web-and-network-basic/"},"frontmatter":{"title":"1장. 웹과 네트워크의 기본에 대해 알아보자"}},"next":{"fields":{"slug":"/deploy-spring-boot-in-aws-ec2-manually/"},"frontmatter":{"title":"[Infra] AWS EC2에 Spring Boot 수작업으로 배포하기"}}},"pageContext":{"id":"01318426-7520-5a57-92ff-c917e1483247","series":null,"previousPostId":"972c64d3-e116-5d29-913c-8614a2f054e3","nextPostId":"bc68fa05-ec4a-5e12-a9b8-4e58769887df"}},"staticQueryHashes":[],"slicesMap":{}}