---
title: "Cache-Control 명세서 정리"
description: "HTTP 헤더 중 하나이자 HTTP 캐싱을 제어하는 Cache-Control 헤더에 대해 정리한 글입니다."
date: 2026-01-21
tags: ["네트워크", "HTTP", "HTTP 캐시", "HTTP Header", "Cache-Control"]
---

- HTTP Response 캐시를 활용하면 성능을 향상할 수 있다.
- HTTP **캐시**는 HTTP 응답 메시지를 로컬에 저장하는 **저장소**이자, 그 안에 메시지 저장, 검색, 삭제를 제어하는 하위 **시스템**을 의미한다.
- 캐시는 캐시 가능한 응답을 저장하며, 향후 동일한 요청에 대한 응답을 곧바로 하게 해주어 응답 시간과 네트워크 대역폭 소비를 줄인다.
- 공유 캐시(Shared Cache)는 여러 사용자가 재사용할 수 있도록 응답을 저장하는 캐시다. 일반적으로 중개자(CDN, 프록시 등)의 일부로 배포된다. 반면 개인 캐시(Private Cache)는 단일 사용자에게 전용되는 캐시이며, 보통 브라우저에 저장되는 것을 의미한다.
- HTTP 캐싱의 목표는 이전 응답 메시지를 재사용하여 현재 요청을 처리함으로써 성능을 크게 향상시키는 것이다. 캐시는 저장된 응답이 "validate"(캐시된 응답이 해당 요청에 대해 여전히 유효한지 확인하기 위해 원본 서버와 확인하는 과정)없이 재사용될 수 있을 때, 응답이 "fresh"하다고 간주한다. (그렇다고 캐시된 응답과 원본 서버의 응답이 항상 같은 것은 아니다.) 따라서 Fresh한 응답은 이를 재사용하여 지연 시간과 네트워크 오버헤드를 모두 줄일 수 있다. 캐시된 응답이 Fresh 상태가 아니더라도, validation(유효성 검증)이나 원본 서버에 접근할 수 없는 경우(후술) 재사용할 수 있다.
- 캐싱은 HTTP의 선택적 기능이지만, 가급적 응답을 재사용하는 것이 바람직하며, 이를 막는 요구사항이나 로컬 구성이 없는 경우에는 재사용이 기본 동작이라고 가정할 수 있다.
- HTTP 캐시 요구사항은 항상 특정 응답을 저장하고 재사용하도록 강제하기보다는, **재사용 불가능한 응답을 저장하거나 저장된 응답을 부적절하게 재사용하는 것을 방지하는 데 초점**을 맞춘다.
- Cache Key는 캐시가 응답을 선택하는 데 사용하는 정보로, 최소한 **요청 메서드와 URI로 구성**된다. 요청 메서드는 후속 요청을 처리할 때 재사용 조건을 결정한다. 오늘날 일반적으로 사용되는 많은 HTTP 캐시는 GET 응답만 캐시하므로, URI만을 Cache Key로 사용한다.
  - 캐시는 콘텐츠 협상(Content Negotiation)이 적용되는 요청 대상에 대해 여러가지 응답을 저장할 수 있다. 캐시는 `Vary` 응답 헤더의 정보를 사용하여 원본 요청의 헤더 필드 일부를 캐시 키에도 포함함으로써 이러한 응답을 구분한다. (예를 들어, 서버가 응답에 `Vary: Accept-Language`를 포함하면, 캐시는 URI 뿐 아니라 요청의 `Accept-Language` 헤더 값까지 조합하여 새로운 Cache Key를 생성한다.)
  - 캐시는 Cache Key에 추가 자료를 포함할 수 있다. 예를 들어, 브라우저 캐시(Private 캐시)는 참조 사이트의 식별자를 포함하여 캐시에 "이중 키"를 지정함으로써 일부 개인정보 위험을 방지할 수 있다. (참고: https://www.rfc-editor.org/rfc/rfc9111.html#security.timing)
- 일반적으로 캐시는 GET 요청에 대한 200(OK) 응답을 저장한다. 하지만, 리디렉션, 실패 결과(예: 404), 불완전한 결과(예: 206(Partial Content)), 그리고 GET 이외에 메서드에 대한 응답도 저장할 수는 있다. 단, 해당 메서드의 정의가 캐싱을 허용하고 캐시 키로 사용하기에 적합한 것을 정의하는 경우에 한한다.
- 캐시는 원본 서버와 통신할 수 없거나, 요청에 대한 전달 경로를 찾을 수 없을 때 "disconnected" 상태가 된다. disconnected 상태의 캐시는 특정 상황에서 오래된 응답을 제공할 수 있다. (후술) 
- 캐시가 서버로부터 받은 응답을 저장하기 위해서는 반드시 충족해야 하는 규칙들이 있다.
  - 캐시는 요청에 사용된 HTTP 메서드를 인식하고 그에 따른 캐싱 동작을 수행할 수 있어야 한다.
  - 응답 코드가 최종적인 것이어야 하며 1xx(Information) 같은 임시 상태 코드는 저장할 수 없다. 특히 206(Partial Content)이나 304(Not Modified)와 같은 특정 상태 코드는 캐시가 해당 코드의 의미와 처리 방식을 명확히 이해하고 구현하고 있을 때만 저장이 허용된다. 이는 불완전한 데이터가 잘못 캐싱되어 사용자에게 전달되는 것을 방지하기 위함이다.
  - 응답 헤더에 `no-store` 지시어가 포함되어 있다면, 캐시는 해당 응답을 저장해서는 안된다. Shared Cache의 경우에는 제약이 더 엄격해진다. 응답에 `private` 지시어가 있다면 특정 사용자(브라우저)만을 위한 응답이므로 공유 캐시에 저장될 수 없다. 또한 요청에 `Authrization` 헤더가 포함된 경우 인증된 사용자의 전용 정보일 가능성이 크기 때문에 `public`, `s-maxage`, `must-revalidate` 처럼 Shared Cache 저장을 명시적으로 허용하는 지시어가 응답에 포함되어 있어야만 저장이 가능하다.
  - 응답을 저장하기 위해서는 해당 응답이 얼마나 오랫동안 유효한지에 대한 정보나 캐싱 가능 여부를 나타내는 지시어(`public`, `Expires`, `max-age`, `s-maxage`)가 하나 이상 포함되어야 한다. 만약 이러한 지시어가 없더라도 Heuristicially(경험적) 캐싱이 가능한 상태 코드(예: 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501)라면 자체적인 알고리즘에 따라 응답을 저장할 수 있다.
  - 캐시 확장 기능을 사용하면 위에서 언급된 표준 요구사항들을 재정의할 수 있다. 또한 실무적으로 많은 캐시 서버들은 유효성 검사기(ETag, Last-Modified)나 명시적인 만료 시간이 없는 응답은 나중에 사용하기 어렵다고 판단하여 저장하지 않기도 한다. 하지만 표준 명세상으로는 이러한 응답들을 저장하는 것이 금지되어 있지는 않다.
- 캐시는 응답을 저장할 때, 모든 헤더 필드를 반드시 포함해야 한다. 다만, 다음 예외 사항들이 적용된다.
  - 응답 메시지를 전달하기 전에 `Connection` 헤더 필드 및 해당 필드에 명시된 필드들은 제거되어야 한다. 이는 캐시로 저장하기 전에 수행함으로써 구현될 수 있다.
  - 일부 필드의 의미론적 특성상 메시지 전달 전에 해당 필드를 제거해야 하며, 저장 전에 수행함으로써 구현될 수 있다. 예시는 [HTTP의 7.6.1절](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1)을 참조하라.
  - `no-cache`와 `private` 지시어는 각각 모든 캐시와 공유 캐시에 의한 헤더 필드 저장을 방지하는 값을 가질 수 있다.
    - `no-cache="field-name"` 형식을 사용하여 특정 헤더를 지정할 수 있다. 이 경우 캐시는 전체 응답을 저장할 수는 있지만, 지정된 헤더 필드는 원본 서버의 재검사(revalidation) 성공 없이는 후속 요청에 대한 응답으로 재사용해서는 안된다. 민감한 정보를 담고 있는 특정 헤더가 재사용되는 것을 방지하는 역할을 한다.
    - 기본적으로 `private`는 단일 사용자(브라우저)만을 위한 것이며, 공유 캐시(CDN, 프록시 등)에 저장되어서는 안됨을 의미한다. `private="field-name"` 형식을 사용하여 공유 캐시는 응답의 나머지 부분은 저장하고 재사용할 수 있지만, 지정된 헤더 필드만큼은 반드시 제거한 상태로 저장해야 하며 이를 다른 클라이언트에게 전달해서는 안된다. 이는 공유 캐시가 공통적인 콘텐츠는 캐싱하면서도, 개인 식별 정보나 권한 정보가 담긴 특정 헤더만 골라 제외할 수 있게 해준다.
  - 캐시가 요청을 전달할 때 사용하는 프록시에 특화된 헤더 필드는 캐시가 프록시의 식별자를 캐시 키에 포함시키지 않는 한 저장해서는 안된다. 실질적으로, `Proxy-Authenticate`, `Proxy-Authorization-Info`, `Proxy-Authorization`로 제한된다.

## 3.2. Updating Stored Header Fields
캐시는 유효성 재검사 등을 통해 새로운 응답(예: 304 Not Modified)을 받았을 때, 기존에 저장된 응답의 헤더 필드를 업데이트해야 한다.  
기본적으로 제공된 새로운 응답의 헤더 필드를 기존 응답에 추가하거나, 이미 존재하는 필드라면 새로운 값으로 교체하는 것이 원칙이다.  

하지만 모든 헤더를 무조건 교체해서는 안되며 아래 네 가지 예외 상황이 있다.     
  - `no-cache`와 `private` 지시어로 지정한 특정 헤더
  - 캐시가 저장한 응답 데이터 자체가 의존하고 있는 헤더 필드 (데이터의 형식이나 상태를 정의하기 위해 사용했던 메타데이터. 가장 대표적인 사례는 `Content-Encoding` 헤더이다. 서버가 gzip 방식으로 압축된 데이터를 보냈고, 브라우저가 이를 받아 압축을 해제한 상태로 캐싱했다고 가정했을 때, 이후 유효성 재검사 시 서버가 304 응답을 보내며 `Content-Encoding: br` 이라는 새로운 압축 방법을 명시한 헤더를 보낸다면, 캐시는 이 헤더를 업데이트해서는 안된다.)
  - 수신자에 의해 자동으로 처리되고 제거되는 필드
  - Content-Length 헤더 필드 (304 Not Modified는 본문을 포함하지 않으므로 이를 기준으로 헤더 값을 수정하면 무결성이 깨질 수 있기 때문)

특히 브라우저같은 사용자 에이전트 캐시는 원본 응답 그대로 저장하기보다, 처리 과정을 거친 결과물을 저장하는 경우가 많다. 예를 들어 서버로부터 받은 압축된 데이터를 해제해서 저장하거나, HTML을 파싱해서 생성된 DOM 트리 형태로 저장하기도 한다. 이 과정에서 새로운 응답의 헤더가, 저장해놓은 캐시 데이터의 `Content-Encoding`이나 `Content-Type` 헤더 값과 다른 경우 불일치 문제가 생길 수 있으므로 브라우저는 특정 헤더의 업데이트를 생략할 수 있다.

## 3.3. Storing Incomplete Response
네트워크 연결이 예기치 않게 종료되었거나 리소스의 일부분만 요청된 경우에도 캐시를 효율적으로 활용하기 위한 명세가 있다.

캐시는 GET 메서드를 통한 200 OK 응답의 헤더를 모두 수신했다면, 본문 데이터가 전부 도착하지 않더라도 이를 저장할 수 있는 권한을 가진다.  
이때 반드시 해당 데이터가 [불완전하다는 표시](https://www.rfc-editor.org/rfc/rfc9110#section-6.1)를 해야 한다.  
206 Partial Content 응답 또한 나중에 전체를 채워 넣을 수 있는 미완성된 200 OK 응답과 같은 성격으로 간주하여 저장할 수 있다.  
하지만, 캐시가 `Range`나 `Content-Range` 헤더 필드를 지원하지 않거나 해당 필드에서 사용되는 값의 단위를 이해하지 못한다면, 데이터 무결성을 보장할 수 없으므로 불완전한 응답을 저장하면 안된다.  

이미 저장된 불완전한 응답은 캐시가 스스로 부족한 부분에 대해 추가적인 범위 요청을 수행함으로써 완성될 수 있다.  
서버로부터 받은 새로운 데이터 조각을 기존 데이터와 결합하는 과정은 [3.4 Combining Partial Content](#34-combining-partial-content)의 규정을 따른다.  
이렇게 조립된 데이터가 완벽한 전체를 이루기 전까지 캐시는 이를 일반적인 요청에 대한 응답으로 사용해서는 안된다. 클라이언트에게 응답을 보낼 때의 규칙도 명확하다. 캐시는 불완전한 데이터를 전체 데이터인 것처럼 속여서 전달할 수 없으며, 오직 클라이언트가 요청한 범위가 캐시된 영역 내에 완벽하게 포함될 때만 일부분을 떼어 응답할 수 있다. 이 경우에도 캐시는 해당 응답이 전체가 아님을 나타내기 위해 반드시 206 Partial Content 상태 코드를 명시해야 한다. 

## 3.4. Combining Partial Content
HTTP 통신 과정에서 응답 본문 전체가 아닌 일부분만 전달되는 경우는 흔히 발생한다.  
네트워크 연결이 도중에 끊겨 데이터의 일부만 수신되었거나, 클라이언트가 특정 범위만 요청하는 Range 헤더를 사용한 경우이다.  
캐시는 이러한 과정을 반복하면서 동일한 리소스에 대해 서로 다른 여러 데이터 조각을 보유하게 될 수 있다.

캐시는 이 조각들을 하나의 응답으로 병합하여 저장할 수 있는 권한을 가진다.  
하지만 엄격한 전제 조건이 붙는다.  
병합하려는 모든 조각이, 동일한 강한 검사기(Strong Validator, 주로 ETag)를 공유해야 한다는 점이다.  
이는 각 조각이 정확히 동일한 버전의 리소스에서 파생된 것임을 보장하기 위함이다.  

데이터 조각들을 병합할 때, 캐시는 단순히 본문(Body)만 합치는 것이 아니라 메타데이터인 헤더 필드도 함께 관리해야 한다.  
캐시는 새롭게 수신된 응답에 포함된 헤더 필드들을 사용하여 기존에 저장된 응답의 헤더를 업데이트해야 합니다.  
이 과정은 앞서 살펴본 [섹션 3.2](#32-updating-stored-header-fields)의 업데이트 규칙을 따른다.

## 3.5. Storing Responses to Authenticated Requests
인증 정보(Authorization)가 포함된 요청에 대한 응답을 공유 캐시(Shared Cache)가 어떻게 처리해야 하는지에 대한 엄격한 보안 규칙이 있다.

기본적으로 공유 캐시(CDN, 기업 프록시 등)는 여러 사용자가 공용으로 사용하는 저장소이다.  
요청에 `Authorization` 헤더가 포함되어 있다는 것은, 해당 응답이 특정 사용자의 권한에 따라 생성된 개인적인 정보일 가능성이 매우 높음을 의미한다.  
만약 공유 캐시가 이 응답을 무분별하게 저장하고 다른 사용자에게 제공한다면, A 사용자의 개인 정보가 B 사용자에게 유출되는 심각한 보안 사고가 발생할 수 있다.  
따라서 공유 캐시는 `Authorization` 헤더가 있는 요청에 대한 응답을 원칙적으로 재사용할 수 없습니다.

하지만 서버가 해당 콘텐츠를 공유 캐시에 저장해도 안전하다고 판단할 때가 있다.  
서버가 다음과 같은 `Cache-Control` 지시어를 응답에 포함했을 경우에만 예외적으로 공유 캐시의 재사용을 허용한다.
- `must-revalidate`: 캐시된 응답이 Stale한 상태가 되면, 반드시 원본 서버를 통해 유효성 재검사를 거쳐야만 사용할 수 있다는 지시어이다. 이를 통해 서버는 매번 **권한을 다시 확인**할 기회를 갖게 된다.
- `public`: 해당 응답이 인증된 요청에 대한 결과일지라도 공유 캐시에 저장될 수 있음을 명시적으로 선언하는 지시어이다.
- `s-maxage`: 공유 캐시 전용 만료 시간을 지정한다. 이 지시어가 존재한다는 것 자체가 공유 캐시의 저장을 암시적으로 허용하는 것으로 간주된다.

# 4. Constructing Responses from Caches
캐시가 저장된 응답을 클라리언트에게 다시 응답하기 위해 반드시 충족해야 하는 조건과 운영 방식이 존재한다.

캐시는 요청을 받았을 때 다음의 조건들이 모두 만족되어야만 저장된 응답을 재사용할 수 있다.  
- 요청된 URI와 저장된 응답의 URI가 일치해야 한다.
- 요청 메서드 역시, 저장된 응답을 사용하기에 적절해야 한다.
- `Vary` 헤더 등에 의해 지정된 요청 헤더 필드들이 서로 일치해야 한다. (참고: [4.1 Calculating Cache Keys with the Vary Header Field](#41-calculating-cache-keys-with-the-vary-header-field))  
- 만약 응답에 `no-cache` 지시어가 있다면, 서버를 통한 유효성 검사를 성공적으로 마친 경우에만 재사용이 가능하다.  
- 해당 응답이 신선한 상태(Fresh)이거나, 신선하지 않더라도 서빙이 허용된 상태(Stale) 또는 유효성 검사가 완료된 상태여야 한다.

유효성 검사 없이 저장된 응답을 즉시 사용하는 경우, 캐시는 반드시 `Age` 헤더 필드를 생성해야 한다.  
이 헤더는 해당 응답이 캐시 저장소에 머문 시간을 초 단위로 나타낸다.  
기존에 응답에 포함되어 있던 `Age` 헤더가 있다면, 이를 현재 계산된 값으로 교체하여 전달해야 한다.  

_POST_, _PUT_, _DELETE_ 같이 서버의 상태를 변경할 수 있는 안전하지 않은 메서드(Unsafe methods)의 경우, 캐시는 이를 가로채서 응답할 수 없으며 반드시 원 서버로 전달(Write-through)해야 한다.  
이러한 요청들은 기존에 저장되어 있던 캐시 데이터를 무효화(Invalidate)시킬 수도 있다.

반면 캐시는 동일한 리소스에 대해 여러 요청이 동시에 들어올 때 이를 하나로 묶어 서버에 보내는 **요청 결합(Request Collapsing)** 기능을 수행할 수 있다.  
캐시에 데이터가 없는 상태(Cache Miss)에서 여러 명의 사용자가 같은 페이지를 요청하면, 캐시는 단 하나의 요청만 서버에 보내고 그 결과를 공유하여 서버와 네트워크의 부하를 줄인다.  
다만 서버가 보낸 응답이 특정 요청들에 대해 재사용이 불가능한 조건이라면, 캐시는 다시 개별적인 요청을 서버에 전달해야 하므로 지연 시간이 발생할 수 있다.

저장소에 적합한 응답이 여러 개 존재할 때는, `Date` 헤더를 기준으로 가장 최근에 생성된 응답을 사용해야 한다.  
하지만 네트워크 지연이나 서버 설정 문제로 `Date` 값이 불분명하거나, 여러 응답 중 어느 것이 서버의 현재 상태를 정확히 반영하는지 확신할 수 없는 모호한 상황이라면, `max-age=0`(요청자가 가장 Fresh한 데이터를 원한다는 의미다.) 또는 `no-cache`(서버가 캐시된 데이터를 사용하기 전에 반드시 자신의 현재 데이터와 대조하여 유효성을 확인하게 만든다.)를 포함해서 서버에 요청을 보냄으로써 이를 명확히 할 수 있다.  
또한 자체적인 시계 장치가 없는 캐시는 시간 흐름에 따른 신선도 계산이 불가능하므로, 저장된 데이터를 사용할 때마다 반드시 서버에 유효성 재검사를 요청해야 한다.

## 4.1. Calculating Cache Keys with the `Vary` Header Field
동일한 URI에 대해 요청 헤더의 내용에 따라 서로 다른 응답을 제공해야 하는 상황에서 캐시가 어떻게 정확한 응답을 식별하고 선택해야 하는지를 다루는 명세가 존재한다.

서버는 동일한 URI라도 클라이언트의 언어 설정(Accept-Language)이나 압축 지원 여부(Accept-Encoding)에 따라 다른 콘텐츠를 보낼 수 있다.  
이때 서버는 응답에 `Vary` 헤더를 포함하여, 어떤 요청 헤더가 응답의 내용을 결정했는지 캐시에게 알려줍니다. (예: `Vary: Accept-Language`)

캐시는 `Vary` 헤더가 포함된 응답을 재사용하기 전에, 현재 들어온 요청의 헤더들이 해당 응답을 저장하게 만들었던 원본 요청의 헤더들과 일치하는지 반드시 확인해야 한다.  
만약 일치하지 않는다면, 서버를 통한 유효성 재검사 없이는 해당 응답을 사용할 수 없다.  
특히 `Vary: *`가 포함된 응답은 모든 요청과 일치하지 않는 것으로 간주되어 항상 재사용에 실패한다.

두 요청의 헤더가 일치한다고 판단하는 기준은 단순히 텍스트가 똑같은지에 국한되지 않는다.  
다음과 같은 정규화 과정을 거친 후의 의미적 동일성을 기준으로 삼는다.
- 허용된 위치에서의 공백 추가 또는 제거
- 동일한 이름을 가진 여러 헤더 라인의 결합
- 해당 헤더 명세에 따른 의미론적 정규화(예: 순서가 중요하지 않은 값들의 재배치, 대소문자 구분 없는 값의 정규화)  

만약 특정 헤더가 한 요청에는 있고 다른 요청에는 없다면, 두 요청은 일치하지 않는 것으로 간주된다.

캐시 저장소에 특정 URI에 대해 일치하는 응답이 여러 개 존재할 수 있다.  
이때 캐시는 최선의 응답을 선택하기 위해 다음과 같은 우선순위를 따릅니다.
1. 우선순위 가중치(qvalues) 활용: `Accept` 계열의 헤더처럼 클라이언트가 선호도를 점수화하여 보낸 경우, 이를 기반으로 가장 적합한 응답을 선택할 수 있다.
2. 최신성 기준: 선호도 메커니즘이 없거나 동일한 선호도를 가진 응답이 여러 개라면, `Date` 헤더를 기준으로 가장 최근에 생성된 응답을 선택합니다.
3. `Vary` 누락 응답 처리: 일부 서버가 기본 응답에서 `Vary` 헤더를 실수로 누락시키는 경우가 있다. 이로 인해 부적절한 응답이 전달되는 것을 막기 위해, 캐시는 `Vary` 헤더가 없는 응답보다는 유효한 Vary 헤더를 가진 가장 최근의 응답을 우선적으로 선택한다.

저장된 어떤 응답도 현재 요청과 일치하지 않는다면, 캐시는 해당 요청을 스스로 처리할 수 없다.  
이 경우 캐시는 요청을 원 서버로 전달하며, 이때 자신이 이미 보유하고 있는 응답들을 설명하는 조건부 헤더(Preconditions)를 추가하여 서버가 더 효율적으로 판단할 수 있도록 돕는다.

## 4.2. Freshness
캐시된 응답은 신선한(Fresh) 상태와 신선하지 않은(Stale, 오래된) 상태 중 하나로 분류된다.  
응답의 나이(Age)가 신선도 수명(Freshness Lifetime)을 초과하지 않았다면 해당 응답은 신선하다고 간주된다.  
반대로 나이가 수명을 초과하면 신선하지 않은 것으로 판단한다.  
여기서 **나이란, 응답이 서버에서 생성되거나 유효성 검사를 마친 시점부터 흐른 시간**을 의미하며, **신선도 수명은 서버가 해당 응답을 캐시가 서버 확인 없이 사용해도 좋다고 허용한 전체 기간**을 뜻한다.  

신선도 여부를 결정하는 공식은 다음과 같다.  
`response_is_fresh = (freshness_lifetime > current_age)`

서버는 아래 두 가지 방식을 통해 응답의 만료 시간을 캐시에게 알린다.  

첫 번째는 명시적 만료 시간(Explicit Expiration Time)으로, `Expires` 헤더 필드나 `Cache-Control`의 `max-age` 지시어를 사용하여 미래의 특정 시점을 지정하는 방식이다.  
서버는 보통 해당 리소스가 지정된 시간 전까지는 의미 있게 변하지 않을 것이라는 판단하에 이 값을 설정한다.  
만약 서버가 캐시로 하여금 매번 유효성 검사를 하게 만들고 싶다면, 만료 시간을 과거의 날짜로 설정하여 응답이 생성되자마자 신선하지 않은 상태가 되도록 유도할 수도 있다.

두 번째는 경험적 만료 시간(Heuristic Expiration Time)이다.  
서버가 명시적인 만료 정보를 제공하지 않을 경우, 캐시는 특정 상황에서 자체적인 알고리즘을 동원하여 임의의 만료 시간을 할당할 수 있다.  
이는 [4.2.2. Calculating Heuristic Freshness](#422-calculating-heuristic-freshness)에 규정된 로직을 따른다.  

캐시는 신선도를 계산할 때 날짜 파싱에서 발생할 수 있는 오류를 방지하기 위해 엄격한 규칙을 준수해야 한다.  
모든 HTTP 날짜 형식은 대소문자를 구분하도록 되어 있지만, 캐시는 이를 대소문자 구분 없이 처리할 것이 권장된다.  
또한 캐시의 내부 시계 해상도(시스템이 시간을 인지하고 기록할 수 있는 최소한의 시간 간격이나 정밀도)가 HTTP 날짜 값보다 낮을 경우, 만료 시간을 실제 값보다 이전 시간으로 처리하여 보수적으로 관리해야 한다.  
특히 시간대 처리에서 중요한 규칙은 로컬 시간대가 계산에 영향을 주어서는 안 된다는 점이다.  
모든 계산은 GMT(그리니치 표준시)를 기준으로 이루어져야 하며, GMT 이외의 시간대 약어가 포함된 날짜는 만료 시간 계산 시 무효한 것으로 간주될 수 있다.  

클라이언트는 요청 시 `max-age`나 `min-fresh` 지시어를 사용하여 서버가 정한 신선도 계산 결과에 제한을 두도록 제안할 수 있다.  
하지만 캐시가 반드시 이 제안을 따라야 할 의무는 없다.  

마지막으로 주의할 점은 신선도 개념이 오직 캐시 운영에만 적용된다는 것이다.  
신선도가 지났다고 해서 사용자 에이전트(브라우저)가 화면을 강제로 새로고침하거나 리소스를 다시 불러와야 하는 것은 아니다.  
이는 캐싱 메커니즘과 브라우저의 히스토리 메커니즘(뒤로 가기 등)이 서로 다르게 동작하기 때문이며, 이에 대한 상세한 차이는 [RFC 9111 섹션 6](https://www.rfc-editor.org/rfc/rfc9111.html#history.lists)에서 다루고 있습니다.

### 4.2.1. Calculating Freshness Lifetime
캐시가 응답의 신선도 수명(freshness_lifetime)을 결정할 때, 아래 나열된 규칙 중 가장 먼저 일치하는 항목을 선택하여 결정한다.

1. `s-maxage`: 만약 캐시가 공유 캐시이고 응답에 `s-maxage`가 포함되어 있다면, 그 값을 신선도 수명으로 사용한다.
2. `max-age`: `s-maxage`가 없거나 캐시가 개인 캐시인 경우 `max-age` 값을 수명으로 채택한다. 
3. `Expires`: 위 지시어들이 없다면 _Expires - Date_ 계산식을 통해 수명을 계산한다. 여기서 `Date`는 응답이 생성된 시점의 서버 시각을 의미한다. 만약, 응답에 `Date` 헤더가 없다면 응답 메시지를 수신한 시각을 대신 사용한다.

명시적인 만료 정보가 전혀 없는 경우에는 바로 아래의 경험적 신선도(Heuristic Freshness) 규칙을 적용할 수 있다.  

데이터의 무결성을 위해 캐시는 중복되거나 충돌하는 지시어에 대한 처리 규칙도 준수해야 한다.  
동일한 지시어가 여러 번 나타나면 가장 먼저 나타난 값을 사용하거나, 혹은 해당 응답을 아예 신선하지 않은(Stale) 것으로 간주하여 응답을 안전하게 처리해야 한다.  
만약 `max-age`와 `no-cache`처럼 서로 충돌하는 지시어가 동시에 존재한다면, 캐시는 항상 더 엄격하고 제한적인 쪽(이 경우 no-cache)을 우선시하여 동작해야 한다.

마지막으로 캐시는 신선도 정보가 정수가 아니거나 형식이 잘못된 경우 등 유효하지 않은 정보를 포함하고 있다면, 해당 응답을 즉시 신선하지 않은 상태로 간주할 것을 권장받는다.  
이는 잘못된 캐시 정보로 인해 데이터가 의도치 않게 오랫동안 서빙되는 부작용을 막기 위한 보수적인 접근 방식이다.

### 4.2.2. Calculating Heuristic Freshness
경험적 신선도(Heuristic Freshness)는 서버가 응답의 명시적인 만료 정보를 제공하지 않을 경우, 캐시는 특정 상황에서 자체적인 알고리즘을 이용하여 할당하는 임의의 만료 시간을 의미한다. 

캐시는 저장된 응답에 명시적인 만료 시간이 이미 포함되어 있다면 절대로 경험적 추정 방식을 사용해서는 안된다.  
또한 아무 응답이나 마음대로 추정할 수 있는 것도 아니다.  
[RFC 9111 섹션 3](https://www.rfc-editor.org/rfc/rfc9111.html#response.cacheability)의 요건에 따라, 명시적인 신선도 정보가 없으면서도 상태 코드가 200, 301, 404 처럼 표준상 경험적으로 캐싱이 가능하다고 정의된 경우나, `public` 지시어 등을 통해 명시적으로 캐싱이 허용된 응답에 대해서만 이 방식을 적용할 수 있다.  

과거의 명세에서는 이러한 상태 코드들을 기본적으로 캐싱 가능(cacheable by default)하다고 불렀으나, 현재 명세에서는 경험적으로 캐싱 가능(heuristically cacheable)하다는 용어로 정리되었다.  

가장 대표적인 추정 방식은 `Last-Modified` 헤더를 이용하는 것이다.  
리소스가 마지막으로 수정된 시각이 포함되어 있다면, 캐시는 리소스가 생성된 시각(Date)과 마지막 수정 시각 사이의 간격을 계산한다.  
표준 명세는 이 간격의 일정 비율을 만료 시간으로 잡는 방식을 권장하며, 보통 그 비율은 10% 정도로 설정된다.  

예를 들어 어떤 리소스가 서버에서 100시간 전에 수정되었다면, 캐시는 앞으로 10시간 동안은 리소스가 변하지 않을 것이라고 추정하여 신선한 상태로 간주할 수 있다.  
이는 오래전에 수정된 데이터일수록 앞으로도 한동안은 유지될 가능성이 높다는 가설에 기반한다.  

과거 RFC 2616 명세에서는 물음표(?)가 포함된 쿼리 컴포넌트 URI의 경우 경험적 신선도 계산을 아예 금지하기도 했다.  
동적인 데이터를 다루는 경우가 많아 캐싱하기에 위험하다고 판단했기 때문이다.  
하지만 실제 실무 환경에서는 이러한 제약이 널리 지켜지지 않았고, 현재의 표준은 이를 강제로 금지하지 않는다.  
대신 서버 운영자들에게 캐싱을 원치 않는 동적 리소스가 있다면 표준의 자동적인 처리에 기대지 말고 `Cache-Control: no-cache`와 같은 명시적인 지시어를 반드시 보낼 것을 강력히 권고하고 있다.

### 4.2.3. Calculating Age
캐시된 응답의 현재 나이(_current_age_)를 계산하는 정교한 알고리즘을 정의한다.  

`Age` 헤더는 응답이 원 서버에서 생성되거나 유효성이 확인된 이후부터 현재까지 흐른 전체 시간을 초 단위로 나타내며, 이는 여러 캐시 계층을 거치며 합산된 시간과 네트워크 전송 시간을 모두 포함한다.

정확한 계산을 위해 다음 다섯 가지 데이터가 사용된다.
- `age_value`: 서버로부터 받은 응답에 포함된 `Age` 헤더 값이다. 없으면 0으로 간주한다.
- `date_value`: 서버가 응답을 생성한 시각을 나타내는 `Date` 헤더 값이다.
- `now`: 현재 캐시 시스템의 시계 값이다.
- `request_time`: 캐시가 서버에 요청을 보낸 시점의 시각이다.
- `response_time`: 캐시가 서버로부터 응답을 받은 시점의 시각이다.

캐시는 두 가지 독립적인 방식으로 응답의 초기 나이를 추정한다.
1. 겉보기 나이(apparent_age): 캐시가 응답을 받은 시각에서 서버의 생성 시각을 뺀 값이다 ($response\_time - date\_value$). 서버와 캐시의 시계가 잘 동기화되어 있다는 전제하에 작동하며, 음수가 나오면 0으로 처리한다.
2. 보정된 나이 값(corrected_age_value): 네트워크 지연 시간을 고려한 방식이다. 요청을 보낸 시점부터 응답을 받은 시점까지의 시간($response\_delay$)을 $age\_value$에 더하여 계산합니다. 이는 응답이 전송되는 동안 흐른 시간까지 나이에 포함시키기 위함이다.

두 방식 중 더 보수적(안전)인 값을 선택하기 위해 다음 공식을 사용합니다.  
$$corrected\_initial\_age = max(apparent\_age, corrected\_age\_value)$$  
이 값은 응답이 캐시에 막 도착했을 때의 시점 기준 나이가 됩니다.

마지막으로 응답이 캐시 저장소에 머문 시간($resident\_time$)을 고려해야 한다.  
캐시에 저장된 이후 현재($now$)까지 흐른 시간을 초기 나이에 더하면 비로소 최종적인 현재 나이가 도출된다.  
$$resident\_time = now - response\_time$$
$$current\_age = corrected\_initial\_age + resident\_time$$

이 알고리즘의 핵심 목적은 서버와 캐시 간의 시계 불일치(Clock Skew)나 네트워크 전송 지연으로 인해 발생할 수 있는 오차를 최소화하는 것이다.  
캐시는 항상 가능한 가장 큰 값을 나이로 채택함으로써, 리소스를 실제보다 신선하다고 오판하여 오래된 데이터를 서빙하는 보안 및 무결성 위험을 방지한다.

### 4.2.4. Serving Stale Response
신선하지 않은(Stale) 응답이란 명시적인 만료 정보가 있거나 경험적 만료 시간이 계산되었음에도 불구하고, 앞서 살펴본 신선도 계산 공식에 의해 유효 기간이 지난 응답을 의미한다.  
캐시의 기본 원칙은 이러한 오래된 데이터를 사용하지 않는 것이지만, 특정 예외 상황에서는 이를 서빙하는 것이 허용된다.

프로토콜상의 명시적인 지시어가 있는 경우, 캐시는 어떤 상황에서도 오래된 응답을 클라이언트에게 보내서는 안된다. 다음과 같은 지시어들이 이에 해당한다.  
- `no-cache`: 저장소의 응답을 사용하기 전 반드시 서버의 재검증을 거쳐야 한다. 이름 때문에 저장 자체를 하지 않는 것으로 오해하기 쉽지만, HTTP 명세에서 저장조차 허용하지 않는 지시어는 `no-store`이다. `no-cache`는 저장된 응답을 사용할 때마다 원본 서버에 데이터 유효성을 검증 받으라는 **강제 재검증 지시**이다.
- `must-revalidate`: 응답이 신선하지 않게 되면 반드시 서버의 재검증을 거쳐야 하며, 서버 연결 실패 시 오래된 응답을 대신 보내는 행위도 금지된다.
- `proxy-revalidate` / `s-maxage`: 공유 캐시에 대해 `must-revalidate`와 유사한 엄격한 재검증 의무를 부여한다.

위의 금지 지시어가 없는 경우에 한해서, 다음 상황에서만 Stale한 응답을 전달할 수 있다.  
- 연결 단절(Disconnected): 캐시가 원 서버와 통신할 수 없는 네트워크 단절 상태일 때, 서비스 연속성을 위해 저장된 데이터를 제공할 수 있다.
- 클라이언트의 허용: 클라이언트가 요청 헤더에 `max-stale` 지시어를 포함하여, "N초가 지난 데이터라도 괜찮다"고 명시한 경우다.
- 서버의 허용 및 확장 지시어: 서버가 `stale-while-revalidate`나 `stale-if-error` (RFC 5861)와 같은 확장 지시어를 통해 특정 조건에서 오래된 응답의 사용을 허용한 경우다.
- 별도 계약: 프로토콜 외부의 대역 외(Out-of-band) 설정이나 계약에 따라 합의된 경우다.

## 4.3. Validation
검증(_Validation_) 또는 재검증(_Revalidation_)은, 캐시가 저장된 데이터를 가지고는 있지만 그 데이터를 그대로 사용하기에는 확신이 없을 때(신선도가 지났거나 여러 후보 중 선택이 어려울 때), 원 서버의 판단을 구하는 과정이다.

캐시가 저장된 응답을 직접 내보낼 수 없는 상황이 되면, 해당 요청을 서버로 전달하면서 캐시가 이미 가지고 있는 정보들을 함께 보낸다.  
이때 사용되는 것이 [HTTP의 조건부 요청(Conditional Request) 메커니즘](https://www.rfc-editor.org/rfc/rfc9110#section-13)이다.  
캐시는 `If-None-Match`(ETag 기반)나 `If-Modified-Since`(날짜 기반) 같은 헤더를 요청에 추가하여, "내가 이런 버전을 가지고 있는데, 혹시 바뀐 게 있나요?"라고 서버에 묻는다.

요청을 받은 서버는 캐시가 보낸 조건부 헤더를 보고 두 가지 중 하나를 선택합니다.
1. 기존 데이터가 유효한 경우 (304 Not Modified): 서버의 리소스가 캐시의 것과 다르지 않다면, 서버는 본문을 생략한 304 응답을 보낸다. 이 응답에는 새로운 만료 시간 정보 등이 포함될 수 있으며, 캐시는 이를 바탕으로 기존 저장된 응답의 메타데이터(헤더)를 업데이트하여 다시 신선한 상태로 만든다.
2. 데이터가 바뀌었거나 새로운 응답이 필요한 경우 (200 OK 등): 서버의 리소스가 변경되었다면, 서버는 새로운 전체 응답을 보냅니다. 캐시는 기존에 저장되어 있던 낡은 데이터를 폐기하고 이 새로운 응답으로 교체하여 저장한다.

이 과정의 가장 큰 이점은 데이터의 최신성을 보장하면서도 네트워크 비용을 최소화한다는 점이다.  
304 응답이 오는 경우 실제 데이터(Body)의 전송이 생략되므로, 캐시는 아주 적은 네트워크 비용만으로 기존 데이터를 다시 사용할 수 있는 정당성을 확보하게 된다.  

### 4.3.1. Sending a Validation Request
캐시가 서버에 데이터 유효성을 확인하기 위해 조건부 요청을 생성하고 전송하는 구체적인 절차를 다룬다.

캐시는 클라이언트의 요청을 처리하는 과정에서 검증이 필요할 때 해당 요청을 기반으로 시작하거나, 스스로 독립적인 요청을 만들어낼 수도 있다.  
독립적인 요청을 만들 때는 기존에 저장된 응답에서 메서드, 대상 URI, 그리고 Vary 헤더에 정의된 요청 헤더들을 복사하여 요청의 뼈대를 구성한다.  
여기에 캐시는 저장된 응답에 포함되어 있던 검증자(Validator) 메타데이터를 활용하여 전제 조건(Precondition) 헤더를 추가한다.  
이 과정은 서버가 캐시의 데이터와 현재 서버의 데이터가 동일한지 비교할 수 있는 근거를 제공한다.

명세에서는 두 가지 주요 검증자를 제시한다.
- `Last-Modified` (타임스탬프): 리소스가 마지막으로 수정된 시각을 나타낸다. 주로 `If-Modified-Since` 헤더에 사용되어 해당 시각 이후에 데이터가 변경되었는지 확인하는 데 쓰인다.
- `ETag` (엔티티 태그): 리소스의 특정 버전을 식별하는 고유한 문자열이다. 하나 이상의 `ETag`를 `If-None-Match` 헤더에 실어 보내 서버의 현재 데이터가 캐시된 버전 중 하나와 일치하는지 확인한다. `ETag`는 시간 기반 검증보다 정밀하다.

캐시는 조건부 요청을 보낼 때 다음과 같은 의무 사항을 준수해야 한다.
- `ETag` 우선 전송 (MUST): 저장된 응답에 ETag가 포함되어 있었다면, 반드시 관련 엔티티 태그를 전송해야 한다. 이는 데이터의 정확한 버전을 식별하는 가장 확실한 방법이기 때문이다.
- `Last-Modified` 전송 권장 (SHOULD): 범위 요청(Subrange)이 아니고 단일 응답을 검증하는 상황에서 `Last-Modified` 값이 있다면 이를 `If-Modified-Since`와 함께 보낼 것이 권장된다.
- 범위 요청 시의 예외 (MAY): 부분 데이터(Subrange)를 요청할 때 `ETag` 없이 `Last-Modified`만 있다면 이를 `If-Unmodified-Since`나 `If-Range`와 함께 보낼 수 있다.

실무적으로 캐시는 `ETag`가 더 우수함에도 불구하고 두 종류의 검증자를 모두 보내는 경우가 많다. 이는 `ETag`를 이해하지 못하는 오래된 중간 서버들도 적절하게 응답할 수 있도록 호환성을 배려하기 위함이다.

### 4.3.2. Handling a Received Validation Request
클라이언트(브라우저나 하위 캐시)로부터 조건부 요청을 받은 중간 캐시(프록시, CDN 등)가 이를 어떻게 처리해야 하는지에 대한 규칙을 정의한다.

캐시 체인(Request Chain)에서 중간 캐시는 서버 역할과 클라이언트 역할을 동시에 수행한다.  
하위 캐시로부터 조건부 요청을 받았을 때, 중간 캐시는 자신이 저장한 응답이 그 조건을 만족하는지 먼저 확인해야 한다.  
만약 저장된 `200 OK` 또는 `206 Partial Content` 응답으로 요청을 해결할 수 있다면, 요청에 포함된 조건부 헤더(Precondition)를 저장된 응답의 검증자(Validator)와 대조하여 평가해야 한다.  
단, 캐시는 모든 조건부 헤더를 처리해서는 안된다.  
원 서버에만 적용되어야 하는 조건(예: 특정 리소스의 존재 여부 확인 등), 캐시된 응답으로 해결할 수 없는 의미를 가진 요청, 또는 해당 리소스에 대한 저장된 응답이 없는 경우에는 조건부 헤더를 평가하지 말고 서버로 전달해야 한다.

캐시가 조건부 요청을 평가할 때는 아래 우선순위를 따른다.  
- `If-None-Match`가 있다면 `If-Modified-Since`보다 먼저 평가한다.
- `If-Match`와 `If-Unmodified-Since`는 일반적으로 캐시에서 처리하기보다는 원 서버로 전달되어야 하는 헤더로 간주한다.
- 만약 `If-Modified-Since` 요청을 받았는데 저장된 응답에 `Last-Modified` 헤더가 없다면, 캐시는 저장된 응답의 `Date` 헤더(없다면 수신 시각)를 기준으로 수정 여부를 판단해야 한다.

중간 캐시가 자신의 저장된 응답을 서버로부터 재검증받기 위해 요청을 전달할 때, **ETag 결합(Union) 기법**을 사용할 수 있다.  
1. 클라이언트가 보낸 `If-None-Match` 리스트와 캐시 자신이 보낸 리소스를 검증하기 위한 `ETag` 리스트를 하나로 합쳐서 서버에 보낼 수 있다. 이를 통해 한 번의 요청으로 클라이언트와 캐시 모두의 데이터를 동시에 검증한다.
2. 단, 캐시가 리소스의 일부분(_Partial Content_)만 가지고 있다면, 클라이언트의 요청 범위가 자신이 가진 데이터로 완전히 충족될 때만 해당 `ETag`를 리스트에 포함할 수 있다.

서버로부터 `304 Not Modified` 응답을 받았을 때, 서버가 보낸 `ETag`가 캐시에는 있지만 클라이언트의 요청 리스트에는 없는 경우를 주의해야 한다.  
이 상황은 캐시가 클라이언트보다 최신 버전(또는 다른 버전)을 가지고 있음을 의미한다.  
이때 캐시는 클라이언트에게 304를 그대로 전달하는 대신, 자신이 가진 저장된 응답을 304의 메타데이터로 업데이트한 후 200 OK 응답으로 조립하여 클라이언트에게 보내야 한다.  
이는 클라이언트가 요구한 조건을 캐시가 이미 만족하는 최신 데이터로 보완하여 해결해 주는 과정이다.

### 4.3.3. Handling a Validation Response
캐시가 보낸 조건부 요청에 대해 서버가 보내온 응답 상태 코드에 따라 캐시가 어떻게 행동해야 하는지 정의한다.

서버의 응답은 크게 세 가지 시나리오로 나뉜다.
1. `304 Not Modified` 응답을 받은 경우, 캐시가 서버에 보낸 검증자(`ETag` 또는 `Last-Modified`)가 서버의 현재 데이터와 일치함을 의미한다. 이때 캐시는 서버로부터 본문(Body)을 다시 받을 필요가 없으므로, 기존에 저장된 응답을 최신 상태로 업데이트하여 재사용한다. 구체적인 업데이트 방법은 [4.3.4. Freshening Stored Responses upon Validation](#434-freshening-stored-responses-upon-validation)의 규칙을 따른다.
2. 전체 응답(`200 OK` 등)을 받은 경우, 캐시가 보낸 조건부 요청의 전제 조건이 충족되지 않았음을 의미하며, 서버의 리소스가 변경되었거나 캐시가 가진 것보다 최신 버전의 데이터가 서버에 있음을 뜻한다. 이때 캐시는 저장된 응답을 무시하고 서버가 보낸 전체 응답을 사용하여 클라이언트의 요청에 답해야 한다. 또한, [3. Storing Responses in Caches](#3-storing-responses-in-caches)의 저장 제약 조건을 만족한다면 이 새로운 전체 응답을 저장소에 기록하여 기존 데이터를 대체할 수 있다.

캐시가 유효성 검사를 시도하는 도중에 서버로부터 5xx (Server Error) 응답을 받는 특수한 상황이 발생할 수 있다. 이때 캐시는 두 가지 선택권을 가진다.
1. 서버에서 받은 5xx 에러를 클라이언트에게 그대로 전달한다. 
2. 서버가 응답하지 않은 것으로 처리하고 자체적으로 대응한다. 이 경우 캐시는 [4.2.4. Serving Stale Responses](#424-serving-stale-response)의 제약 조건(예: `must-revalidate`가 없는 경우 등)을 충족한다면 이전에 저장된 응답(Stale Response)을 대신 클라이언트에게 보낼 수 있다. 또는 유효성 검사 요청을 다시 시도할 수도 있다.

### 4.3.4. Freshening Stored Responses upon Validation
서버로부터 304(Not Modified) 응답을 받았을 때, 캐시가 저장소에 있는 어떤 응답들을 찾아내어 업데이트해야 하는지 그 정교한 필터링 과정을 정의한다.

캐시는 먼저 현재 요청에 대해 사용될 수 있었던 모든 저장된 응답들을 후보군으로 삼는다.  
이는 [4. Constructing Responses from Caches](#4-constructing-responses-from-caches)에서 정의한 조건(URI 일치, 메서드 허용 등)을 만족하는 응답들을 의미한다.  
다만, 신선도(Freshness) 요건은 제외한다. 유효성 검사 자체가 신선하지 않은 데이터를 갱신하기 위해 수행되는 것이기 때문이다.

후보군이 정해지면, 캐시는 서버가 보낸 304 응답의 검증자 정보를 바탕으로 다음의 우선순위에 따라 최종 업데이트 대상을 확정한다.
1. 강한 검사기(Strong Validator) 우선 적용: 서버 응답에 하나 이상의 강한 검사기(예: `ETag`)가 포함된 경우, 캐시는 후보군 중 이와 정확히 일치하는 강한 검사기를 가진 모든 응답을 업데이트 대상으로 선택한다. 만약 후보군 중에 서버가 보낸 것과 일치하는 강한 검사기가 하나도 없다면, 캐시는 해당 304 응답을 사용하여 어떤 기존 응답도 업데이트해서는 안 된다.
2. 약한 검사기(Weak Validator) 적용: 서버 응답에 강한 검사기는 없고 약한 검사기(예: `W/` 접두사가 붙은 `ETag`)만 있는 경우이다. 이때 캐시는 후보군 중에서 이 약한 검사기와 일치하는 응답들을 찾고, 그중 가장 최신의 응답 하나만을 선택하여 업데이트한다.
3. 검사기가 없는 경우: 서버 응답에 어떤 검증자도 포함되어 있지 않은 특수한 상황(예: 클라이언트가 `Last-Modified` 없이 `If-Modified-Since`를 생성한 경우 등)이다. 이때 후보군에 단 하나의 응답만 존재하고, 그 응답 역시 검증자를 가지고 있지 않다면 해당 응답을 업데이트 대상으로 선택한다.

최종적으로 선택된 저장된 응답에 대해, 캐시는 반드시 서버가 보낸 304 응답의 헤더 필드를 사용하여 기존 헤더를 업데이트해야 한다.  
이 과정은 [3.2. Updating Stored Header Fields](#32-updating-stored-header-fields)에서 정의한 규칙을 엄격히 따른다.  
이를 통해 캐시된 데이터의 본문(Body)은 그대로 유지하면서, 서버가 새로 보낸 신선도 정보(Cache-Control 등)를 반영하여 리소스의 유효 수명을 연장하게 된다.

### 4.3.5. Freshening Responses with HEAD
HEAD 메서드를 사용하여, 저장된 GET 응답을 갱신하거나 무효화하는 방법을 정의한다.  
HEAD 응답은 본문 데이터 없이 메타데이터(헤더)만 포함하므로, 전체 데이터를 다시 받지 않고도 캐시를 관리하는 효율적인 수단이 된다.

HEAD 메서드의 특성은 응답 본문을 제외하고 GET과 동일한 헤더 정보를 제공한다는 점이다.  
이 속성은 두 가지 상황에서 유용하다.  
첫째, 저장된 응답에 검증자(Validator)가 없어 효율적인 조건부 GET 요청을 보낼 수 없는 경우이다.  
둘째, 리소스가 변경되었더라도 당장 본문 데이터를 전송받고 싶지 않을 때이다.  
캐시는 원 서버에 HEAD 요청을 보내 받은 200 OK 응답을 바탕으로 기존의 GET 응답들을 최신 상태로 유지하거나, 더 이상 유효하지 않다고 판단하여 무효화할 수 있다.

캐시는 HEAD 요청에 대한 200 OK 응답을 받으면, 해당 요청에 선택될 수 있었던 모든 저장된 GET 응답들을 대상으로 다음의 일치 여부를 검사한다.
1. 검증자 일치: 저장된 응답과 HEAD 응답이 가진 검증자 필드(`ETag`, `Last-Modified`)의 값이 서로 일치해야 한다.
2. 콘텐츠 길이 일치: 만약 HEAD 응답에 `Content-Length` 헤더가 포함되어 있다면, 이 값이 저장된 GET 응답의 본문 크기와 정확히 일치해야 한다.  

이 조건들을 모두 만족하면 캐시는 저장된 응답이 여전히 유효하다고 판단하여 메타데이터를 업데이트한다.  
만약 하나라도 일치하지 않는다면, 캐시는 해당 저장된 응답이 더 이상 최신 상태가 아니라고 간주하여 신선하지 않은(Stale) 상태로 처리해야 한다.

조건을 만족하여 업데이트를 진행하기로 결정했다면, 캐시는 반드시 HEAD 응답에서 제공된 헤더 필드들을 사용하여 기존 저장된 GET 응답의 메타데이터를 갱신해야 한다.  
이 과정은 [3.2. Updating Stored Header Fields](#32-updating-stored-header-fields)에서 정의한 일반적인 헤더 업데이트 규칙을 엄격히 따른다.  
이를 통해 본문 데이터를 다시 다운로드하지 않고도, `Cache-Control`이나 `Expires` 같은 수명 관련 정보를 서버의 최신 지침에 맞게 수정할 수 있다.

## 4.4. Invalidating Stored Responses
서버의 상태를 변경할 수 있는 '안전하지 않은 메서드(Unsafe methods)' 요청이 발생했을 때, 캐시가 데이터의 최신성을 유지하기 위해 기존에 저장된 응답을 어떻게 무효화해야 하는지 정의한다.

_PUT_, _POST_, _DELETE_와 같은 메서드는 서버의 데이터를 수정, 생성 또는 삭제하는 작업에 사용된다.  
만약 어떤 URI에 대해 POST 요청이 성공했다면, 해당 URI에 대해 이전에 저장되어 있던 GET 응답은 더 이상 유효하지 않을 가능성이 높다.  
따라서 중간 캐시는 데이터 불일치를 방지하기 위해 관련된 캐시 엔트리를 무효화해야 할 의무가 있다.

캐시는 안전하지 않은 메서드(또는 안전 여부를 알 수 없는 메서드)에 대해 2xx(성공) 또는 3xx(리다이렉션)와 같은 '오류가 없는 응답(Non-error response)'을 받았을 때 다음과 같이 동작한다.
1. 대상 URI 무효화 (MUST): 요청의 대상이 된 URI(Target URI)에 대한 저장된 응답은 반드시 무효화해야 한다.
2. 연관 URI 무효화 (MAY): 응답 헤더의 `Location`이나 `Content-Location`에 명시된 URI들 또한 무효화할 수 있다. 서버가 리소스를 생성하거나 이동시킨 경우, 해당 주소들의 기존 캐시도 최신이 아닐 수 있기 때문이다.
3. 보안 제약 (MUST NOT): 무효화하려는 URI의 오리진(Origin, 스킴/호스트/포트 조합)이 요청 대상 URI의 오리진과 다르다면 절대로 무효화를 수행해서는 안 된다. 이는 공격자가 타 도메인의 캐시를 임의로 삭제하는 서비스 거부(DoS) 공격을 방지하기 위한 필수적인 보안 장치이다.

여기서 무효화란 단순히 데이터를 지우는 것만을 의미하지 않는다.  
캐시는 해당 URI와 일치하는 모든 저장된 응답을 물리적으로 삭제하거나, 혹은 '무효(Invalid)' 상태로 표시하여 이후의 요청에 대해 반드시 서버의 재검증(Mandatory Validation)을 거치도록 강제해야 한다.

이러한 무효화 규칙은 완벽한 전역 동기화를 보장하지 않는다.  
특정 상태 변경 요청은 오직 해당 요청이 거쳐 간 경로상의 캐시들에 대해서만 무효화를 트리거한다.  
따라서 **네트워크의 다른 경로에 있는 캐시들은 여전히 과거의 응답을 보유하고 있을 수 있다**.  
이는 **HTTP 캐싱 시스템이 가진 구조적 특성**이며, 이를 보완하기 위해 서버는 적절한 만료 시간(`Expiration`) 정책을 병행하여 사용해야 한다.

# Syntax
`Cache-Control`의 구문은 다음과 같다.  
`Cache-Control: <directive>, <directive>, ...`

지시어(directive)는 아래 규칙을 따라야 한다.

- 대소문자를 구분하지 않지만 소문자를 권장한다. 왜냐하면 일부 구현체에서는 대문자 지시어를 인식하지 못할 수 있기 때문이다.
- 일부 지시어는 인자가 없어도 된다. 하지만 인자가 포함된 지시어의 경우 `=`를 통해 지시어를 정의한다.
- 여러 개의 지시어는 `, `를 통해 구분한다.

예: `Cache-Control: no-cache, no-store, max-age=0, must-revalidate`

# 관련 용어

- (HTTP) Cache: 후속 요청에서 재사용하기 위해 요청과 응답을 보관하는 구현체이다. 공유 캐시(Shared Cache) 또는 개인 캐시(Private Cache)일 수 있다.
- Shared Cache: Origin Server와 Client 사이에 존재하는 캐시이다 (예: 프록시, CDN). 하나의 응답을 저장하고, 여러 사용자에게 재사용하므로 개발자는 공유 캐시에 저장될 개인화된 콘텐츠를 캐싱하지 않도록 해야 한다.
- Private Cache: 클라이언트(브라우저)에 존재하는 캐시다. 로컬 캐시 또는 브라우저 캐시라고도 한다. 단일 사용자를 위한 개인화된 콘텐츠를 저장하고 재사용할 수 있다.
- Store Response: 응답이 캐시 가능한 경우 캐시에 응답을 저장한다. 하지만 캐시된 응답이 항상 그대로 재사용되는 것은 아니다. (일반적으로 '캐시'는 응답을 저장하는 것을 의미한다.)
- Reuse Response: 후속 요청에 대해 캐시된 응답을 재사용한다.
- Revalidate Response(재검증 응답): Origin 서버에 저장된 응답이 여전히 유효한지 여부를 확인한다. 일반적으로 재검증은 조건부 요청을 통해 수행된다.
- Fresh Response: 응답이 최신(Fresh)임을 나타낸다. 이는 일반적으로 후술될 요청 지시어에 따라 후속 요청에 재사용될 수 있다.
- Stale Response: 응답이 오래된 응답임을 나타낸다. 이는 일반적으로 응답을 그대로 재사용할 수 없음을 의미한다. 캐시 저장소는 오래된 응답을 즉시 제거할 필요는 없다. 재검증 과정을 통해 응답이 오래된 상태에서 다시 최신 상태(Fresh)로 변경될 수 있기 때문이다.

# `Age` HTTP 헤더 필드
`Age` 헤더 필드는 HTTP 응답이 Origin 서버에서 생성된 후 네트워크 상의 중간 캐시(프록시 서버, CDN 등)에 얼마나 머물렀는지를 초 단위로 나타내는 값이다.  
값이 실시간으로 업데이트되는 것은 아니고, 캐시 서버가 저장하고 있던 HTTP 응답을 클라이언트에게 전달하는 시점에 그동안 경과한 시간을 계산하여 값을 갱신하는 구조이다.




# 지시어(Directives)

## 응답 지시어(Response Directives)

### `max-age`
`max-age=N`는 HTTP 응답이 생성된 후 N초 동안만 Fresh Response로 유지됨을 의미한다.  
캐시가 이 HTTP 응답을 저장하고, Fresh 상태일 동안에만 재사용할 수 있음을 나타낸다.

`max-age`는 응답을 수신한 이후로부터 경과한 시간이 아니라, Origin 서버에서 응답이 생성된 이후 경과한 시간임을 유의해야 한다.  

# Cache-Control 명세
요청에 특정 지시어가 있다고 해서, 응답에도 동일한 지시어가 포함되거나 복사되어야 함을 의미하지는 않는다.  
프록시는 캐시 구현 여부와 관계없이 전달받은 캐시 지시어를 그대로 다음 단계로 전달해야 한다.  
이는 해당 지시어가 현재 단계에 중요하지 않더라도, 요청 및 응답 경로상의 다른 단계에 적용될 수 있기 때문이다.

특정 캐시만을 대상으로 지시어를 지정하는 것은 불가능하다.

각 지시어는 토큰으로 식별되며, 대소문자를 구분하지 않는다.

# `Age` 응답 헤더 필드
RFC 9111에서 `Age` 응답 헤더 필드에 대한 정의에 따르면, '서버에서 응답이 생성된 시점 또는 Origin 서버에서 유효성 검사를 완료한 시점으로부터 경과한 시간을 추정한 값'이다.  
말이 조금 어려운데, 단순한 의미로는 "리소스가 프록시 캐싱 내에 머문 시간"을 의미한다.

대부분 `Age` 필드 값은 매우 짧은데, 값이 0이라면 Origin Server로부터 리소스를 가져온 것일 가능성이 높다. 
0이 아니라면, 일반적으로 프록시 서버의 날짜와 HTTP 응답에 포함된 `Date` 헤더 필드의 값의 차를 의미한다.

> 계산식: `Age = delta-seconds`

필드 값은 0 이상의 값이며, 시간(초)를 나타낸다.    
만약 필드 값이 리스트 형식인 경우 첫 번째 요소의 값만 사용한다.    
만약 단일 값 혹은 리스트의 첫 번째 요소의 값이 0 미만의 유효하지 않은 값인 경우, 캐시는 해당 필드를 무시해야 한다.

Age 헤더 필드가 있다는 것은, 해당 요청에 대해서 Origin 서버에서 응답이 생성되거나 유효성 검사를 완료하지 않았음을 의미한다.  
그러나 Age 헤더 필드가 없다고 해서 원본 서버에 연결되지 않았다는 것을 의미하지 않는다.

# 서버가 보내는 지시어(응답 지시어)
- `max-age`
  - 응답이 생성된 후 N초까지 응답이 최신 상태로 유지됨을 나타낸다.
  - 응답 수신 시점부터 경과된 시점이 아니라, Origin 서버에서 응답이 생성된 시점부터 

# 클라이언트가 보내는 지시어(요청 지시어)
요청 지시어는 브라우저가 서버에 데이터를 요청할 때, "나는 이런 상태의 데이터를 받고 싶다"고 요구하는 설정들이다.  
여기서 데이터는 캐시 데이터일 수도 있고, Origin 서버의 원본 데이터일 수도 있다.
해당 지시어는 캐싱에 대한 **권장 사항**이며, Origin 서버는 요청 지시어대로 캐시 정책을 구현할 수는 있지만 필수 사항은 아니다.

## `max-age`, `max-stale`, `min-fresh`
- `max-age`
  - 클라이언트가 지정한 `max-age` 초 이내의 데이터만 받겠다는 뜻이다. 만약, `max-age`가 60인데 리소스의 `Age`가 60일 경우 해당 리소스를 그대로 재사용하고, 60초를 넘은 경우 서버로 요청을 보내게 된다.
  - `max-age=5`와 같이 사용해야 하며, `max-age="5"` 와 같이 사용해선 안된다.

- `max-stale`
  - 유효 기간이 지난 캐시 데이터더라도, 클라이언트가 지정한 `max-stale` 초 이내의 데이터도 재사용하겠다는 의미다.
  - `max-stale` 값이 없다면 유효 기간이 지난 데이터에 대한 요청은 반드시 서버로 요청을 보낸다.

- `min-fresh`
  - 클라이언트가 현재 `Age`에 N초를 더한 시간 동안에도 여전히 Fresh함을 유지하는 응답을 원할 때 사용한다. 즉, 최소한 `min-fresh`에 지정한 시간만큼은 더 신선한 상태로 남아있을 응답을 요구하는 것이다.
  - 
    - 클라이언트가 최소 N초 동안 유효한 저장된 응답을 허용함을 나타낸다. 클라이언트는 `min-fresh`에 지정한 초 동안 최신 상태를 유지하는 응답을 요구한다. 응답의 Fresh 유지 기간이 `Age + min_fresh` 보다 이상인 응답을 선호한다.  
    - `min-fresh=20`과 같이 사용해야 하며, `min-fresh="20"` 과 같이 사용해선 안된다.

# 참고
- [RFC 9111 - HTTP Caching](https://www.rfc-editor.org/rfc/rfc9111.html)
- [RFC 9110 - HTTP](https://www.rfc-editor.org/rfc/rfc9110.html)

# 다 쓰면 한번 봐볼것
[김예지 약사 - 하루 15시간 공부가 쉬워집니다.](https://youtu.be/ylFGQVSpoF8?si=Oq-xZRbNjnHHvTeJ)
