---
title: "Cache-Control 명세서 정리"
description: "HTTP 헤더 중 하나이자 HTTP 캐싱을 제어하는 Cache-Control 헤더에 대해 정리한 글입니다."
date: 2026-01-21
tags: ["네트워크", "HTTP", "HTTP 캐시", "HTTP Header", "Cache-Control"]
---

- HTTP Response 캐시를 활용하면 성능을 향상할 수 있다.
- HTTP **캐시**는 HTTP 응답 메시지를 로컬에 저장하는 **저장소**이자, 그 안에 메시지 저장, 검색, 삭제를 제어하는 하위 **시스템**을 의미한다.
- 캐시는 캐시 가능한 응답을 저장하며, 향후 동일한 요청에 대한 응답을 곧바로 하게 해주어 응답 시간과 네트워크 대역폭 소비를 줄인다.
- 공유 캐시(Shared Cache)는 여러 사용자가 재사용할 수 있도록 응답을 저장하는 캐시다. 일반적으로 중개자(CDN, 프록시 등)의 일부로 배포된다. 반면 개인 캐시(Private Cache)는 단일 사용자에게 전용되는 캐시이며, 보통 브라우저에 저장되는 것을 의미한다.
- HTTP 캐싱의 목표는 이전 응답 메시지를 재사용하여 현재 요청을 처리함으로써 성능을 크게 향상시키는 것이다. 캐시는 저장된 응답이 "validate"(캐시된 응답이 해당 요청에 대해 여전히 유효한지 확인하기 위해 원본 서버와 확인하는 과정)없이 재사용될 수 있을 때, 응답이 "fresh"하다고 간주한다. (그렇다고 캐시된 응답과 원본 서버의 응답이 항상 같은 것은 아니다.) 따라서 Fresh한 응답은 이를 재사용하여 지연 시간과 네트워크 오버헤드를 모두 줄일 수 있다. 캐시된 응답이 Fresh 상태가 아니더라도, validation(유효성 검증)이나 원본 서버에 접근할 수 없는 경우(후술) 재사용할 수 있다.
- 캐싱은 HTTP의 선택적 기능이지만, 가급적 응답을 재사용하는 것이 바람직하며, 이를 막는 요구사항이나 로컬 구성이 없는 경우에는 재사용이 기본 동작이라고 가정할 수 있다.
- HTTP 캐시 요구사항은 항상 특정 응답을 저장하고 재사용하도록 강제하기보다는, **재사용 불가능한 응답을 저장하거나 저장된 응답을 부적절하게 재사용하는 것을 방지하는 데 초점**을 맞춘다.
- Cache Key는 캐시가 응답을 선택하는 데 사용하는 정보로, 최소한 **요청 메서드와 URI로 구성**된다. 요청 메서드는 후속 요청을 처리할 때 재사용 조건을 결정한다. 오늘날 일반적으로 사용되는 많은 HTTP 캐시는 GET 응답만 캐시하므로, URI만을 Cache Key로 사용한다.
  - 캐시는 콘텐츠 협상(Content Negotiation)이 적용되는 요청 대상에 대해 여러가지 응답을 저장할 수 있다. 캐시는 `Vary` 응답 헤더의 정보를 사용하여 원본 요청의 헤더 필드 일부를 캐시 키에도 포함함으로써 이러한 응답을 구분한다. (예를 들어, 서버가 응답에 `Vary: Accept-Language`를 포함하면, 캐시는 URI 뿐 아니라 요청의 `Accept-Language` 헤더 값까지 조합하여 새로운 Cache Key를 생성한다.)
  - 캐시는 Cache Key에 추가 자료를 포함할 수 있다. 예를 들어, 브라우저 캐시(Private 캐시)는 참조 사이트의 식별자를 포함하여 캐시에 "이중 키"를 지정함으로써 일부 개인정보 위험을 방지할 수 있다. (참고: https://www.rfc-editor.org/rfc/rfc9111.html#security.timing)
- 일반적으로 캐시는 GET 요청에 대한 200(OK) 응답을 저장한다. 하지만, 리디렉션, 실패 결과(예: 404), 불완전한 결과(예: 206(Partial Content)), 그리고 GET 이외에 메서드에 대한 응답도 저장할 수는 있다. 단, 해당 메서드의 정의가 캐싱을 허용하고 캐시 키로 사용하기에 적합한 것을 정의하는 경우에 한한다.
- 캐시는 원본 서버와 통신할 수 없거나, 요청에 대한 전달 경로를 찾을 수 없을 때 "disconnected" 상태가 된다. disconnected 상태의 캐시는 특정 상황에서 오래된 응답을 제공할 수 있다. (후술) 
- 캐시가 서버로부터 받은 응답을 저장하기 위해서는 반드시 충족해야 하는 규칙들이 있다.
  - 캐시는 요청에 사용된 HTTP 메서드를 인식하고 그에 따른 캐싱 동작을 수행할 수 있어야 한다.
  - 응답 코드가 최종적인 것이어야 하며 1xx(Information) 같은 임시 상태 코드는 저장할 수 없다. 특히 206(Partial Content)이나 304(Not Modified)와 같은 특정 상태 코드는 캐시가 해당 코드의 의미와 처리 방식을 명확히 이해하고 구현하고 있을 때만 저장이 허용된다. 이는 불완전한 데이터가 잘못 캐싱되어 사용자에게 전달되는 것을 방지하기 위함이다.
  - 응답 헤더에 `no-store` 지시어가 포함되어 있다면, 캐시는 해당 응답을 저장해서는 안된다. Shared Cache의 경우에는 제약이 더 엄격해진다. 응답에 `private` 지시어가 있다면 특정 사용자(브라우저)만을 위한 응답이므로 공유 캐시에 저장될 수 없다. 또한 요청에 `Authrization` 헤더가 포함된 경우 인증된 사용자의 전용 정보일 가능성이 크기 때문에 `public`, `s-maxage`, `must-revalidate` 처럼 Shared Cache 저장을 명시적으로 허용하는 지시어가 응답에 포함되어 있어야만 저장이 가능하다.
  - 응답을 저장하기 위해서는 해당 응답이 얼마나 오랫동안 유효한지에 대한 정보나 캐싱 가능 여부를 나타내는 지시어(`public`, `Expires`, `max-age`, `s-maxage`)가 하나 이상 포함되어야 한다. 만약 이러한 지시어가 없더라도 Heuristicially(경험적) 캐싱이 가능한 상태 코드(예: 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501)라면 자체적인 알고리즘에 따라 응답을 저장할 수 있다.
  - 캐시 확장 기능을 사용하면 위에서 언급된 표준 요구사항들을 재정의할 수 있다. 또한 실무적으로 많은 캐시 서버들은 유효성 검사기(ETag, Last-Modified)나 명시적인 만료 시간이 없는 응답은 나중에 사용하기 어렵다고 판단하여 저장하지 않기도 한다. 하지만 표준 명세상으로는 이러한 응답들을 저장하는 것이 금지되어 있지는 않다.
- 캐시는 응답을 저장할 때, 모든 헤더 필드를 반드시 포함해야 한다. 다만, 다음 예외 사항들이 적용된다.
  - 응답 메시지를 전달하기 전에 `Connection` 헤더 필드 및 해당 필드에 명시된 필드들은 제거되어야 한다. 이는 캐시로 저장하기 전에 수행함으로써 구현될 수 있다.
  - 일부 필드의 의미론적 특성상 메시지 전달 전에 해당 필드를 제거해야 하며, 저장 전에 수행함으로써 구현될 수 있다. 예시는 [HTTP의 7.6.1절](https://www.rfc-editor.org/rfc/rfc9110#section-7.6.1)을 참조하라.
  - `no-cache`와 `private` 지시어는 각각 모든 캐시와 공유 캐시에 의한 헤더 필드 저장을 방지하는 값을 가질 수 있다.
    - `no-cache="field-name"` 형식을 사용하여 특정 헤더를 지정할 수 있다. 이 경우 캐시는 전체 응답을 저장할 수는 있지만, 지정된 헤더 필드는 원본 서버의 재검사(revalidation) 성공 없이는 후속 요청에 대한 응답으로 재사용해서는 안된다. 민감한 정보를 담고 있는 특정 헤더가 재사용되는 것을 방지하는 역할을 한다.
    - 기본적으로 `private`는 단일 사용자(브라우저)만을 위한 것이며, 공유 캐시(CDN, 프록시 등)에 저장되어서는 안됨을 의미한다. `private="field-name"` 형식을 사용하여 공유 캐시는 응답의 나머지 부분은 저장하고 재사용할 수 있지만, 지정된 헤더 필드만큼은 반드시 제거한 상태로 저장해야 하며 이를 다른 클라이언트에게 전달해서는 안된다. 이는 공유 캐시가 공통적인 콘텐츠는 캐싱하면서도, 개인 식별 정보나 권한 정보가 담긴 특정 헤더만 골라 제외할 수 있게 해준다.
  - 캐시가 요청을 전달할 때 사용하는 프록시에 특화된 헤더 필드는 캐시가 프록시의 식별자를 캐시 키에 포함시키지 않는 한 저장해서는 안된다. 실질적으로, `Proxy-Authenticate`, `Proxy-Authorization-Info`, `Proxy-Authorization`로 제한된다.




# Syntax
`Cache-Control`의 구문은 다음과 같다.  
`Cache-Control: <directive>, <directive>, ...`

지시어(directive)는 아래 규칙을 따라야 한다.

- 대소문자를 구분하지 않지만 소문자를 권장한다. 왜냐하면 일부 구현체에서는 대문자 지시어를 인식하지 못할 수 있기 때문이다.
- 일부 지시어는 인자가 없어도 된다. 하지만 인자가 포함된 지시어의 경우 `=`를 통해 지시어를 정의한다.
- 여러 개의 지시어는 `, `를 통해 구분한다.

예: `Cache-Control: no-cache, no-store, max-age=0, must-revalidate`

# 관련 용어

- (HTTP) Cache: 후속 요청에서 재사용하기 위해 요청과 응답을 보관하는 구현체이다. 공유 캐시(Shared Cache) 또는 개인 캐시(Private Cache)일 수 있다.
- Shared Cache: Origin Server와 Client 사이에 존재하는 캐시이다 (예: 프록시, CDN). 하나의 응답을 저장하고, 여러 사용자에게 재사용하므로 개발자는 공유 캐시에 저장될 개인화된 콘텐츠를 캐싱하지 않도록 해야 한다.
- Private Cache: 클라이언트(브라우저)에 존재하는 캐시다. 로컬 캐시 또는 브라우저 캐시라고도 한다. 단일 사용자를 위한 개인화된 콘텐츠를 저장하고 재사용할 수 있다.
- Store Response: 응답이 캐시 가능한 경우 캐시에 응답을 저장한다. 하지만 캐시된 응답이 항상 그대로 재사용되는 것은 아니다. (일반적으로 '캐시'는 응답을 저장하는 것을 의미한다.)
- Reuse Response: 후속 요청에 대해 캐시된 응답을 재사용한다.
- Revalidate Response(재검증 응답): Origin 서버에 저장된 응답이 여전히 유효한지 여부를 확인한다. 일반적으로 재검증은 조건부 요청을 통해 수행된다.
- Fresh Response: 응답이 최신(Fresh)임을 나타낸다. 이는 일반적으로 후술될 요청 지시어에 따라 후속 요청에 재사용될 수 있다.
- Stale Response: 응답이 오래된 응답임을 나타낸다. 이는 일반적으로 응답을 그대로 재사용할 수 없음을 의미한다. 캐시 저장소는 오래된 응답을 즉시 제거할 필요는 없다. 재검증 과정을 통해 응답이 오래된 상태에서 다시 최신 상태(Fresh)로 변경될 수 있기 때문이다.

# `Age` HTTP 헤더 필드
`Age` 헤더 필드는 HTTP 응답이 Origin 서버에서 생성된 후 네트워크 상의 중간 캐시(프록시 서버, CDN 등)에 얼마나 머물렀는지를 초 단위로 나타내는 값이다.  
값이 실시간으로 업데이트되는 것은 아니고, 캐시 서버가 저장하고 있던 HTTP 응답을 클라이언트에게 전달하는 시점에 그동안 경과한 시간을 계산하여 값을 갱신하는 구조이다.




# 지시어(Directives)

## 응답 지시어(Response Directives)

### `max-age`
`max-age=N`는 HTTP 응답이 생성된 후 N초 동안만 Fresh Response로 유지됨을 의미한다.  
캐시가 이 HTTP 응답을 저장하고, Fresh 상태일 동안에만 재사용할 수 있음을 나타낸다.

`max-age`는 응답을 수신한 이후로부터 경과한 시간이 아니라, Origin 서버에서 응답이 생성된 이후 경과한 시간임을 유의해야 한다.  

# Cache-Control 명세
요청에 특정 지시어가 있다고 해서, 응답에도 동일한 지시어가 포함되거나 복사되어야 함을 의미하지는 않는다.  
프록시는 캐시 구현 여부와 관계없이 전달받은 캐시 지시어를 그대로 다음 단계로 전달해야 한다.  
이는 해당 지시어가 현재 단계에 중요하지 않더라도, 요청 및 응답 경로상의 다른 단계에 적용될 수 있기 때문이다.

특정 캐시만을 대상으로 지시어를 지정하는 것은 불가능하다.

각 지시어는 토큰으로 식별되며, 대소문자를 구분하지 않는다.

# `Age` 응답 헤더 필드
RFC 9111에서 `Age` 응답 헤더 필드에 대한 정의에 따르면, '서버에서 응답이 생성된 시점 또는 Origin 서버에서 유효성 검사를 완료한 시점으로부터 경과한 시간을 추정한 값'이다.  
말이 조금 어려운데, 단순한 의미로는 "리소스가 프록시 캐싱 내에 머문 시간"을 의미한다.

대부분 `Age` 필드 값은 매우 짧은데, 값이 0이라면 Origin Server로부터 리소스를 가져온 것일 가능성이 높다. 
0이 아니라면, 일반적으로 프록시 서버의 날짜와 HTTP 응답에 포함된 `Date` 헤더 필드의 값의 차를 의미한다.

> 계산식: `Age = delta-seconds`

필드 값은 0 이상의 값이며, 시간(초)를 나타낸다.    
만약 필드 값이 리스트 형식인 경우 첫 번째 요소의 값만 사용한다.    
만약 단일 값 혹은 리스트의 첫 번째 요소의 값이 0 미만의 유효하지 않은 값인 경우, 캐시는 해당 필드를 무시해야 한다.

Age 헤더 필드가 있다는 것은, 해당 요청에 대해서 Origin 서버에서 응답이 생성되거나 유효성 검사를 완료하지 않았음을 의미한다.  
그러나 Age 헤더 필드가 없다고 해서 원본 서버에 연결되지 않았다는 것을 의미하지 않는다.

# 서버가 보내는 지시어(응답 지시어)
- `max-age`
  - 응답이 생성된 후 N초까지 응답이 최신 상태로 유지됨을 나타낸다.
  - 응답 수신 시점부터 경과된 시점이 아니라, Origin 서버에서 응답이 생성된 시점부터 

# 클라이언트가 보내는 지시어(요청 지시어)
요청 지시어는 브라우저가 서버에 데이터를 요청할 때, "나는 이런 상태의 데이터를 받고 싶다"고 요구하는 설정들이다.  
여기서 데이터는 캐시 데이터일 수도 있고, Origin 서버의 원본 데이터일 수도 있다.
해당 지시어는 캐싱에 대한 **권장 사항**이며, Origin 서버는 요청 지시어대로 캐시 정책을 구현할 수는 있지만 필수 사항은 아니다.

## `max-age`, `max-stale`, `min-fresh`
- `max-age`
  - 클라이언트가 지정한 `max-age` 초 이내의 데이터만 받겠다는 뜻이다. 만약, `max-age`가 60인데 리소스의 `Age`가 60일 경우 해당 리소스를 그대로 재사용하고, 60초를 넘은 경우 서버로 요청을 보내게 된다.
  - `max-age=5`와 같이 사용해야 하며, `max-age="5"` 와 같이 사용해선 안된다.

- `max-stale`
  - 유효 기간이 지난 캐시 데이터더라도, 클라이언트가 지정한 `max-stale` 초 이내의 데이터도 재사용하겠다는 의미다.
  - `max-stale` 값이 없다면 유효 기간이 지난 데이터에 대한 요청은 반드시 서버로 요청을 보낸다.

- `min-fresh`
  - 클라이언트가 현재 `Age`에 N초를 더한 시간 동안에도 여전히 Fresh함을 유지하는 응답을 원할 때 사용한다. 즉, 최소한 `min-fresh`에 지정한 시간만큼은 더 신선한 상태로 남아있을 응답을 요구하는 것이다.
  - 
    - 클라이언트가 최소 N초 동안 유효한 저장된 응답을 허용함을 나타낸다. 클라이언트는 `min-fresh`에 지정한 초 동안 최신 상태를 유지하는 응답을 요구한다. 응답의 Fresh 유지 기간이 `Age + min_fresh` 보다 이상인 응답을 선호한다.  
    - `min-fresh=20`과 같이 사용해야 하며, `min-fresh="20"` 과 같이 사용해선 안된다.

# 참고
- [RFC 9111 - HTTP Caching](https://www.rfc-editor.org/rfc/rfc9111.html)
- [RFC 9110 - HTTP](https://www.rfc-editor.org/rfc/rfc9110.html)
