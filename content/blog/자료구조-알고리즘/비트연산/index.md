---
title: "비트 연산"
description: "비트 연산에 대해 학습한 내용을 정리한 글입니다."
date: 2026-01-17
tags: [ "알고리즘", "비트 연산" ]
series: "알고리즘"
---

# 비트 연산의 정의와 기초 논리

비트 연산은 데이터를 비트(Bit) 단위로 조작하는 연산 방식이다.  
컴퓨터는 모든 정보를 이진수 형태로 저장/처리하며, 비트 연산은 이러한 개별 비트의 상태를 직접 제어함으로써 최적의 성능과 메모리 효율을 달성하게 해준다.  
비트 연산은 산술 연산보다 CPU 사이클 소모가 훨씬 적기에 임베디드 시스템, 그래픽스, 암호화 및 네트워크 프로토콜 설계에서 핵심적인 역할을 수행한다.

가장 기본적인 비트 연산자는 AND(&), OR(|), XOR(^), NOT(~) 이 있다.  
기본적으로 불 대수의 원리를 따르며 두 비트의 사이의 관계를 정의한다.

| A | B | A & B | A \| B | A ^ B | ~A |
|:-:|:-:|:-----:|:------:|:-----:|:--:|
| 0 | 0 |   0   |   0    |   0   | 1  |
| 0 | 1 |   0   |   1    |   1   | 1  | 
| 1 | 0 |   0   |   1    |   1   | 0  |
| 1 | 1 |   1   |   1    |   0   | 0  |

# 시프트(Shift) 연산과 산술적 의미
시프트 연산은 비트 열을 왼쪽이나 오른쪽으로 밀어내는 연산이다.  
이를 활용하면 정수형 데이터의 배수 연산을 매우 빠르게 처리할 수 있다.

왼쪽 시프트(`<<`)는 비트들을 왼쪽으로 이동하며, 오른쪽에 새로 생기는 빈 공간에는 0을 할당한다.  
비트를 왼쪽으로 한 칸 밀 때마다 원래 값에 2를 곱한 것과 같은 효과를 낸다. (예: x << 3 == x * 2^3)

오른쪽 시프트(`>>`)는 비트들을 오른쪽으로 이동하며, 이동 방식에 따라 논리적 시프트와 산술적 시프트로 나뉜다.  
논리적 시프트는 왼쪽에 새로 생기는 빈 공간을 0으로 할당한다.  
산술적 시프트는 부호 비트를 유지하며 빈 공간을 채운다. 이는 음수 값을 유지하며 2로 나누는 연산을 수행할 때 필수적이다.  

# 비트 연산 활용
## 비트 마스크
비트 연산의 가장 대표적인 활용 사례는 비트마스크이다.  
이는 여러 Boolean 상태 정보를 하나의 정수형 변수에 담아 관리하는 기법이다.

예를 들어 8비트 정수 하나로 8가지 옵션의 ON/OFF 상태를 표현

## 알고리즘 최적화
어떤 정수가 2의 거듭제곱인지 판별할 때, 반복문을 돌리는 대신 `n & (n - 1) == 0` 인지만 판별하면 된다.  
예를 들어 N이 4일 경우, 4 & 3 == 100 & 011 == 0 이 된다.  
반대로 N이 5일 경우, 5 & 4 == 100 & 101 == 100 이 된다.

또한 홀수와 짝수를 판별할 때 모듈러 연산(n % 2) 대신, 가장 낮은 자리 비트를 검사하는 `n & 1` 연산을 사용하면 하드웨어 수준에서 더 빠르게 처리된다.  
홀수의 경우 가장 낮은 자리의 비트는 0이, 짝수인 경우 1이 와야 한다는 점을 이용한 것이다.  
`n & 1`의 결과가 0일 경우 짝수, 1일 경우 홀수가 된다.  
예를 들어 N이 4일 경우, 4 & 1 == 100 & 1 == 0이, N이 5일 경우 5 & 1 == 101 & 1 == 1

# 정리
비트 연산은 소스 코드의 가독성을 해칠 수 있다. 비트 연산을 모르는 개발자나 연산 자체가 한눈에 들어오지 않는 경우가 있기 때문이다.  
하지만 시스템 성능을 끌어올려야 하는 상황에서는 대체 불가능한 도구이다.  
현대의 컴파일러들은 산술 연산을 비트 연산으로 자동 최적화해주기도 하지만, 개발자가 비트 수준에서 데이터 구조를 이해하고 직접 조작할 수 있는 능력은 효율적인 데이터 구조 설계와 저수준의 시스템을 프로그래밍하는 중요한 역량이 될 것이다.
