---
title: "[JSCODE] - OS 면접 스터디 5주차"
description: "[JSCODE] - OS 면접 스터디 5주차"
date: 2023-12-06
update: 2023-12-06
tags: ["operating-system", "interview"]
series: "운영체제 면접 스터디"
---

## 가상 주소와 물리 주소(실주소)에 대해 설명해주세요.
```text
가상 주소의 경우 프로세스마다 독립적으로 가지는 주소 공간입니다. 모두 0번지부터 시작합니다.
물리 주소의 경우 프로세스가 실제 메모리에 올라가는 위치입니다.
```

## 가상 주소를 물리 주소(실주소)로 어떻게 변환할까요?
```text
MMU라는 하드웨어에 의해 변환됩니다.
CPU가 가진 논리 주소를 MMU로 전달하게 되고, 메모리 매핑 전략에 따라 달라지는 방법을 통해 물리 주소로 변환하게 됩니다.

추가)
이 MMU는 Relocation Register와 Limit Register를 이용해 계산합니다.
Relocation Register는 현재 사용 가능한 물리 주소의 최하위 주소 값을 가집니다.
Limit Register는 논리 주소의 범위를 가집니다. 이 값을 통해 해당 프로세스의 물리적 주소를 벗어나지 않도록 막을 수 있습니다.

추가)
OS가 이를 계산하여 변환하지 않는 이유는, HW를 이용하는 것보다 훨씬 느리기 때문입니다.
HW는 값만 넣어주면 빠르게 계산되어 결과를 얻을 수 있는 반면,
OS에게 위임하게 된다면 컨텍스트 스위칭으로 인한 추가적인 오버헤드가 발생하기 때문입니다. 
```

## 절대 주소 지정과 상대 주소 지정의 차이점은 뭘까요?
```text
절대 주소 지정은 컴파일러에 의해 만들어진 논리 주소가, 실제 메모리에 적재될 때 그대로 사용되어 적재되는 것을 의미합니다.
상대 주소 지정은 이 논리 주소와는 상관없이 메모리에 적재될 때, 그리고 적재된 이후에 동적으로 물리 주소를 할당하는 것을 의미합니다.
```

## 메모리 분할에 대해 설명해주세요.
```text
프로세스를 동일한 크기의 메모리 블록으로 나누는 것을 의미합니다.
이 페이지 분할을 통해 프로세스에서 사용되는 메모리만을 메인 메모리에 적재하여 사용할 수 있게 되어
메모리를 효율적으로 사용할 수 있게 됩니다.
```

## 메모리 배치 기법(메모리 관리 전략)에 대해 설명해주세요.
```text
프로세스를 메인 메모리에 적재할 때 어떤 방식으로 적재할 것인가에 대한 방법입니다.

방법으로 크게 나누면 연속 메모리 할당과 불연속 메모리 할당으로 나눌 수 있습니다.
```

```text
[연속 메모리 할당]
단일 프로그래밍 환경 -> 프로세스 1개를 통채로 메인 메모리에 적재
다중 프로그래밍 환경 -> 고정 분할 방법: 메인 메모리를 여러 개의 고정된 크기로 나누고 해당 크기에 프로세스를 적재하는 방식. 내부 단편화 발생
                -> 가변 분할 방법: 고정된 크기를 없애고 프로세스가 필요한 만큼만 메모리에 적재. 외부 단편화 발생. 최초 적합, 최적 적합, 최악 적합

[불연속 메모리 할당]
고정 분할: 페이징 ->
가변 분할: 세그멘테이션 -> 
```

## 외부 단편화와 내부 단편화의 차이가 뭔가요?
```text
외부 단편화는 프로세스가 적재될 수 있는 공간이지만, 그 크기가 작아 들어가지 못하는 공간입니다.
내부 단편화는 메인 메모리 상에 일정 크기의 공간 안에 그 공간보다 더 작은 프로세스가 할당되어 생기는 공간을 의미합니다.

예를 들어 설명해보면, 외부 단편화는 음식을 담을 그릇이 있지만 이 그릇에 비해 음식의 크기가 더 커서 담지 못하는 현상을 의미합니다.
내부 단편화는 음식을 그릇에 담았지만, 음식의 크기가 그릇에 비해 매우 작아서 빈공간이 생기는 개념입니다.
```

## 메모리 배치 기법중 하나인 colaescing(통합)에 대해 설명해주세요.
```text
메인 메모리에 할당된 프로세스가 종료되면 해당 프로세스가 차지한 공간과 인접한 빈 공간이 있는지 확인하고
이 공간들을 하나로 통합하는 과정입니다.
이를 통해 외부 단편화를 최소화할 수 있습니다.
```

## 메모리 배치 기법중 하나인 compaction(압축)에 대해 설명해주세요.
```text
메인 메모리에 적재된 프로세스들을 최대한 한 쪽으로 모두 모으는 기법입니다.
이를 통해 외부 단편화를 최소화할 수 있습니다.

하지만 압축하는 시간동안 시스템은 모든 일을 중지해야 한다는 심각한 단점이 있습니다.
```

## 메모리 배치 기법중 하나인 버디 시스템에 대해 설명해주세요.
```text
메인 메모리를 항상 2^N 크기로 할당합니다. 
그 후 프로세스를 적재할 때, 가능한 공간을 절반씩 쪼개면서 들어갈 수 있는 최적의 공간을 찾아 넣습니다.
프로세스를 적재할 때는 최대한 메모리의 낮은 위치에 적재하는 식으로 진행됩니다.

외부 단편화를 최소화할 수 있습니다.

만약 프로세스가 할당 해제되고 자신의 Buddy가 존재하고 비어있다면 Merge합니다.
```

## 가상 메모리에 대해 설명해주세요.
```text
메인 메모리에 프로세스의 모든 메모리를 올리지 않고 필요한 메모리만 올릴 수 있도록,
필요하지 않은 부분의 경우 디스크에 일부 공간에 저장하는 개념을 의미합니다.

가상 메모리를 사용하는 기법으로는 페이징과 세그멘테이션이 있습니다.
```

## 메모리 배치 기법중 하나인 페이징에 대해 설명해주세요.
```text
프로세스의 메모리 영역을 크기가 동일한 페이지로 나눕니다. 동시에 메인 메모리도 동일한 크기의 프레임으로 나눠 놓습니다.
그 후 프로세스의 일부 필요한 페이지를 프레임에 적재하고 이를 페이지 테이블에 기록합니다.
물리 주소는 이 페이지 테이블을 통해 찾을 수 있습니다.

빈 프레임이 존재만 한다면 메모리 공간 어디에든 적재할 수 있어 공간을 효율적으로 사용할 수 있으며,
외부 단편화는 발생하지 않지만 내부 단편화가 발생할 수 있다는 특징이 있습니다.
```

## 메모리 배치 기법중 하나인 세그멘테이션에 대해 설명해주세요.
```text
프로그램을 구성하는 논리적인 단위로 메모리를 나누게 됩니다. 이를 세그먼트라고 합니다.
이 세그먼트가 메인 메모리에 적재되면 세그먼트 테이블에 이를 기록하고, 이 정보를 통해 물리 주소를 조회할 수 있습니다.
보통 최초 적합이나 최소 적합 알고리즘을 사용합니다.
```

## 페이징과 세그멘테이션의 비교 (개인적으로 추가)
```text
페이징은 용량이 작은 메인 메모리 크기가 동시에 많이 실행될 수 있다. 
세그멘테이션은 페이징 기법의 장점에 추가로 프로그램을 논리적으로 독립된 주소 공간으로 나누고 쉽게 공유 및 보호할 수 있다.
```

## Swapping이란 무엇인가요?
```text
메인 메모리에 새로운 프로세스를 적재할 공간이 없을 경우, 메인 메모리에 있는 특정 프로세스를 디스크의 가상 메모리에 잠시 저장해뒀다가
공간이 생기면 다시 가져와 실행하는 개념을 의미합니다.
```

## Swapping의 과정을 설명해 주세요.
```text
우선 CPU가 요청하는 논리 주소를 MMU를 통해 물리 주소로 변환하게 됩니다.
이때 물리 주소에 원하는 메모리 블록이 없다면, 디스크에서 해당 메모리 블록을 메인 메모리에 적재해야 합니다.
만약 메인 메모리에 공간이 없다면, 메인 메모리에 있는 특정 메모리 블록을 디스크로 이동을 하고 요구되는 메모리 블록을 메인 메모리에 적재합니다.
만약 메인 메모리에 공간이 있다면, 바로 디스크에서 메모리 블록을 가져와 적재합니다.
그 후 페이지 테이블을 업데이트 하는 식으로 스와핑이 진행됩니다.
```

## Swapping의 장단점을 설명해 주세요.
```text
장점으로는, 가상 메모리를 활용하여 필요한 메모리 블록만 메인 메모리에 올린다는 점에서 공간을 효율적으로 사용한다는 장점이 있습니다.
하지만 단점으로, 스와핑하는 과정은 디스크 I/O 작업이 포함되기 때문에 오버헤드가 발생한다는 단점이 있습니다.
```

## 페이지 교체에 대해서 설명해주세요.
```text
디스크에서 페이지를 메인 메모리에 적재하려고 할 때, 빈 공간이 없어서 기존에 적재되어 있는 페이지를 디스크로 이동시키고
디스크에 있는 페이지를 메인 메모리에 적재하는 과정을 의미합니다.

대표적인 페이지 교체 알고리즘으로는, FIFO, LRU, LFU, Clock 알고리즘이 있습니다.
```

## 페이지 부재를 최소화하려면 어떻게 해야 하나요?
```text
상식적으로 생각을 해봤을 때, CPU가 원하는 페이지가 최대한 메인 메모리에 적재가 되어 있는 상태여야 합니다.
이를 위해서는 적절한 페이지 교체 알고리즘을 선택하거나, 페이지의 크기도 적절히 조절을 하는 것이 도움이 될 수 있습니다.
```

## 페이지 교체 알고리즘 FIFO에 대해 설명 해주세요.
```text
메인 메모리에 올라간 페이지의 순서대로 스와핑 아웃을 하는 방식입니다.
이는 아무래도 구현은 쉽지만 페이지 교체를 최소화하는 방법이 아닐 확률이 큽니다.
```

## 페이지 교체 알고리즘 LRU에 대해 설명 해주세요.
```text
Least Recently Used의 약자로, 가장 오랫동안 사용되지 않은 페이지를 스와핑 아웃시키는 방식입니다.

페이지의 실제 패턴을 고려했기에 더 적은 페이지 교체가 일어날 수 있습니다.
하지만 알고리즘을 위한 추가 연산이 들어가기에 오버헤드가 발생합니다.
```

## 페이지 교체 알고리즘 LFU에 대해 설명 해주세요.
```text
Least Frequently Used의 약자로, 가장 적게 사용된 페이지를 스와핑 아웃하는 방식입니다.

실제 페이지 사용 패턴을 고려했기에 페이지 교체가 적게 일어날 수 있습니다.
하지만 알고리즘을 위한 추가적인 연산이 들어가기에 오버헤드가 발생합니다.
```

## 페이지 교체 알고리즘 클럭 알고리즘에 대해 설명해주세요.
```text
페이지들을 시계처럼 원형 큐에 저장합니다.
이 큐에 프레임을 저장할 때, 참조 여부를 나타내는 비트도 함께 저장합니다.
만약 페이지가 참조되면 이 비트를 1로 바꾸게 됩니다.

그리고 시계침처럼 이 원형큐를 계속해서 순회하며 바라보는 인덱스가 있는데요.
만약 한 바퀴를 도는 동안 참조되지 않았다면 비트를 1에서 0으로 수정하고, 그 후에도 한 바퀴 도는 동안 참조되지 않으면
해당 페이지를 교체하는 방식으로 이루어집니다.

이 알고리즘은 구현이 간단하면서 동시에 페이지 교체가 적게 일어나는 방식으로 알고 있습니다.
```

## 쓰레싱에 대해 설명해주세요.
```text
실제 프로세스 동작보다 페이지 교체에 더 많은 시간을 쏟게 되는 현상을 의미합니다.

이를 해결하기 위한 알고리즘으로 워킹 알고리즘과 페이지 부재 빈도 알고리즘이 있습니다.
```

## 워킹 알고리즘에 대해 설명해주세요.
```text
현재 프로세스가 실행 중인 상황에서 가장 중점적으로 사용되는 메모리 영역을 워킹 셋이라고 합니다.
이 워킹 셋을 메모리에 동시에 적재할 수 있도록 보장하여 페이징 부재 빈도를 낮추는 방식의 알고리즘 입니다. 
```

## 페이지 부재 빈도 알고리즘에 대해 설명해주세요.
```text
프로세스의 페이지 부재율을 주기적으로 조사하고 이 값을 근거로 해당 프로세스에 할당할 메모리 양을 동적으로 조절하는 알고리즘입니다.

해당 프로세스의 페이지 부재율이 높으면, 그만큼 이 프로세스에 할당된 페이지의 양이 적다는 의미이므로 할당할 수 있는 페이지의 양을 증가합니다.
이때 페이지 부재율이 높은 프로세스의 페이지 할당률을 낮춰 그 수를 조절한다.
```

------------------------

## 이화여대 강의 정리

```text
프로세스가 메모리에 적재될 때, 메모리의 어느 위치에 적재할 지에 대한 방법(주소 바인딩)이 3가지 있다.

1. Compile Time Binding
프로세스의 가상 주소를 실제 주소로 그대로 사용한다.
이는 프로세스 2개 이상을 동시에 메모리에 적재하기에 위험성이 있다.
컴파일러는 절대 코드(Absolute Code)를 생성한 경우 사용되는 방법이다.

2. Load Time Binding
프로세스가 메모리에 적재될 때(Load time) 무작위로 적재가 되고, 변경되지 않는다.
컴파일러는 재배치가능코드(Relocatable Code)를 생성한 경우 가능한 방법이다.

3. Run Time Binding
프로세스가 메모리에 적재될 때 무작위로 적재되지만, 동적으로 변경이 가능하다.
현 시대에 흔히 사용되는 방법이다.
```

```text
프로그래밍 언어로 변수나 메서드를 선언한다.
그리고 컴파일하면 실행 파일(프로그램)이 생성된다.
이 프로그램은 자체적으로 0번지부터 시작하는 메모리 주소가 있다.
컴파일러가 이 실행 파일을 만들 때 알아서 메모리를 할당한다.

프로그램이 실행되어 프로세스가 되어도 자체적인 주소 공간을 사용한다.
이를 가상 주소라고 한다.
실제 주소는 실제 메모리의 주소 공간을 의미한다.

CPU는 PCB에 있는 Program Counter가 가리키는 주소를 바라본다.
이때 PC가 가리키는 주소는 가상 주소이다.
(왜? 물리 주소는 항상 바뀔 수 있고, 잘못하면 다른 프로세스의 명령어를 실행한다. 논리주소는 바뀌지 않고 매번 동일한 곳을 가리키기 때문)

따라서 이 가상 주소를 통해 실제 주소를 가리키려면 변환 과정이 필요하다.

이는 MMU(Memory Management Unit)라는 하드웨어에 의해 실행된다.
(왜 운영체제가 아닌 하드웨어? 빠른 속도로 메모리에 접근해야한다. 그런데 운영체제에 의해 관리되면 오버헤드가 발생한다.)

(연속 할당에서의) MMU는 논리 주소를 relocation register와 limit register를 통해 물리 주소로 변환한다.
relocation register는 실행하려는 프로세스의 물리적 주소의 시작 위치를 가리킨다.
limit register는 실행하려는 프로세스가 가지는 주소의 전체 범위를 가진다.
따라서 논리주소 + relocation register의 값 = 물리 주소가 된다.
이떄, limit register는 해당 프로세스가 가지는 물리적 주소의 범위를 벗어나서 명령을 실행하는 경우를 막기 위해 존재한다. 
```

```text
[Dynamic Loading]
프로세스 전체의 메모리 공간을 실제 메모리 영역에 적재하지 않고, 해당 메모리 공간이 필요로 할 때 메모리에 적재하는 것을 의미한다.

[Swapping]
메모리에 적재되어 있는 프로세스의 일부 페이지를 디스크로 쫓아내는 것을 의미한다.
```

```text
[Allocation of Physical Memory]
1. 연속 할당
하나의 프로세스가 메모리에 적재될 때, 통채로 올라가는 것을 의미한다.

2. 불연속 할당
하나의 프로세스에 대해서도 페이징 단위로 나누어 메모리에 적재하는 것을 의미한다.
더군다나 같은 프로세스의 페이지라고 해도 메인메모리 상에서 연속적이지 않다.

2-1. 페이징 기법
프로세스의 논리 주소를 동일한 사이즈의 페이지로 나눈다.
일부 페이지는 스왑 메모리에, 일부 페이지는 메인 메모리에 저장한다.
주소 변환은 '페이지 테이블'을 통해 이뤄진다.

페이지 테이블을 통한 주소 변환은 다음의 과정으로 이뤄진다.
1. CPU가 가진 논리 주소로 페이지 테이블에서 물리 주소로 변환한다.
2. CPU가 같이 가지고 있는 offset 값으로 물리 주소로부터 offset 만큼의 주소를 추가한다.

그런데 이 페이지 테이블은 4byte로 나누고, 실행되는 프로세스가 32비트인 경우, 각 프로세스마다 100만 행의 페이지 테이블을 가진다.
이때 중요한 점은 컨텍스트 스위칭이 발생할 때 이 페이지 테이블도 함께 초기화된다.
따라서 효율측면에서 좋지 않다. 따라서 캐싱 기법을 통해 성능을 개선한다.
```