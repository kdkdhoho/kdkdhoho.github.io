---
title: "OS 면접 스터디 5주차"
description: "OS 면접 스터디 5주차 질답"
date: 2023-12-06
update: 2023-12-06
tags: ["operating-system", "interview"]
series: "운영체제 면접 스터디"
---

## 이화여대 강의 정리

```text
프로세스가 메모리에 적재될 때, 메모리의 어느 위치에 적재할 지에 대한 방법(주소 바인딩)이 3가지 있다.

1. Compile Time Binding
프로세스의 가상 주소를 실제 주소로 그대로 사용한다.
이는 프로세스 2개 이상을 동시에 메모리에 적재하기에 위험성이 있다.
컴파일러는 절대 코드(Absolute Code)를 생성한 경우 사용되는 방법이다.

2. Load Time Binding
프로세스가 메모리에 적재될 때(Load time) 무작위로 적재가 되고, 변경되지 않는다.
컴파일러는 재배치가능코드(Relocatable Code)를 생성한 경우 가능한 방법이다.

3. Run Time Binding
프로세스가 메모리에 적재될 때 무작위로 적재되지만, 동적으로 변경이 가능하다.
현 시대에 흔히 사용되는 방법이다.
```

```text
프로그래밍 언어로 변수나 메서드를 선언한다.
그리고 컴파일하면 실행 파일(프로그램)이 생성된다.
이 프로그램은 자체적으로 0번지부터 시작하는 메모리 주소가 있다.
컴파일러가 이 실행 파일을 만들 때 알아서 메모리를 할당한다.

프로그램이 실행되어 프로세스가 되어도 자체적인 주소 공간을 사용한다.
이를 가상 주소라고 한다.
실제 주소는 실제 메모리의 주소 공간을 의미한다.

CPU는 PCB에 있는 Program Counter가 가리키는 주소를 바라본다.
이때 PC가 가리키는 주소는 가상 주소이다.
(왜? 물리 주소는 항상 바뀔 수 있고, 잘못하면 다른 프로세스의 명령어를 실행한다. 논리주소는 바뀌지 않고 매번 동일한 곳을 가리키기 때문)

따라서 이 가상 주소를 통해 실제 주소를 가리키려면 변환 과정이 필요하다.

이는 MMU(Memory Management Unit)라는 하드웨어에 의해 실행된다.
(왜 운영체제가 아닌 하드웨어? 빠른 속도로 메모리에 접근해야한다. 그런데 운영체제에 의해 관리되면 오버헤드가 발생한다.)

(연속 할당에서의) MMU는 논리 주소를 relocation register와 limit register를 통해 물리 주소로 변환한다.
relocation register는 실행하려는 프로세스의 물리적 주소의 시작 위치를 가리킨다.
limit register는 실행하려는 프로세스가 가지는 주소의 전체 범위를 가진다.
따라서 논리주소 + relocation register의 값 = 물리 주소가 된다.
이떄, limit register는 해당 프로세스가 가지는 물리적 주소의 범위를 벗어나서 명령을 실행하는 경우를 막기 위해 존재한다. 
```

```text
[Dynamic Loading]
프로세스 전체의 메모리 공간을 실제 메모리 영역에 적재하지 않고, 해당 메모리 공간이 필요로 할 때 메모리에 적재하는 것을 의미한다.

[Swapping]
메모리에 적재되어 있는 프로세스의 일부 페이지를 디스크로 쫓아내는 것을 의미한다.
```

```text
[Allocation of Physical Memory]
1. 연속 할당
하나의 프로세스가 메모리에 적재될 때, 통채로 올라가는 것을 의미한다.

2. 불연속 할당
하나의 프로세스에 대해서도 페이징 단위로 나누어 메모리에 적재하는 것을 의미한다.
더군다나 같은 프로세스의 페이지라고 해도 메인메모리 상에서 연속적이지 않다.

2-1. 페이징 기법
프로세스의 논리 주소를 동일한 사이즈의 페이지로 나눈다.
일부 페이지는 스왑 메모리에, 일부 페이지는 메인 메모리에 저장한다.
주소 변환은 '페이지 테이블'을 통해 이뤄진다.
```

---------------------------------------------------------------

## 가상 주소와 물리 주소(실주소)에 대해 설명해주세요.
```text
가상 주소의 경우 프로세스마다 독립적으로 가지는 주소 공간입니다. 모두 0번지부터 시작합니다.
물리 주소의 경우 프로세스가 실제 메모리에 올라가는 위치입니다.
```

## 가상 주소를 물리 주소(실주소)로 어떻게 변환할까요?
```text
MMU라는 하드웨어에 의해 변환됩니다.
MMU에는 프로세스의 물리적 주소의 시작 위치를 가리키는 relocatation 레지스터가 있는데,
CPU가 가리키는 논리 주소에 이 relocation 레지스터의 값을 더하면, 원하는 곳의 물리 주소를 구할 수 있습니다.
```

## 절대 주소 지정과 상대 주소 지정의 차이점은 뭘까요?
```text
절대 주소 지정은 컴파일러에 의해 만들어진 논리 주소가, 실제 메모리에 적재될 때 그대로 사용되어 적재되는 것을 의미합니다.
상대 주소 지정은 이 논리 주소와는 상관없이 메모리에 적재될 때, 그리고 적재된 이후에 동적으로 물리 주소를 할당하는 것을 의미합니다.
```

## 메모리 분할에 대해 설명해주세요.
```text

```

## 메모리 배치 기법(메모리 관리 전략)에 대해 설명해주세요.
## 외부 단편화와 내부 단편화의 차이가 뭔가요?
## 메모리 배치 기법중 하나인 colaescing(통합)에 대해 설명해주세요.
## 메모리 배치 기법중 하나인 compaction(압축)에 대해 설명해주세요.
## 메모리 배치 기법중 하나인 버디 시스템에 대해 설명해주세요.
## 메모리 배치 기법중 하나인 페이징에 대해 설명해주세요.
## 메모리 배치 기법중 하나인 세그멘테이션에 대해 설명해주세요.
## 가상 메모리에 대해 설명해주세요.
## Swapping이란 무엇인가요?
## Swapping의 과정을 설명해 주세요.
## Swapping의 장단점을 설명해 주세요.
## 페이지 교체에 대해서 설명해주세요.
## 페이지 부재를 최소화하려면 어떻게 해야 하나요?
## 페이지 교체 알고리즘 FIFO에 대해 설명 해주세요.
## 페이지 교체 알고리즘 LRU에 대해 설명 해주세요.
## 페이지 교체 알고리즘 LFU에 대해 설명 해주세요.
## 페이지 교체 알고리즘 클럭 알고리즘에 대해 설명해주세요.
## 쓰레싱에 대해 설명해주세요.
## 워킹 알고리즘에 대해 설명해주세요.
## 페이지 부재 빈도 알고리즘에 대해 설명해주세요.